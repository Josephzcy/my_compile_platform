// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_object_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_object_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "geometry.pb.h"
#include "data_source.pb.h"
#include "calib_param.pb.h"
#include "vehicle_signal.pb.h"
#include "object_warning.pb.h"
#include "camera.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_object_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_object_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_object_2eproto;
namespace perception {
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class ObjectList;
class ObjectListDefaultTypeInternal;
extern ObjectListDefaultTypeInternal _ObjectList_default_instance_;
class Object_FusionInfo;
class Object_FusionInfoDefaultTypeInternal;
extern Object_FusionInfoDefaultTypeInternal _Object_FusionInfo_default_instance_;
class Object_ImageInfo;
class Object_ImageInfoDefaultTypeInternal;
extern Object_ImageInfoDefaultTypeInternal _Object_ImageInfo_default_instance_;
class Object_VehicleRigid;
class Object_VehicleRigidDefaultTypeInternal;
extern Object_VehicleRigidDefaultTypeInternal _Object_VehicleRigid_default_instance_;
class Object_WorldInfo;
class Object_WorldInfoDefaultTypeInternal;
extern Object_WorldInfoDefaultTypeInternal _Object_WorldInfo_default_instance_;
}  // namespace perception
PROTOBUF_NAMESPACE_OPEN
template<> ::perception::Object* Arena::CreateMaybeMessage<::perception::Object>(Arena*);
template<> ::perception::ObjectList* Arena::CreateMaybeMessage<::perception::ObjectList>(Arena*);
template<> ::perception::Object_FusionInfo* Arena::CreateMaybeMessage<::perception::Object_FusionInfo>(Arena*);
template<> ::perception::Object_ImageInfo* Arena::CreateMaybeMessage<::perception::Object_ImageInfo>(Arena*);
template<> ::perception::Object_VehicleRigid* Arena::CreateMaybeMessage<::perception::Object_VehicleRigid>(Arena*);
template<> ::perception::Object_WorldInfo* Arena::CreateMaybeMessage<::perception::Object_WorldInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace perception {

enum Object_ObjectType : int {
  Object_ObjectType_kNone = 0,
  Object_ObjectType_kVehicle = 1,
  Object_ObjectType_kPed = 2,
  Object_ObjectType_kBike = 3,
  Object_ObjectType_kCone = 4,
  Object_ObjectType_kVehicleWheel = 5,
  Object_ObjectType_kVehiclePlate = 6,
  Object_ObjectType_kPedHead = 7,
  Object_ObjectType_kSmallTrafficSign = 10,
  Object_ObjectType_kBigTrafficSign = 11,
  Object_ObjectType_kTrafficLight = 12,
  Object_ObjectType_kAnimals = 13,
  Object_ObjectType_kVehicleLight = 14,
  Object_ObjectType_kStreetLamp = 15,
  Object_ObjectType_kObjectTypeNum = 16,
  Object_ObjectType_Object_ObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_ObjectType_Object_ObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_ObjectType_IsValid(int value);
constexpr Object_ObjectType Object_ObjectType_ObjectType_MIN = Object_ObjectType_kNone;
constexpr Object_ObjectType Object_ObjectType_ObjectType_MAX = Object_ObjectType_kObjectTypeNum;
constexpr int Object_ObjectType_ObjectType_ARRAYSIZE = Object_ObjectType_ObjectType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_ObjectType_descriptor();
template<typename T>
inline const std::string& Object_ObjectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_ObjectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_ObjectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_ObjectType_descriptor(), enum_t_value);
}
inline bool Object_ObjectType_Parse(
    const std::string& name, Object_ObjectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_ObjectType>(
    Object_ObjectType_descriptor(), name, value);
}
enum Object_VehiclePose : int {
  Object_VehiclePose_kInvalid = 0,
  Object_VehiclePose_kLeftTail = 1,
  Object_VehiclePose_kMidTail = 2,
  Object_VehiclePose_kRightTail = 3,
  Object_VehiclePose_kLeftHead = 4,
  Object_VehiclePose_kMidHead = 5,
  Object_VehiclePose_kRightHead = 6,
  Object_VehiclePose_kLeftSide = 7,
  Object_VehiclePose_kRightSide = 8,
  Object_VehiclePose_kLeftCutIn = 9,
  Object_VehiclePose_kRightCutIn = 10,
  Object_VehiclePose_kLeftCutOut = 11,
  Object_VehiclePose_kRightCutOut = 12,
  Object_VehiclePose_kOccluded = 13,
  Object_VehiclePose_kUnknownPose = 20,
  Object_VehiclePose_Object_VehiclePose_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_VehiclePose_Object_VehiclePose_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_VehiclePose_IsValid(int value);
constexpr Object_VehiclePose Object_VehiclePose_VehiclePose_MIN = Object_VehiclePose_kInvalid;
constexpr Object_VehiclePose Object_VehiclePose_VehiclePose_MAX = Object_VehiclePose_kUnknownPose;
constexpr int Object_VehiclePose_VehiclePose_ARRAYSIZE = Object_VehiclePose_VehiclePose_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_VehiclePose_descriptor();
template<typename T>
inline const std::string& Object_VehiclePose_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_VehiclePose>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_VehiclePose_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_VehiclePose_descriptor(), enum_t_value);
}
inline bool Object_VehiclePose_Parse(
    const std::string& name, Object_VehiclePose* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_VehiclePose>(
    Object_VehiclePose_descriptor(), name, value);
}
enum Object_AnchorPtInfo : int {
  Object_AnchorPtInfo_kVehicleHead = 0,
  Object_AnchorPtInfo_kVehicleTail = 1,
  Object_AnchorPtInfo_kVehicleFrontWheel = 2,
  Object_AnchorPtInfo_kVehicleRearWheel = 3,
  Object_AnchorPtInfo_kVehicleSomeWheel = 4,
  Object_AnchorPtInfo_kDetectBottomCenter = 5,
  Object_AnchorPtInfo_kVehicleLeftFrontWheel = 6,
  Object_AnchorPtInfo_kVehicleLeftRearWheel = 7,
  Object_AnchorPtInfo_kVehicleRightFrontWheel = 8,
  Object_AnchorPtInfo_kVehicleRightRearWheel = 9,
  Object_AnchorPtInfo_Object_AnchorPtInfo_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_AnchorPtInfo_Object_AnchorPtInfo_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_AnchorPtInfo_IsValid(int value);
constexpr Object_AnchorPtInfo Object_AnchorPtInfo_AnchorPtInfo_MIN = Object_AnchorPtInfo_kVehicleHead;
constexpr Object_AnchorPtInfo Object_AnchorPtInfo_AnchorPtInfo_MAX = Object_AnchorPtInfo_kVehicleRightRearWheel;
constexpr int Object_AnchorPtInfo_AnchorPtInfo_ARRAYSIZE = Object_AnchorPtInfo_AnchorPtInfo_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_AnchorPtInfo_descriptor();
template<typename T>
inline const std::string& Object_AnchorPtInfo_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_AnchorPtInfo>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_AnchorPtInfo_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_AnchorPtInfo_descriptor(), enum_t_value);
}
inline bool Object_AnchorPtInfo_Parse(
    const std::string& name, Object_AnchorPtInfo* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_AnchorPtInfo>(
    Object_AnchorPtInfo_descriptor(), name, value);
}
enum Object_MeasureType : int {
  Object_MeasureType_kVehicleMeasureHeadReg = 0,
  Object_MeasureType_kVehicleMeasureTailReg = 1,
  Object_MeasureType_kVehicleMeasureDetect = 2,
  Object_MeasureType_kVehicleMeasureWheel = 3,
  Object_MeasureType_kVehicleMeasurePlate = 4,
  Object_MeasureType_Object_MeasureType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_MeasureType_Object_MeasureType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_MeasureType_IsValid(int value);
constexpr Object_MeasureType Object_MeasureType_MeasureType_MIN = Object_MeasureType_kVehicleMeasureHeadReg;
constexpr Object_MeasureType Object_MeasureType_MeasureType_MAX = Object_MeasureType_kVehicleMeasurePlate;
constexpr int Object_MeasureType_MeasureType_ARRAYSIZE = Object_MeasureType_MeasureType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_MeasureType_descriptor();
template<typename T>
inline const std::string& Object_MeasureType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_MeasureType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_MeasureType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_MeasureType_descriptor(), enum_t_value);
}
inline bool Object_MeasureType_Parse(
    const std::string& name, Object_MeasureType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_MeasureType>(
    Object_MeasureType_descriptor(), name, value);
}
enum Object_VehicleClass : int {
  Object_VehicleClass_kNegative = 0,
  Object_VehicleClass_kBus = 1,
  Object_VehicleClass_kCar = 2,
  Object_VehicleClass_kMiniBus = 3,
  Object_VehicleClass_kBucketTruck = 4,
  Object_VehicleClass_kContainerTruck = 5,
  Object_VehicleClass_kTricycle = 6,
  Object_VehicleClass_kTanker = 7,
  Object_VehicleClass_kCementTankTruck = 8,
  Object_VehicleClass_kPickup = 9,
  Object_VehicleClass_kSedimentTruck = 10,
  Object_VehicleClass_kIveco = 11,
  Object_VehicleClass_kSpecialCar = 12,
  Object_VehicleClass_kCityAuto = 13,
  Object_VehicleClass_kVehicleUnknown = 14,
  Object_VehicleClass_Object_VehicleClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_VehicleClass_Object_VehicleClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_VehicleClass_IsValid(int value);
constexpr Object_VehicleClass Object_VehicleClass_VehicleClass_MIN = Object_VehicleClass_kNegative;
constexpr Object_VehicleClass Object_VehicleClass_VehicleClass_MAX = Object_VehicleClass_kVehicleUnknown;
constexpr int Object_VehicleClass_VehicleClass_ARRAYSIZE = Object_VehicleClass_VehicleClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_VehicleClass_descriptor();
template<typename T>
inline const std::string& Object_VehicleClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_VehicleClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_VehicleClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_VehicleClass_descriptor(), enum_t_value);
}
inline bool Object_VehicleClass_Parse(
    const std::string& name, Object_VehicleClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_VehicleClass>(
    Object_VehicleClass_descriptor(), name, value);
}
enum Object_TrafficLightClass : int {
  Object_TrafficLightClass_kTLUnknown = 0,
  Object_TrafficLightClass_kTLMix2Horizontal = 1,
  Object_TrafficLightClass_kTLMix2Vertical = 2,
  Object_TrafficLightClass_kTLMix3Horizontal = 3,
  Object_TrafficLightClass_kTLMix3Vertical = 4,
  Object_TrafficLightClass_kTLSingle = 5,
  Object_TrafficLightClass_Object_TrafficLightClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_TrafficLightClass_Object_TrafficLightClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_TrafficLightClass_IsValid(int value);
constexpr Object_TrafficLightClass Object_TrafficLightClass_TrafficLightClass_MIN = Object_TrafficLightClass_kTLUnknown;
constexpr Object_TrafficLightClass Object_TrafficLightClass_TrafficLightClass_MAX = Object_TrafficLightClass_kTLSingle;
constexpr int Object_TrafficLightClass_TrafficLightClass_ARRAYSIZE = Object_TrafficLightClass_TrafficLightClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_TrafficLightClass_descriptor();
template<typename T>
inline const std::string& Object_TrafficLightClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_TrafficLightClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_TrafficLightClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_TrafficLightClass_descriptor(), enum_t_value);
}
inline bool Object_TrafficLightClass_Parse(
    const std::string& name, Object_TrafficLightClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_TrafficLightClass>(
    Object_TrafficLightClass_descriptor(), name, value);
}
enum Object_TrafficLightStatus : int {
  Object_TrafficLightStatus_kTLSUnknown = 0,
  Object_TrafficLightStatus_kTLSRed = 1,
  Object_TrafficLightStatus_kTLSGreen = 2,
  Object_TrafficLightStatus_kTLSYellow = 3,
  Object_TrafficLightStatus_Object_TrafficLightStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_TrafficLightStatus_Object_TrafficLightStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_TrafficLightStatus_IsValid(int value);
constexpr Object_TrafficLightStatus Object_TrafficLightStatus_TrafficLightStatus_MIN = Object_TrafficLightStatus_kTLSUnknown;
constexpr Object_TrafficLightStatus Object_TrafficLightStatus_TrafficLightStatus_MAX = Object_TrafficLightStatus_kTLSYellow;
constexpr int Object_TrafficLightStatus_TrafficLightStatus_ARRAYSIZE = Object_TrafficLightStatus_TrafficLightStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_TrafficLightStatus_descriptor();
template<typename T>
inline const std::string& Object_TrafficLightStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_TrafficLightStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_TrafficLightStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_TrafficLightStatus_descriptor(), enum_t_value);
}
inline bool Object_TrafficLightStatus_Parse(
    const std::string& name, Object_TrafficLightStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_TrafficLightStatus>(
    Object_TrafficLightStatus_descriptor(), name, value);
}
enum Object_VehicleLightClass : int {
  Object_VehicleLightClass_kVLUnknown = 0,
  Object_VehicleLightClass_kVLHeadLight = 1,
  Object_VehicleLightClass_kVLTailLight = 2,
  Object_VehicleLightClass_kVLBrakeLight = 4,
  Object_VehicleLightClass_kVLTurnLeftLight = 8,
  Object_VehicleLightClass_kVLTurnRightLight = 16,
  Object_VehicleLightClass_Object_VehicleLightClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_VehicleLightClass_Object_VehicleLightClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_VehicleLightClass_IsValid(int value);
constexpr Object_VehicleLightClass Object_VehicleLightClass_VehicleLightClass_MIN = Object_VehicleLightClass_kVLUnknown;
constexpr Object_VehicleLightClass Object_VehicleLightClass_VehicleLightClass_MAX = Object_VehicleLightClass_kVLTurnRightLight;
constexpr int Object_VehicleLightClass_VehicleLightClass_ARRAYSIZE = Object_VehicleLightClass_VehicleLightClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_VehicleLightClass_descriptor();
template<typename T>
inline const std::string& Object_VehicleLightClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_VehicleLightClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_VehicleLightClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_VehicleLightClass_descriptor(), enum_t_value);
}
inline bool Object_VehicleLightClass_Parse(
    const std::string& name, Object_VehicleLightClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_VehicleLightClass>(
    Object_VehicleLightClass_descriptor(), name, value);
}
enum Object_VehicleLightStatus : int {
  Object_VehicleLightStatus_kVLSUnknown = 0,
  Object_VehicleLightStatus_kVLSOn = 1,
  Object_VehicleLightStatus_kVLSOff = 2,
  Object_VehicleLightStatus_kVLSFlash = 3,
  Object_VehicleLightStatus_Object_VehicleLightStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_VehicleLightStatus_Object_VehicleLightStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_VehicleLightStatus_IsValid(int value);
constexpr Object_VehicleLightStatus Object_VehicleLightStatus_VehicleLightStatus_MIN = Object_VehicleLightStatus_kVLSUnknown;
constexpr Object_VehicleLightStatus Object_VehicleLightStatus_VehicleLightStatus_MAX = Object_VehicleLightStatus_kVLSFlash;
constexpr int Object_VehicleLightStatus_VehicleLightStatus_ARRAYSIZE = Object_VehicleLightStatus_VehicleLightStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_VehicleLightStatus_descriptor();
template<typename T>
inline const std::string& Object_VehicleLightStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_VehicleLightStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_VehicleLightStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_VehicleLightStatus_descriptor(), enum_t_value);
}
inline bool Object_VehicleLightStatus_Parse(
    const std::string& name, Object_VehicleLightStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_VehicleLightStatus>(
    Object_VehicleLightStatus_descriptor(), name, value);
}
enum Object_MoveState : int {
  Object_MoveState_kMSUnknown = 0,
  Object_MoveState_kEgoDirectionDriving = 1,
  Object_MoveState_kEgoDirectionStopped = 2,
  Object_MoveState_kEgoDirectionReversing = 3,
  Object_MoveState_kOnComming = 4,
  Object_MoveState_kCrossing = 5,
  Object_MoveState_kStationary = 6,
  Object_MoveState_Object_MoveState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_MoveState_Object_MoveState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_MoveState_IsValid(int value);
constexpr Object_MoveState Object_MoveState_MoveState_MIN = Object_MoveState_kMSUnknown;
constexpr Object_MoveState Object_MoveState_MoveState_MAX = Object_MoveState_kStationary;
constexpr int Object_MoveState_MoveState_ARRAYSIZE = Object_MoveState_MoveState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_MoveState_descriptor();
template<typename T>
inline const std::string& Object_MoveState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_MoveState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_MoveState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_MoveState_descriptor(), enum_t_value);
}
inline bool Object_MoveState_Parse(
    const std::string& name, Object_MoveState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_MoveState>(
    Object_MoveState_descriptor(), name, value);
}
enum Object_VehicleRigidAnchor : int {
  Object_VehicleRigidAnchor_kVRARear = 0,
  Object_VehicleRigidAnchor_kVRARearWheel = 1,
  Object_VehicleRigidAnchor_kVRAHeadWheel = 2,
  Object_VehicleRigidAnchor_kVRAHead = 3,
  Object_VehicleRigidAnchor_kVRAMaxNum = 4,
  Object_VehicleRigidAnchor_Object_VehicleRigidAnchor_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_VehicleRigidAnchor_Object_VehicleRigidAnchor_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_VehicleRigidAnchor_IsValid(int value);
constexpr Object_VehicleRigidAnchor Object_VehicleRigidAnchor_VehicleRigidAnchor_MIN = Object_VehicleRigidAnchor_kVRARear;
constexpr Object_VehicleRigidAnchor Object_VehicleRigidAnchor_VehicleRigidAnchor_MAX = Object_VehicleRigidAnchor_kVRAMaxNum;
constexpr int Object_VehicleRigidAnchor_VehicleRigidAnchor_ARRAYSIZE = Object_VehicleRigidAnchor_VehicleRigidAnchor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_VehicleRigidAnchor_descriptor();
template<typename T>
inline const std::string& Object_VehicleRigidAnchor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_VehicleRigidAnchor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_VehicleRigidAnchor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_VehicleRigidAnchor_descriptor(), enum_t_value);
}
inline bool Object_VehicleRigidAnchor_Parse(
    const std::string& name, Object_VehicleRigidAnchor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_VehicleRigidAnchor>(
    Object_VehicleRigidAnchor_descriptor(), name, value);
}
enum Object_TrackStatus : int {
  Object_TrackStatus_kTSUnknown = 0,
  Object_TrackStatus_kTSFirstDetectd = 1,
  Object_TrackStatus_kTSTracking = 2,
  Object_TrackStatus_kTSPredict = 3,
  Object_TrackStatus_Object_TrackStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_TrackStatus_Object_TrackStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_TrackStatus_IsValid(int value);
constexpr Object_TrackStatus Object_TrackStatus_TrackStatus_MIN = Object_TrackStatus_kTSUnknown;
constexpr Object_TrackStatus Object_TrackStatus_TrackStatus_MAX = Object_TrackStatus_kTSPredict;
constexpr int Object_TrackStatus_TrackStatus_ARRAYSIZE = Object_TrackStatus_TrackStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_TrackStatus_descriptor();
template<typename T>
inline const std::string& Object_TrackStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_TrackStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_TrackStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_TrackStatus_descriptor(), enum_t_value);
}
inline bool Object_TrackStatus_Parse(
    const std::string& name, Object_TrackStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_TrackStatus>(
    Object_TrackStatus_descriptor(), name, value);
}
enum Object_SelectLevelStatus : int {
  Object_SelectLevelStatus_kSLOriginDet = 0,
  Object_SelectLevelStatus_kSLDetAfterInnerROINMS = 1,
  Object_SelectLevelStatus_kSLDetAfterCrossROINMS = 2,
  Object_SelectLevelStatus_kSLReservered = 3,
  Object_SelectLevelStatus_kSLCandidateDet = 4,
  Object_SelectLevelStatus_Object_SelectLevelStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Object_SelectLevelStatus_Object_SelectLevelStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Object_SelectLevelStatus_IsValid(int value);
constexpr Object_SelectLevelStatus Object_SelectLevelStatus_SelectLevelStatus_MIN = Object_SelectLevelStatus_kSLOriginDet;
constexpr Object_SelectLevelStatus Object_SelectLevelStatus_SelectLevelStatus_MAX = Object_SelectLevelStatus_kSLCandidateDet;
constexpr int Object_SelectLevelStatus_SelectLevelStatus_ARRAYSIZE = Object_SelectLevelStatus_SelectLevelStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_SelectLevelStatus_descriptor();
template<typename T>
inline const std::string& Object_SelectLevelStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_SelectLevelStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_SelectLevelStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_SelectLevelStatus_descriptor(), enum_t_value);
}
inline bool Object_SelectLevelStatus_Parse(
    const std::string& name, Object_SelectLevelStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_SelectLevelStatus>(
    Object_SelectLevelStatus_descriptor(), name, value);
}
// ===================================================================

class Object_ImageInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.Object.ImageInfo) */ {
 public:
  inline Object_ImageInfo() : Object_ImageInfo(nullptr) {};
  virtual ~Object_ImageInfo();

  Object_ImageInfo(const Object_ImageInfo& from);
  Object_ImageInfo(Object_ImageInfo&& from) noexcept
    : Object_ImageInfo() {
    *this = ::std::move(from);
  }

  inline Object_ImageInfo& operator=(const Object_ImageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object_ImageInfo& operator=(Object_ImageInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Object_ImageInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object_ImageInfo* internal_default_instance() {
    return reinterpret_cast<const Object_ImageInfo*>(
               &_Object_ImageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Object_ImageInfo& a, Object_ImageInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Object_ImageInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object_ImageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Object_ImageInfo* New() const final {
    return CreateMaybeMessage<Object_ImageInfo>(nullptr);
  }

  Object_ImageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Object_ImageInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Object_ImageInfo& from);
  void MergeFrom(const Object_ImageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object_ImageInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.Object.ImageInfo";
  }
  protected:
  explicit Object_ImageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_object_2eproto);
    return ::descriptor_table_object_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWheelListFieldNumber = 6,
    kRegPtListFieldNumber = 7,
    kDetRectFieldNumber = 1,
    kRegRectFieldNumber = 2,
    kTrackRectFieldNumber = 3,
    kSmoothRectFieldNumber = 4,
    kPlateRectFieldNumber = 5,
    kBoxFieldNumber = 10,
    kCameraIdFieldNumber = 11,
  };
  // repeated .perception.common.Rect2f wheel_list = 6;
  int wheel_list_size() const;
  private:
  int _internal_wheel_list_size() const;
  public:
  void clear_wheel_list();
  ::perception::common::Rect2f* mutable_wheel_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Rect2f >*
      mutable_wheel_list();
  private:
  const ::perception::common::Rect2f& _internal_wheel_list(int index) const;
  ::perception::common::Rect2f* _internal_add_wheel_list();
  public:
  const ::perception::common::Rect2f& wheel_list(int index) const;
  ::perception::common::Rect2f* add_wheel_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Rect2f >&
      wheel_list() const;

  // repeated .perception.common.Point2f reg_pt_list = 7;
  int reg_pt_list_size() const;
  private:
  int _internal_reg_pt_list_size() const;
  public:
  void clear_reg_pt_list();
  ::perception::common::Point2f* mutable_reg_pt_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Point2f >*
      mutable_reg_pt_list();
  private:
  const ::perception::common::Point2f& _internal_reg_pt_list(int index) const;
  ::perception::common::Point2f* _internal_add_reg_pt_list();
  public:
  const ::perception::common::Point2f& reg_pt_list(int index) const;
  ::perception::common::Point2f* add_reg_pt_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Point2f >&
      reg_pt_list() const;

  // .perception.common.Rect2f det_rect = 1;
  bool has_det_rect() const;
  private:
  bool _internal_has_det_rect() const;
  public:
  void clear_det_rect();
  const ::perception::common::Rect2f& det_rect() const;
  ::perception::common::Rect2f* release_det_rect();
  ::perception::common::Rect2f* mutable_det_rect();
  void set_allocated_det_rect(::perception::common::Rect2f* det_rect);
  private:
  const ::perception::common::Rect2f& _internal_det_rect() const;
  ::perception::common::Rect2f* _internal_mutable_det_rect();
  public:
  void unsafe_arena_set_allocated_det_rect(
      ::perception::common::Rect2f* det_rect);
  ::perception::common::Rect2f* unsafe_arena_release_det_rect();

  // .perception.common.Rect2f reg_rect = 2;
  bool has_reg_rect() const;
  private:
  bool _internal_has_reg_rect() const;
  public:
  void clear_reg_rect();
  const ::perception::common::Rect2f& reg_rect() const;
  ::perception::common::Rect2f* release_reg_rect();
  ::perception::common::Rect2f* mutable_reg_rect();
  void set_allocated_reg_rect(::perception::common::Rect2f* reg_rect);
  private:
  const ::perception::common::Rect2f& _internal_reg_rect() const;
  ::perception::common::Rect2f* _internal_mutable_reg_rect();
  public:
  void unsafe_arena_set_allocated_reg_rect(
      ::perception::common::Rect2f* reg_rect);
  ::perception::common::Rect2f* unsafe_arena_release_reg_rect();

  // .perception.common.Rect2f track_rect = 3;
  bool has_track_rect() const;
  private:
  bool _internal_has_track_rect() const;
  public:
  void clear_track_rect();
  const ::perception::common::Rect2f& track_rect() const;
  ::perception::common::Rect2f* release_track_rect();
  ::perception::common::Rect2f* mutable_track_rect();
  void set_allocated_track_rect(::perception::common::Rect2f* track_rect);
  private:
  const ::perception::common::Rect2f& _internal_track_rect() const;
  ::perception::common::Rect2f* _internal_mutable_track_rect();
  public:
  void unsafe_arena_set_allocated_track_rect(
      ::perception::common::Rect2f* track_rect);
  ::perception::common::Rect2f* unsafe_arena_release_track_rect();

  // .perception.common.Rect2f smooth_rect = 4;
  bool has_smooth_rect() const;
  private:
  bool _internal_has_smooth_rect() const;
  public:
  void clear_smooth_rect();
  const ::perception::common::Rect2f& smooth_rect() const;
  ::perception::common::Rect2f* release_smooth_rect();
  ::perception::common::Rect2f* mutable_smooth_rect();
  void set_allocated_smooth_rect(::perception::common::Rect2f* smooth_rect);
  private:
  const ::perception::common::Rect2f& _internal_smooth_rect() const;
  ::perception::common::Rect2f* _internal_mutable_smooth_rect();
  public:
  void unsafe_arena_set_allocated_smooth_rect(
      ::perception::common::Rect2f* smooth_rect);
  ::perception::common::Rect2f* unsafe_arena_release_smooth_rect();

  // .perception.common.Rect2f plate_rect = 5;
  bool has_plate_rect() const;
  private:
  bool _internal_has_plate_rect() const;
  public:
  void clear_plate_rect();
  const ::perception::common::Rect2f& plate_rect() const;
  ::perception::common::Rect2f* release_plate_rect();
  ::perception::common::Rect2f* mutable_plate_rect();
  void set_allocated_plate_rect(::perception::common::Rect2f* plate_rect);
  private:
  const ::perception::common::Rect2f& _internal_plate_rect() const;
  ::perception::common::Rect2f* _internal_mutable_plate_rect();
  public:
  void unsafe_arena_set_allocated_plate_rect(
      ::perception::common::Rect2f* plate_rect);
  ::perception::common::Rect2f* unsafe_arena_release_plate_rect();

  // .perception.common.Box3D box = 10;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::perception::common::Box3D& box() const;
  ::perception::common::Box3D* release_box();
  ::perception::common::Box3D* mutable_box();
  void set_allocated_box(::perception::common::Box3D* box);
  private:
  const ::perception::common::Box3D& _internal_box() const;
  ::perception::common::Box3D* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::perception::common::Box3D* box);
  ::perception::common::Box3D* unsafe_arena_release_box();

  // .minieye.CamID camera_id = 11;
  bool has_camera_id() const;
  private:
  bool _internal_has_camera_id() const;
  public:
  void clear_camera_id();
  const ::minieye::CamID& camera_id() const;
  ::minieye::CamID* release_camera_id();
  ::minieye::CamID* mutable_camera_id();
  void set_allocated_camera_id(::minieye::CamID* camera_id);
  private:
  const ::minieye::CamID& _internal_camera_id() const;
  ::minieye::CamID* _internal_mutable_camera_id();
  public:
  void unsafe_arena_set_allocated_camera_id(
      ::minieye::CamID* camera_id);
  ::minieye::CamID* unsafe_arena_release_camera_id();

  // @@protoc_insertion_point(class_scope:perception.Object.ImageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Rect2f > wheel_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Point2f > reg_pt_list_;
  ::perception::common::Rect2f* det_rect_;
  ::perception::common::Rect2f* reg_rect_;
  ::perception::common::Rect2f* track_rect_;
  ::perception::common::Rect2f* smooth_rect_;
  ::perception::common::Rect2f* plate_rect_;
  ::perception::common::Box3D* box_;
  ::minieye::CamID* camera_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_object_2eproto;
};
// -------------------------------------------------------------------

class Object_VehicleRigid PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.Object.VehicleRigid) */ {
 public:
  inline Object_VehicleRigid() : Object_VehicleRigid(nullptr) {};
  virtual ~Object_VehicleRigid();

  Object_VehicleRigid(const Object_VehicleRigid& from);
  Object_VehicleRigid(Object_VehicleRigid&& from) noexcept
    : Object_VehicleRigid() {
    *this = ::std::move(from);
  }

  inline Object_VehicleRigid& operator=(const Object_VehicleRigid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object_VehicleRigid& operator=(Object_VehicleRigid&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Object_VehicleRigid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object_VehicleRigid* internal_default_instance() {
    return reinterpret_cast<const Object_VehicleRigid*>(
               &_Object_VehicleRigid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Object_VehicleRigid& a, Object_VehicleRigid& b) {
    a.Swap(&b);
  }
  inline void Swap(Object_VehicleRigid* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object_VehicleRigid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Object_VehicleRigid* New() const final {
    return CreateMaybeMessage<Object_VehicleRigid>(nullptr);
  }

  Object_VehicleRigid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Object_VehicleRigid>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Object_VehicleRigid& from);
  void MergeFrom(const Object_VehicleRigid& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object_VehicleRigid* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.Object.VehicleRigid";
  }
  protected:
  explicit Object_VehicleRigid(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_object_2eproto);
    return ::descriptor_table_object_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeasAlongLengthFieldNumber = 1,
    kWFieldNumber = 2,
    kHFieldNumber = 3,
  };
  // repeated .perception.common.Float meas_along_length = 1;
  int meas_along_length_size() const;
  private:
  int _internal_meas_along_length_size() const;
  public:
  void clear_meas_along_length();
  ::perception::common::Float* mutable_meas_along_length(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Float >*
      mutable_meas_along_length();
  private:
  const ::perception::common::Float& _internal_meas_along_length(int index) const;
  ::perception::common::Float* _internal_add_meas_along_length();
  public:
  const ::perception::common::Float& meas_along_length(int index) const;
  ::perception::common::Float* add_meas_along_length();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Float >&
      meas_along_length() const;

  // .perception.common.Float w = 2;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  const ::perception::common::Float& w() const;
  ::perception::common::Float* release_w();
  ::perception::common::Float* mutable_w();
  void set_allocated_w(::perception::common::Float* w);
  private:
  const ::perception::common::Float& _internal_w() const;
  ::perception::common::Float* _internal_mutable_w();
  public:
  void unsafe_arena_set_allocated_w(
      ::perception::common::Float* w);
  ::perception::common::Float* unsafe_arena_release_w();

  // .perception.common.Float h = 3;
  bool has_h() const;
  private:
  bool _internal_has_h() const;
  public:
  void clear_h();
  const ::perception::common::Float& h() const;
  ::perception::common::Float* release_h();
  ::perception::common::Float* mutable_h();
  void set_allocated_h(::perception::common::Float* h);
  private:
  const ::perception::common::Float& _internal_h() const;
  ::perception::common::Float* _internal_mutable_h();
  public:
  void unsafe_arena_set_allocated_h(
      ::perception::common::Float* h);
  ::perception::common::Float* unsafe_arena_release_h();

  // @@protoc_insertion_point(class_scope:perception.Object.VehicleRigid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Float > meas_along_length_;
  ::perception::common::Float* w_;
  ::perception::common::Float* h_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_object_2eproto;
};
// -------------------------------------------------------------------

class Object_WorldInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.Object.WorldInfo) */ {
 public:
  inline Object_WorldInfo() : Object_WorldInfo(nullptr) {};
  virtual ~Object_WorldInfo();

  Object_WorldInfo(const Object_WorldInfo& from);
  Object_WorldInfo(Object_WorldInfo&& from) noexcept
    : Object_WorldInfo() {
    *this = ::std::move(from);
  }

  inline Object_WorldInfo& operator=(const Object_WorldInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object_WorldInfo& operator=(Object_WorldInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Object_WorldInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object_WorldInfo* internal_default_instance() {
    return reinterpret_cast<const Object_WorldInfo*>(
               &_Object_WorldInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Object_WorldInfo& a, Object_WorldInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Object_WorldInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object_WorldInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Object_WorldInfo* New() const final {
    return CreateMaybeMessage<Object_WorldInfo>(nullptr);
  }

  Object_WorldInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Object_WorldInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Object_WorldInfo& from);
  void MergeFrom(const Object_WorldInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object_WorldInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.Object.WorldInfo";
  }
  protected:
  explicit Object_WorldInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_object_2eproto);
    return ::descriptor_table_object_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOdomTraceFieldNumber = 26,
    kVelFieldNumber = 1,
    kRelVelFieldNumber = 2,
    kAccFieldNumber = 3,
    kPosFieldNumber = 4,
    kSizeFieldNumber = 5,
    kAngleFieldNumber = 6,
    kBoxFieldNumber = 10,
    kClsFieldNumber = 12,
    kPoseFieldNumber = 14,
    kPoseAngleFieldNumber = 19,
    kMotionStateFieldNumber = 20,
    kPosVarFieldNumber = 22,
    kSizeVarFieldNumber = 23,
    kPoseAngleVarFieldNumber = 24,
    kAnchorOffsetFieldNumber = 25,
    kIdFieldNumber = 11,
    kValFieldNumber = 13,
    kTtcFieldNumber = 15,
    kHeadwayFieldNumber = 16,
    kCipvFieldNumber = 17,
    kCippFieldNumber = 18,
    kAnchorFieldNumber = 21,
  };
  // repeated .perception.common.XY odom_trace = 26;
  int odom_trace_size() const;
  private:
  int _internal_odom_trace_size() const;
  public:
  void clear_odom_trace();
  ::perception::common::XY* mutable_odom_trace(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::XY >*
      mutable_odom_trace();
  private:
  const ::perception::common::XY& _internal_odom_trace(int index) const;
  ::perception::common::XY* _internal_add_odom_trace();
  public:
  const ::perception::common::XY& odom_trace(int index) const;
  ::perception::common::XY* add_odom_trace();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::XY >&
      odom_trace() const;

  // .perception.common.XYZ vel = 1;
  bool has_vel() const;
  private:
  bool _internal_has_vel() const;
  public:
  void clear_vel();
  const ::perception::common::XYZ& vel() const;
  ::perception::common::XYZ* release_vel();
  ::perception::common::XYZ* mutable_vel();
  void set_allocated_vel(::perception::common::XYZ* vel);
  private:
  const ::perception::common::XYZ& _internal_vel() const;
  ::perception::common::XYZ* _internal_mutable_vel();
  public:
  void unsafe_arena_set_allocated_vel(
      ::perception::common::XYZ* vel);
  ::perception::common::XYZ* unsafe_arena_release_vel();

  // .perception.common.XYZ rel_vel = 2;
  bool has_rel_vel() const;
  private:
  bool _internal_has_rel_vel() const;
  public:
  void clear_rel_vel();
  const ::perception::common::XYZ& rel_vel() const;
  ::perception::common::XYZ* release_rel_vel();
  ::perception::common::XYZ* mutable_rel_vel();
  void set_allocated_rel_vel(::perception::common::XYZ* rel_vel);
  private:
  const ::perception::common::XYZ& _internal_rel_vel() const;
  ::perception::common::XYZ* _internal_mutable_rel_vel();
  public:
  void unsafe_arena_set_allocated_rel_vel(
      ::perception::common::XYZ* rel_vel);
  ::perception::common::XYZ* unsafe_arena_release_rel_vel();

  // .perception.common.XYZ acc = 3;
  bool has_acc() const;
  private:
  bool _internal_has_acc() const;
  public:
  void clear_acc();
  const ::perception::common::XYZ& acc() const;
  ::perception::common::XYZ* release_acc();
  ::perception::common::XYZ* mutable_acc();
  void set_allocated_acc(::perception::common::XYZ* acc);
  private:
  const ::perception::common::XYZ& _internal_acc() const;
  ::perception::common::XYZ* _internal_mutable_acc();
  public:
  void unsafe_arena_set_allocated_acc(
      ::perception::common::XYZ* acc);
  ::perception::common::XYZ* unsafe_arena_release_acc();

  // .perception.common.XYZ pos = 4;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::perception::common::XYZ& pos() const;
  ::perception::common::XYZ* release_pos();
  ::perception::common::XYZ* mutable_pos();
  void set_allocated_pos(::perception::common::XYZ* pos);
  private:
  const ::perception::common::XYZ& _internal_pos() const;
  ::perception::common::XYZ* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::perception::common::XYZ* pos);
  ::perception::common::XYZ* unsafe_arena_release_pos();

  // .perception.common.Size3D size = 5;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::perception::common::Size3D& size() const;
  ::perception::common::Size3D* release_size();
  ::perception::common::Size3D* mutable_size();
  void set_allocated_size(::perception::common::Size3D* size);
  private:
  const ::perception::common::Size3D& _internal_size() const;
  ::perception::common::Size3D* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::perception::common::Size3D* size);
  ::perception::common::Size3D* unsafe_arena_release_size();

  // .perception.common.Angle3f angle = 6;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  const ::perception::common::Angle3f& angle() const;
  ::perception::common::Angle3f* release_angle();
  ::perception::common::Angle3f* mutable_angle();
  void set_allocated_angle(::perception::common::Angle3f* angle);
  private:
  const ::perception::common::Angle3f& _internal_angle() const;
  ::perception::common::Angle3f* _internal_mutable_angle();
  public:
  void unsafe_arena_set_allocated_angle(
      ::perception::common::Angle3f* angle);
  ::perception::common::Angle3f* unsafe_arena_release_angle();

  // .perception.common.Box3D box = 10;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::perception::common::Box3D& box() const;
  ::perception::common::Box3D* release_box();
  ::perception::common::Box3D* mutable_box();
  void set_allocated_box(::perception::common::Box3D* box);
  private:
  const ::perception::common::Box3D& _internal_box() const;
  ::perception::common::Box3D* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::perception::common::Box3D* box);
  ::perception::common::Box3D* unsafe_arena_release_box();

  // .perception.common.Int cls = 12;
  bool has_cls() const;
  private:
  bool _internal_has_cls() const;
  public:
  void clear_cls();
  const ::perception::common::Int& cls() const;
  ::perception::common::Int* release_cls();
  ::perception::common::Int* mutable_cls();
  void set_allocated_cls(::perception::common::Int* cls);
  private:
  const ::perception::common::Int& _internal_cls() const;
  ::perception::common::Int* _internal_mutable_cls();
  public:
  void unsafe_arena_set_allocated_cls(
      ::perception::common::Int* cls);
  ::perception::common::Int* unsafe_arena_release_cls();

  // .perception.common.Int pose = 14;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::perception::common::Int& pose() const;
  ::perception::common::Int* release_pose();
  ::perception::common::Int* mutable_pose();
  void set_allocated_pose(::perception::common::Int* pose);
  private:
  const ::perception::common::Int& _internal_pose() const;
  ::perception::common::Int* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::perception::common::Int* pose);
  ::perception::common::Int* unsafe_arena_release_pose();

  // .perception.common.PoseAngle pose_angle = 19;
  bool has_pose_angle() const;
  private:
  bool _internal_has_pose_angle() const;
  public:
  void clear_pose_angle();
  const ::perception::common::PoseAngle& pose_angle() const;
  ::perception::common::PoseAngle* release_pose_angle();
  ::perception::common::PoseAngle* mutable_pose_angle();
  void set_allocated_pose_angle(::perception::common::PoseAngle* pose_angle);
  private:
  const ::perception::common::PoseAngle& _internal_pose_angle() const;
  ::perception::common::PoseAngle* _internal_mutable_pose_angle();
  public:
  void unsafe_arena_set_allocated_pose_angle(
      ::perception::common::PoseAngle* pose_angle);
  ::perception::common::PoseAngle* unsafe_arena_release_pose_angle();

  // .perception.common.Int motion_state = 20;
  bool has_motion_state() const;
  private:
  bool _internal_has_motion_state() const;
  public:
  void clear_motion_state();
  const ::perception::common::Int& motion_state() const;
  ::perception::common::Int* release_motion_state();
  ::perception::common::Int* mutable_motion_state();
  void set_allocated_motion_state(::perception::common::Int* motion_state);
  private:
  const ::perception::common::Int& _internal_motion_state() const;
  ::perception::common::Int* _internal_mutable_motion_state();
  public:
  void unsafe_arena_set_allocated_motion_state(
      ::perception::common::Int* motion_state);
  ::perception::common::Int* unsafe_arena_release_motion_state();

  // .perception.common.Point3D pos_var = 22;
  bool has_pos_var() const;
  private:
  bool _internal_has_pos_var() const;
  public:
  void clear_pos_var();
  const ::perception::common::Point3D& pos_var() const;
  ::perception::common::Point3D* release_pos_var();
  ::perception::common::Point3D* mutable_pos_var();
  void set_allocated_pos_var(::perception::common::Point3D* pos_var);
  private:
  const ::perception::common::Point3D& _internal_pos_var() const;
  ::perception::common::Point3D* _internal_mutable_pos_var();
  public:
  void unsafe_arena_set_allocated_pos_var(
      ::perception::common::Point3D* pos_var);
  ::perception::common::Point3D* unsafe_arena_release_pos_var();

  // .perception.common.Point3D size_var = 23;
  bool has_size_var() const;
  private:
  bool _internal_has_size_var() const;
  public:
  void clear_size_var();
  const ::perception::common::Point3D& size_var() const;
  ::perception::common::Point3D* release_size_var();
  ::perception::common::Point3D* mutable_size_var();
  void set_allocated_size_var(::perception::common::Point3D* size_var);
  private:
  const ::perception::common::Point3D& _internal_size_var() const;
  ::perception::common::Point3D* _internal_mutable_size_var();
  public:
  void unsafe_arena_set_allocated_size_var(
      ::perception::common::Point3D* size_var);
  ::perception::common::Point3D* unsafe_arena_release_size_var();

  // .perception.common.Point3D pose_angle_var = 24;
  bool has_pose_angle_var() const;
  private:
  bool _internal_has_pose_angle_var() const;
  public:
  void clear_pose_angle_var();
  const ::perception::common::Point3D& pose_angle_var() const;
  ::perception::common::Point3D* release_pose_angle_var();
  ::perception::common::Point3D* mutable_pose_angle_var();
  void set_allocated_pose_angle_var(::perception::common::Point3D* pose_angle_var);
  private:
  const ::perception::common::Point3D& _internal_pose_angle_var() const;
  ::perception::common::Point3D* _internal_mutable_pose_angle_var();
  public:
  void unsafe_arena_set_allocated_pose_angle_var(
      ::perception::common::Point3D* pose_angle_var);
  ::perception::common::Point3D* unsafe_arena_release_pose_angle_var();

  // .perception.common.XYZ anchor_offset = 25;
  bool has_anchor_offset() const;
  private:
  bool _internal_has_anchor_offset() const;
  public:
  void clear_anchor_offset();
  const ::perception::common::XYZ& anchor_offset() const;
  ::perception::common::XYZ* release_anchor_offset();
  ::perception::common::XYZ* mutable_anchor_offset();
  void set_allocated_anchor_offset(::perception::common::XYZ* anchor_offset);
  private:
  const ::perception::common::XYZ& _internal_anchor_offset() const;
  ::perception::common::XYZ* _internal_mutable_anchor_offset();
  public:
  void unsafe_arena_set_allocated_anchor_offset(
      ::perception::common::XYZ* anchor_offset);
  ::perception::common::XYZ* unsafe_arena_release_anchor_offset();

  // uint32 id = 11;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float val = 13;
  void clear_val();
  float val() const;
  void set_val(float value);
  private:
  float _internal_val() const;
  void _internal_set_val(float value);
  public:

  // float ttc = 15;
  void clear_ttc();
  float ttc() const;
  void set_ttc(float value);
  private:
  float _internal_ttc() const;
  void _internal_set_ttc(float value);
  public:

  // float headway = 16;
  void clear_headway();
  float headway() const;
  void set_headway(float value);
  private:
  float _internal_headway() const;
  void _internal_set_headway(float value);
  public:

  // int32 cipv = 17;
  void clear_cipv();
  ::PROTOBUF_NAMESPACE_ID::int32 cipv() const;
  void set_cipv(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cipv() const;
  void _internal_set_cipv(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 cipp = 18;
  void clear_cipp();
  ::PROTOBUF_NAMESPACE_ID::int32 cipp() const;
  void set_cipp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cipp() const;
  void _internal_set_cipp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .perception.Object.AnchorPtInfo anchor = 21;
  void clear_anchor();
  ::perception::Object_AnchorPtInfo anchor() const;
  void set_anchor(::perception::Object_AnchorPtInfo value);
  private:
  ::perception::Object_AnchorPtInfo _internal_anchor() const;
  void _internal_set_anchor(::perception::Object_AnchorPtInfo value);
  public:

  // @@protoc_insertion_point(class_scope:perception.Object.WorldInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::XY > odom_trace_;
  ::perception::common::XYZ* vel_;
  ::perception::common::XYZ* rel_vel_;
  ::perception::common::XYZ* acc_;
  ::perception::common::XYZ* pos_;
  ::perception::common::Size3D* size_;
  ::perception::common::Angle3f* angle_;
  ::perception::common::Box3D* box_;
  ::perception::common::Int* cls_;
  ::perception::common::Int* pose_;
  ::perception::common::PoseAngle* pose_angle_;
  ::perception::common::Int* motion_state_;
  ::perception::common::Point3D* pos_var_;
  ::perception::common::Point3D* size_var_;
  ::perception::common::Point3D* pose_angle_var_;
  ::perception::common::XYZ* anchor_offset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  float val_;
  float ttc_;
  float headway_;
  ::PROTOBUF_NAMESPACE_ID::int32 cipv_;
  ::PROTOBUF_NAMESPACE_ID::int32 cipp_;
  int anchor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_object_2eproto;
};
// -------------------------------------------------------------------

class Object_FusionInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.Object.FusionInfo) */ {
 public:
  inline Object_FusionInfo() : Object_FusionInfo(nullptr) {};
  virtual ~Object_FusionInfo();

  Object_FusionInfo(const Object_FusionInfo& from);
  Object_FusionInfo(Object_FusionInfo&& from) noexcept
    : Object_FusionInfo() {
    *this = ::std::move(from);
  }

  inline Object_FusionInfo& operator=(const Object_FusionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object_FusionInfo& operator=(Object_FusionInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Object_FusionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object_FusionInfo* internal_default_instance() {
    return reinterpret_cast<const Object_FusionInfo*>(
               &_Object_FusionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Object_FusionInfo& a, Object_FusionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Object_FusionInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object_FusionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Object_FusionInfo* New() const final {
    return CreateMaybeMessage<Object_FusionInfo>(nullptr);
  }

  Object_FusionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Object_FusionInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Object_FusionInfo& from);
  void MergeFrom(const Object_FusionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object_FusionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.Object.FusionInfo";
  }
  protected:
  explicit Object_FusionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_object_2eproto);
    return ::descriptor_table_object_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssociatedImageInfosFieldNumber = 1,
    kAssociatedWorldInfosFieldNumber = 2,
    kAssociatedConfMatrixFieldNumber = 3,
    kFusionWorldInfoFieldNumber = 4,
  };
  // repeated .perception.Object.ImageInfo associated_image_infos = 1;
  int associated_image_infos_size() const;
  private:
  int _internal_associated_image_infos_size() const;
  public:
  void clear_associated_image_infos();
  ::perception::Object_ImageInfo* mutable_associated_image_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object_ImageInfo >*
      mutable_associated_image_infos();
  private:
  const ::perception::Object_ImageInfo& _internal_associated_image_infos(int index) const;
  ::perception::Object_ImageInfo* _internal_add_associated_image_infos();
  public:
  const ::perception::Object_ImageInfo& associated_image_infos(int index) const;
  ::perception::Object_ImageInfo* add_associated_image_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object_ImageInfo >&
      associated_image_infos() const;

  // repeated .perception.Object.WorldInfo associated_world_infos = 2;
  int associated_world_infos_size() const;
  private:
  int _internal_associated_world_infos_size() const;
  public:
  void clear_associated_world_infos();
  ::perception::Object_WorldInfo* mutable_associated_world_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object_WorldInfo >*
      mutable_associated_world_infos();
  private:
  const ::perception::Object_WorldInfo& _internal_associated_world_infos(int index) const;
  ::perception::Object_WorldInfo* _internal_add_associated_world_infos();
  public:
  const ::perception::Object_WorldInfo& associated_world_infos(int index) const;
  ::perception::Object_WorldInfo* add_associated_world_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object_WorldInfo >&
      associated_world_infos() const;

  // repeated float associated_conf_matrix = 3;
  int associated_conf_matrix_size() const;
  private:
  int _internal_associated_conf_matrix_size() const;
  public:
  void clear_associated_conf_matrix();
  private:
  float _internal_associated_conf_matrix(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_associated_conf_matrix() const;
  void _internal_add_associated_conf_matrix(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_associated_conf_matrix();
  public:
  float associated_conf_matrix(int index) const;
  void set_associated_conf_matrix(int index, float value);
  void add_associated_conf_matrix(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      associated_conf_matrix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_associated_conf_matrix();

  // .perception.Object.WorldInfo fusion_world_info = 4;
  bool has_fusion_world_info() const;
  private:
  bool _internal_has_fusion_world_info() const;
  public:
  void clear_fusion_world_info();
  const ::perception::Object_WorldInfo& fusion_world_info() const;
  ::perception::Object_WorldInfo* release_fusion_world_info();
  ::perception::Object_WorldInfo* mutable_fusion_world_info();
  void set_allocated_fusion_world_info(::perception::Object_WorldInfo* fusion_world_info);
  private:
  const ::perception::Object_WorldInfo& _internal_fusion_world_info() const;
  ::perception::Object_WorldInfo* _internal_mutable_fusion_world_info();
  public:
  void unsafe_arena_set_allocated_fusion_world_info(
      ::perception::Object_WorldInfo* fusion_world_info);
  ::perception::Object_WorldInfo* unsafe_arena_release_fusion_world_info();

  // @@protoc_insertion_point(class_scope:perception.Object.FusionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object_ImageInfo > associated_image_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object_WorldInfo > associated_world_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > associated_conf_matrix_;
  mutable std::atomic<int> _associated_conf_matrix_cached_byte_size_;
  ::perception::Object_WorldInfo* fusion_world_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_object_2eproto;
};
// -------------------------------------------------------------------

class Object PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.Object) */ {
 public:
  inline Object() : Object(nullptr) {};
  virtual ~Object();

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Object& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Object* New() const final {
    return CreateMaybeMessage<Object>(nullptr);
  }

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.Object";
  }
  protected:
  explicit Object(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_object_2eproto);
    return ::descriptor_table_object_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Object_ImageInfo ImageInfo;
  typedef Object_VehicleRigid VehicleRigid;
  typedef Object_WorldInfo WorldInfo;
  typedef Object_FusionInfo FusionInfo;

  typedef Object_ObjectType ObjectType;
  static constexpr ObjectType kNone =
    Object_ObjectType_kNone;
  static constexpr ObjectType kVehicle =
    Object_ObjectType_kVehicle;
  static constexpr ObjectType kPed =
    Object_ObjectType_kPed;
  static constexpr ObjectType kBike =
    Object_ObjectType_kBike;
  static constexpr ObjectType kCone =
    Object_ObjectType_kCone;
  static constexpr ObjectType kVehicleWheel =
    Object_ObjectType_kVehicleWheel;
  static constexpr ObjectType kVehiclePlate =
    Object_ObjectType_kVehiclePlate;
  static constexpr ObjectType kPedHead =
    Object_ObjectType_kPedHead;
  static constexpr ObjectType kSmallTrafficSign =
    Object_ObjectType_kSmallTrafficSign;
  static constexpr ObjectType kBigTrafficSign =
    Object_ObjectType_kBigTrafficSign;
  static constexpr ObjectType kTrafficLight =
    Object_ObjectType_kTrafficLight;
  static constexpr ObjectType kAnimals =
    Object_ObjectType_kAnimals;
  static constexpr ObjectType kVehicleLight =
    Object_ObjectType_kVehicleLight;
  static constexpr ObjectType kStreetLamp =
    Object_ObjectType_kStreetLamp;
  static constexpr ObjectType kObjectTypeNum =
    Object_ObjectType_kObjectTypeNum;
  static inline bool ObjectType_IsValid(int value) {
    return Object_ObjectType_IsValid(value);
  }
  static constexpr ObjectType ObjectType_MIN =
    Object_ObjectType_ObjectType_MIN;
  static constexpr ObjectType ObjectType_MAX =
    Object_ObjectType_ObjectType_MAX;
  static constexpr int ObjectType_ARRAYSIZE =
    Object_ObjectType_ObjectType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ObjectType_descriptor() {
    return Object_ObjectType_descriptor();
  }
  template<typename T>
  static inline const std::string& ObjectType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ObjectType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ObjectType_Name.");
    return Object_ObjectType_Name(enum_t_value);
  }
  static inline bool ObjectType_Parse(const std::string& name,
      ObjectType* value) {
    return Object_ObjectType_Parse(name, value);
  }

  typedef Object_VehiclePose VehiclePose;
  static constexpr VehiclePose kInvalid =
    Object_VehiclePose_kInvalid;
  static constexpr VehiclePose kLeftTail =
    Object_VehiclePose_kLeftTail;
  static constexpr VehiclePose kMidTail =
    Object_VehiclePose_kMidTail;
  static constexpr VehiclePose kRightTail =
    Object_VehiclePose_kRightTail;
  static constexpr VehiclePose kLeftHead =
    Object_VehiclePose_kLeftHead;
  static constexpr VehiclePose kMidHead =
    Object_VehiclePose_kMidHead;
  static constexpr VehiclePose kRightHead =
    Object_VehiclePose_kRightHead;
  static constexpr VehiclePose kLeftSide =
    Object_VehiclePose_kLeftSide;
  static constexpr VehiclePose kRightSide =
    Object_VehiclePose_kRightSide;
  static constexpr VehiclePose kLeftCutIn =
    Object_VehiclePose_kLeftCutIn;
  static constexpr VehiclePose kRightCutIn =
    Object_VehiclePose_kRightCutIn;
  static constexpr VehiclePose kLeftCutOut =
    Object_VehiclePose_kLeftCutOut;
  static constexpr VehiclePose kRightCutOut =
    Object_VehiclePose_kRightCutOut;
  static constexpr VehiclePose kOccluded =
    Object_VehiclePose_kOccluded;
  static constexpr VehiclePose kUnknownPose =
    Object_VehiclePose_kUnknownPose;
  static inline bool VehiclePose_IsValid(int value) {
    return Object_VehiclePose_IsValid(value);
  }
  static constexpr VehiclePose VehiclePose_MIN =
    Object_VehiclePose_VehiclePose_MIN;
  static constexpr VehiclePose VehiclePose_MAX =
    Object_VehiclePose_VehiclePose_MAX;
  static constexpr int VehiclePose_ARRAYSIZE =
    Object_VehiclePose_VehiclePose_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VehiclePose_descriptor() {
    return Object_VehiclePose_descriptor();
  }
  template<typename T>
  static inline const std::string& VehiclePose_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VehiclePose>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VehiclePose_Name.");
    return Object_VehiclePose_Name(enum_t_value);
  }
  static inline bool VehiclePose_Parse(const std::string& name,
      VehiclePose* value) {
    return Object_VehiclePose_Parse(name, value);
  }

  typedef Object_AnchorPtInfo AnchorPtInfo;
  static constexpr AnchorPtInfo kVehicleHead =
    Object_AnchorPtInfo_kVehicleHead;
  static constexpr AnchorPtInfo kVehicleTail =
    Object_AnchorPtInfo_kVehicleTail;
  static constexpr AnchorPtInfo kVehicleFrontWheel =
    Object_AnchorPtInfo_kVehicleFrontWheel;
  static constexpr AnchorPtInfo kVehicleRearWheel =
    Object_AnchorPtInfo_kVehicleRearWheel;
  static constexpr AnchorPtInfo kVehicleSomeWheel =
    Object_AnchorPtInfo_kVehicleSomeWheel;
  static constexpr AnchorPtInfo kDetectBottomCenter =
    Object_AnchorPtInfo_kDetectBottomCenter;
  static constexpr AnchorPtInfo kVehicleLeftFrontWheel =
    Object_AnchorPtInfo_kVehicleLeftFrontWheel;
  static constexpr AnchorPtInfo kVehicleLeftRearWheel =
    Object_AnchorPtInfo_kVehicleLeftRearWheel;
  static constexpr AnchorPtInfo kVehicleRightFrontWheel =
    Object_AnchorPtInfo_kVehicleRightFrontWheel;
  static constexpr AnchorPtInfo kVehicleRightRearWheel =
    Object_AnchorPtInfo_kVehicleRightRearWheel;
  static inline bool AnchorPtInfo_IsValid(int value) {
    return Object_AnchorPtInfo_IsValid(value);
  }
  static constexpr AnchorPtInfo AnchorPtInfo_MIN =
    Object_AnchorPtInfo_AnchorPtInfo_MIN;
  static constexpr AnchorPtInfo AnchorPtInfo_MAX =
    Object_AnchorPtInfo_AnchorPtInfo_MAX;
  static constexpr int AnchorPtInfo_ARRAYSIZE =
    Object_AnchorPtInfo_AnchorPtInfo_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AnchorPtInfo_descriptor() {
    return Object_AnchorPtInfo_descriptor();
  }
  template<typename T>
  static inline const std::string& AnchorPtInfo_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AnchorPtInfo>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AnchorPtInfo_Name.");
    return Object_AnchorPtInfo_Name(enum_t_value);
  }
  static inline bool AnchorPtInfo_Parse(const std::string& name,
      AnchorPtInfo* value) {
    return Object_AnchorPtInfo_Parse(name, value);
  }

  typedef Object_MeasureType MeasureType;
  static constexpr MeasureType kVehicleMeasureHeadReg =
    Object_MeasureType_kVehicleMeasureHeadReg;
  static constexpr MeasureType kVehicleMeasureTailReg =
    Object_MeasureType_kVehicleMeasureTailReg;
  static constexpr MeasureType kVehicleMeasureDetect =
    Object_MeasureType_kVehicleMeasureDetect;
  static constexpr MeasureType kVehicleMeasureWheel =
    Object_MeasureType_kVehicleMeasureWheel;
  static constexpr MeasureType kVehicleMeasurePlate =
    Object_MeasureType_kVehicleMeasurePlate;
  static inline bool MeasureType_IsValid(int value) {
    return Object_MeasureType_IsValid(value);
  }
  static constexpr MeasureType MeasureType_MIN =
    Object_MeasureType_MeasureType_MIN;
  static constexpr MeasureType MeasureType_MAX =
    Object_MeasureType_MeasureType_MAX;
  static constexpr int MeasureType_ARRAYSIZE =
    Object_MeasureType_MeasureType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MeasureType_descriptor() {
    return Object_MeasureType_descriptor();
  }
  template<typename T>
  static inline const std::string& MeasureType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MeasureType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MeasureType_Name.");
    return Object_MeasureType_Name(enum_t_value);
  }
  static inline bool MeasureType_Parse(const std::string& name,
      MeasureType* value) {
    return Object_MeasureType_Parse(name, value);
  }

  typedef Object_VehicleClass VehicleClass;
  static constexpr VehicleClass kNegative =
    Object_VehicleClass_kNegative;
  static constexpr VehicleClass kBus =
    Object_VehicleClass_kBus;
  static constexpr VehicleClass kCar =
    Object_VehicleClass_kCar;
  static constexpr VehicleClass kMiniBus =
    Object_VehicleClass_kMiniBus;
  static constexpr VehicleClass kBucketTruck =
    Object_VehicleClass_kBucketTruck;
  static constexpr VehicleClass kContainerTruck =
    Object_VehicleClass_kContainerTruck;
  static constexpr VehicleClass kTricycle =
    Object_VehicleClass_kTricycle;
  static constexpr VehicleClass kTanker =
    Object_VehicleClass_kTanker;
  static constexpr VehicleClass kCementTankTruck =
    Object_VehicleClass_kCementTankTruck;
  static constexpr VehicleClass kPickup =
    Object_VehicleClass_kPickup;
  static constexpr VehicleClass kSedimentTruck =
    Object_VehicleClass_kSedimentTruck;
  static constexpr VehicleClass kIveco =
    Object_VehicleClass_kIveco;
  static constexpr VehicleClass kSpecialCar =
    Object_VehicleClass_kSpecialCar;
  static constexpr VehicleClass kCityAuto =
    Object_VehicleClass_kCityAuto;
  static constexpr VehicleClass kVehicleUnknown =
    Object_VehicleClass_kVehicleUnknown;
  static inline bool VehicleClass_IsValid(int value) {
    return Object_VehicleClass_IsValid(value);
  }
  static constexpr VehicleClass VehicleClass_MIN =
    Object_VehicleClass_VehicleClass_MIN;
  static constexpr VehicleClass VehicleClass_MAX =
    Object_VehicleClass_VehicleClass_MAX;
  static constexpr int VehicleClass_ARRAYSIZE =
    Object_VehicleClass_VehicleClass_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VehicleClass_descriptor() {
    return Object_VehicleClass_descriptor();
  }
  template<typename T>
  static inline const std::string& VehicleClass_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VehicleClass>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VehicleClass_Name.");
    return Object_VehicleClass_Name(enum_t_value);
  }
  static inline bool VehicleClass_Parse(const std::string& name,
      VehicleClass* value) {
    return Object_VehicleClass_Parse(name, value);
  }

  typedef Object_TrafficLightClass TrafficLightClass;
  static constexpr TrafficLightClass kTLUnknown =
    Object_TrafficLightClass_kTLUnknown;
  static constexpr TrafficLightClass kTLMix2Horizontal =
    Object_TrafficLightClass_kTLMix2Horizontal;
  static constexpr TrafficLightClass kTLMix2Vertical =
    Object_TrafficLightClass_kTLMix2Vertical;
  static constexpr TrafficLightClass kTLMix3Horizontal =
    Object_TrafficLightClass_kTLMix3Horizontal;
  static constexpr TrafficLightClass kTLMix3Vertical =
    Object_TrafficLightClass_kTLMix3Vertical;
  static constexpr TrafficLightClass kTLSingle =
    Object_TrafficLightClass_kTLSingle;
  static inline bool TrafficLightClass_IsValid(int value) {
    return Object_TrafficLightClass_IsValid(value);
  }
  static constexpr TrafficLightClass TrafficLightClass_MIN =
    Object_TrafficLightClass_TrafficLightClass_MIN;
  static constexpr TrafficLightClass TrafficLightClass_MAX =
    Object_TrafficLightClass_TrafficLightClass_MAX;
  static constexpr int TrafficLightClass_ARRAYSIZE =
    Object_TrafficLightClass_TrafficLightClass_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TrafficLightClass_descriptor() {
    return Object_TrafficLightClass_descriptor();
  }
  template<typename T>
  static inline const std::string& TrafficLightClass_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TrafficLightClass>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TrafficLightClass_Name.");
    return Object_TrafficLightClass_Name(enum_t_value);
  }
  static inline bool TrafficLightClass_Parse(const std::string& name,
      TrafficLightClass* value) {
    return Object_TrafficLightClass_Parse(name, value);
  }

  typedef Object_TrafficLightStatus TrafficLightStatus;
  static constexpr TrafficLightStatus kTLSUnknown =
    Object_TrafficLightStatus_kTLSUnknown;
  static constexpr TrafficLightStatus kTLSRed =
    Object_TrafficLightStatus_kTLSRed;
  static constexpr TrafficLightStatus kTLSGreen =
    Object_TrafficLightStatus_kTLSGreen;
  static constexpr TrafficLightStatus kTLSYellow =
    Object_TrafficLightStatus_kTLSYellow;
  static inline bool TrafficLightStatus_IsValid(int value) {
    return Object_TrafficLightStatus_IsValid(value);
  }
  static constexpr TrafficLightStatus TrafficLightStatus_MIN =
    Object_TrafficLightStatus_TrafficLightStatus_MIN;
  static constexpr TrafficLightStatus TrafficLightStatus_MAX =
    Object_TrafficLightStatus_TrafficLightStatus_MAX;
  static constexpr int TrafficLightStatus_ARRAYSIZE =
    Object_TrafficLightStatus_TrafficLightStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TrafficLightStatus_descriptor() {
    return Object_TrafficLightStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& TrafficLightStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TrafficLightStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TrafficLightStatus_Name.");
    return Object_TrafficLightStatus_Name(enum_t_value);
  }
  static inline bool TrafficLightStatus_Parse(const std::string& name,
      TrafficLightStatus* value) {
    return Object_TrafficLightStatus_Parse(name, value);
  }

  typedef Object_VehicleLightClass VehicleLightClass;
  static constexpr VehicleLightClass kVLUnknown =
    Object_VehicleLightClass_kVLUnknown;
  static constexpr VehicleLightClass kVLHeadLight =
    Object_VehicleLightClass_kVLHeadLight;
  static constexpr VehicleLightClass kVLTailLight =
    Object_VehicleLightClass_kVLTailLight;
  static constexpr VehicleLightClass kVLBrakeLight =
    Object_VehicleLightClass_kVLBrakeLight;
  static constexpr VehicleLightClass kVLTurnLeftLight =
    Object_VehicleLightClass_kVLTurnLeftLight;
  static constexpr VehicleLightClass kVLTurnRightLight =
    Object_VehicleLightClass_kVLTurnRightLight;
  static inline bool VehicleLightClass_IsValid(int value) {
    return Object_VehicleLightClass_IsValid(value);
  }
  static constexpr VehicleLightClass VehicleLightClass_MIN =
    Object_VehicleLightClass_VehicleLightClass_MIN;
  static constexpr VehicleLightClass VehicleLightClass_MAX =
    Object_VehicleLightClass_VehicleLightClass_MAX;
  static constexpr int VehicleLightClass_ARRAYSIZE =
    Object_VehicleLightClass_VehicleLightClass_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VehicleLightClass_descriptor() {
    return Object_VehicleLightClass_descriptor();
  }
  template<typename T>
  static inline const std::string& VehicleLightClass_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VehicleLightClass>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VehicleLightClass_Name.");
    return Object_VehicleLightClass_Name(enum_t_value);
  }
  static inline bool VehicleLightClass_Parse(const std::string& name,
      VehicleLightClass* value) {
    return Object_VehicleLightClass_Parse(name, value);
  }

  typedef Object_VehicleLightStatus VehicleLightStatus;
  static constexpr VehicleLightStatus kVLSUnknown =
    Object_VehicleLightStatus_kVLSUnknown;
  static constexpr VehicleLightStatus kVLSOn =
    Object_VehicleLightStatus_kVLSOn;
  static constexpr VehicleLightStatus kVLSOff =
    Object_VehicleLightStatus_kVLSOff;
  static constexpr VehicleLightStatus kVLSFlash =
    Object_VehicleLightStatus_kVLSFlash;
  static inline bool VehicleLightStatus_IsValid(int value) {
    return Object_VehicleLightStatus_IsValid(value);
  }
  static constexpr VehicleLightStatus VehicleLightStatus_MIN =
    Object_VehicleLightStatus_VehicleLightStatus_MIN;
  static constexpr VehicleLightStatus VehicleLightStatus_MAX =
    Object_VehicleLightStatus_VehicleLightStatus_MAX;
  static constexpr int VehicleLightStatus_ARRAYSIZE =
    Object_VehicleLightStatus_VehicleLightStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VehicleLightStatus_descriptor() {
    return Object_VehicleLightStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& VehicleLightStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VehicleLightStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VehicleLightStatus_Name.");
    return Object_VehicleLightStatus_Name(enum_t_value);
  }
  static inline bool VehicleLightStatus_Parse(const std::string& name,
      VehicleLightStatus* value) {
    return Object_VehicleLightStatus_Parse(name, value);
  }

  typedef Object_MoveState MoveState;
  static constexpr MoveState kMSUnknown =
    Object_MoveState_kMSUnknown;
  static constexpr MoveState kEgoDirectionDriving =
    Object_MoveState_kEgoDirectionDriving;
  static constexpr MoveState kEgoDirectionStopped =
    Object_MoveState_kEgoDirectionStopped;
  static constexpr MoveState kEgoDirectionReversing =
    Object_MoveState_kEgoDirectionReversing;
  static constexpr MoveState kOnComming =
    Object_MoveState_kOnComming;
  static constexpr MoveState kCrossing =
    Object_MoveState_kCrossing;
  static constexpr MoveState kStationary =
    Object_MoveState_kStationary;
  static inline bool MoveState_IsValid(int value) {
    return Object_MoveState_IsValid(value);
  }
  static constexpr MoveState MoveState_MIN =
    Object_MoveState_MoveState_MIN;
  static constexpr MoveState MoveState_MAX =
    Object_MoveState_MoveState_MAX;
  static constexpr int MoveState_ARRAYSIZE =
    Object_MoveState_MoveState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MoveState_descriptor() {
    return Object_MoveState_descriptor();
  }
  template<typename T>
  static inline const std::string& MoveState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MoveState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MoveState_Name.");
    return Object_MoveState_Name(enum_t_value);
  }
  static inline bool MoveState_Parse(const std::string& name,
      MoveState* value) {
    return Object_MoveState_Parse(name, value);
  }

  typedef Object_VehicleRigidAnchor VehicleRigidAnchor;
  static constexpr VehicleRigidAnchor kVRARear =
    Object_VehicleRigidAnchor_kVRARear;
  static constexpr VehicleRigidAnchor kVRARearWheel =
    Object_VehicleRigidAnchor_kVRARearWheel;
  static constexpr VehicleRigidAnchor kVRAHeadWheel =
    Object_VehicleRigidAnchor_kVRAHeadWheel;
  static constexpr VehicleRigidAnchor kVRAHead =
    Object_VehicleRigidAnchor_kVRAHead;
  static constexpr VehicleRigidAnchor kVRAMaxNum =
    Object_VehicleRigidAnchor_kVRAMaxNum;
  static inline bool VehicleRigidAnchor_IsValid(int value) {
    return Object_VehicleRigidAnchor_IsValid(value);
  }
  static constexpr VehicleRigidAnchor VehicleRigidAnchor_MIN =
    Object_VehicleRigidAnchor_VehicleRigidAnchor_MIN;
  static constexpr VehicleRigidAnchor VehicleRigidAnchor_MAX =
    Object_VehicleRigidAnchor_VehicleRigidAnchor_MAX;
  static constexpr int VehicleRigidAnchor_ARRAYSIZE =
    Object_VehicleRigidAnchor_VehicleRigidAnchor_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VehicleRigidAnchor_descriptor() {
    return Object_VehicleRigidAnchor_descriptor();
  }
  template<typename T>
  static inline const std::string& VehicleRigidAnchor_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VehicleRigidAnchor>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VehicleRigidAnchor_Name.");
    return Object_VehicleRigidAnchor_Name(enum_t_value);
  }
  static inline bool VehicleRigidAnchor_Parse(const std::string& name,
      VehicleRigidAnchor* value) {
    return Object_VehicleRigidAnchor_Parse(name, value);
  }

  typedef Object_TrackStatus TrackStatus;
  static constexpr TrackStatus kTSUnknown =
    Object_TrackStatus_kTSUnknown;
  static constexpr TrackStatus kTSFirstDetectd =
    Object_TrackStatus_kTSFirstDetectd;
  static constexpr TrackStatus kTSTracking =
    Object_TrackStatus_kTSTracking;
  static constexpr TrackStatus kTSPredict =
    Object_TrackStatus_kTSPredict;
  static inline bool TrackStatus_IsValid(int value) {
    return Object_TrackStatus_IsValid(value);
  }
  static constexpr TrackStatus TrackStatus_MIN =
    Object_TrackStatus_TrackStatus_MIN;
  static constexpr TrackStatus TrackStatus_MAX =
    Object_TrackStatus_TrackStatus_MAX;
  static constexpr int TrackStatus_ARRAYSIZE =
    Object_TrackStatus_TrackStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TrackStatus_descriptor() {
    return Object_TrackStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& TrackStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TrackStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TrackStatus_Name.");
    return Object_TrackStatus_Name(enum_t_value);
  }
  static inline bool TrackStatus_Parse(const std::string& name,
      TrackStatus* value) {
    return Object_TrackStatus_Parse(name, value);
  }

  typedef Object_SelectLevelStatus SelectLevelStatus;
  static constexpr SelectLevelStatus kSLOriginDet =
    Object_SelectLevelStatus_kSLOriginDet;
  static constexpr SelectLevelStatus kSLDetAfterInnerROINMS =
    Object_SelectLevelStatus_kSLDetAfterInnerROINMS;
  static constexpr SelectLevelStatus kSLDetAfterCrossROINMS =
    Object_SelectLevelStatus_kSLDetAfterCrossROINMS;
  static constexpr SelectLevelStatus kSLReservered =
    Object_SelectLevelStatus_kSLReservered;
  static constexpr SelectLevelStatus kSLCandidateDet =
    Object_SelectLevelStatus_kSLCandidateDet;
  static inline bool SelectLevelStatus_IsValid(int value) {
    return Object_SelectLevelStatus_IsValid(value);
  }
  static constexpr SelectLevelStatus SelectLevelStatus_MIN =
    Object_SelectLevelStatus_SelectLevelStatus_MIN;
  static constexpr SelectLevelStatus SelectLevelStatus_MAX =
    Object_SelectLevelStatus_SelectLevelStatus_MAX;
  static constexpr int SelectLevelStatus_ARRAYSIZE =
    Object_SelectLevelStatus_SelectLevelStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SelectLevelStatus_descriptor() {
    return Object_SelectLevelStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& SelectLevelStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SelectLevelStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SelectLevelStatus_Name.");
    return Object_SelectLevelStatus_Name(enum_t_value);
  }
  static inline bool SelectLevelStatus_Parse(const std::string& name,
      SelectLevelStatus* value) {
    return Object_SelectLevelStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKeyComponentsFieldNumber = 60,
    kHitTypeStrFieldNumber = 6,
    kImageInfoFieldNumber = 8,
    kWorldInfoFieldNumber = 9,
    kFusionInfoFieldNumber = 16,
    kLaneAssignmentFieldNumber = 21,
    kHasCutLaneFieldNumber = 22,
    kVehRigidFieldNumber = 23,
    kFeaturesFieldNumber = 24,
    kHitIdFieldNumber = 1,
    kHitTypeFieldNumber = 2,
    kConfidenceFieldNumber = 3,
    kFrameCntFieldNumber = 4,
    kTimeCreationFieldNumber = 7,
    kLifeTimeFieldNumber = 5,
    kTrackStatusFieldNumber = 10,
    kTraceStatusFieldNumber = 11,
    kSelectLevelFieldNumber = 12,
    kIdFieldNumber = 15,
    kMeasureTypeFieldNumber = 17,
    kTimestampFieldNumber = 18,
    kFrameIdFieldNumber = 19,
  };
  // repeated .perception.Object key_components = 60;
  int key_components_size() const;
  private:
  int _internal_key_components_size() const;
  public:
  void clear_key_components();
  ::perception::Object* mutable_key_components(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object >*
      mutable_key_components();
  private:
  const ::perception::Object& _internal_key_components(int index) const;
  ::perception::Object* _internal_add_key_components();
  public:
  const ::perception::Object& key_components(int index) const;
  ::perception::Object* add_key_components();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object >&
      key_components() const;

  // string hit_type_str = 6;
  void clear_hit_type_str();
  const std::string& hit_type_str() const;
  void set_hit_type_str(const std::string& value);
  void set_hit_type_str(std::string&& value);
  void set_hit_type_str(const char* value);
  void set_hit_type_str(const char* value, size_t size);
  std::string* mutable_hit_type_str();
  std::string* release_hit_type_str();
  void set_allocated_hit_type_str(std::string* hit_type_str);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_hit_type_str();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hit_type_str(
      std::string* hit_type_str);
  private:
  const std::string& _internal_hit_type_str() const;
  void _internal_set_hit_type_str(const std::string& value);
  std::string* _internal_mutable_hit_type_str();
  public:

  // .perception.Object.ImageInfo image_info = 8;
  bool has_image_info() const;
  private:
  bool _internal_has_image_info() const;
  public:
  void clear_image_info();
  const ::perception::Object_ImageInfo& image_info() const;
  ::perception::Object_ImageInfo* release_image_info();
  ::perception::Object_ImageInfo* mutable_image_info();
  void set_allocated_image_info(::perception::Object_ImageInfo* image_info);
  private:
  const ::perception::Object_ImageInfo& _internal_image_info() const;
  ::perception::Object_ImageInfo* _internal_mutable_image_info();
  public:
  void unsafe_arena_set_allocated_image_info(
      ::perception::Object_ImageInfo* image_info);
  ::perception::Object_ImageInfo* unsafe_arena_release_image_info();

  // .perception.Object.WorldInfo world_info = 9;
  bool has_world_info() const;
  private:
  bool _internal_has_world_info() const;
  public:
  void clear_world_info();
  const ::perception::Object_WorldInfo& world_info() const;
  ::perception::Object_WorldInfo* release_world_info();
  ::perception::Object_WorldInfo* mutable_world_info();
  void set_allocated_world_info(::perception::Object_WorldInfo* world_info);
  private:
  const ::perception::Object_WorldInfo& _internal_world_info() const;
  ::perception::Object_WorldInfo* _internal_mutable_world_info();
  public:
  void unsafe_arena_set_allocated_world_info(
      ::perception::Object_WorldInfo* world_info);
  ::perception::Object_WorldInfo* unsafe_arena_release_world_info();

  // .perception.Object.FusionInfo fusion_info = 16;
  bool has_fusion_info() const;
  private:
  bool _internal_has_fusion_info() const;
  public:
  void clear_fusion_info();
  const ::perception::Object_FusionInfo& fusion_info() const;
  ::perception::Object_FusionInfo* release_fusion_info();
  ::perception::Object_FusionInfo* mutable_fusion_info();
  void set_allocated_fusion_info(::perception::Object_FusionInfo* fusion_info);
  private:
  const ::perception::Object_FusionInfo& _internal_fusion_info() const;
  ::perception::Object_FusionInfo* _internal_mutable_fusion_info();
  public:
  void unsafe_arena_set_allocated_fusion_info(
      ::perception::Object_FusionInfo* fusion_info);
  ::perception::Object_FusionInfo* unsafe_arena_release_fusion_info();

  // .perception.common.Int lane_assignment = 21;
  bool has_lane_assignment() const;
  private:
  bool _internal_has_lane_assignment() const;
  public:
  void clear_lane_assignment();
  const ::perception::common::Int& lane_assignment() const;
  ::perception::common::Int* release_lane_assignment();
  ::perception::common::Int* mutable_lane_assignment();
  void set_allocated_lane_assignment(::perception::common::Int* lane_assignment);
  private:
  const ::perception::common::Int& _internal_lane_assignment() const;
  ::perception::common::Int* _internal_mutable_lane_assignment();
  public:
  void unsafe_arena_set_allocated_lane_assignment(
      ::perception::common::Int* lane_assignment);
  ::perception::common::Int* unsafe_arena_release_lane_assignment();

  // .perception.common.Float has_cut_lane = 22;
  bool has_has_cut_lane() const;
  private:
  bool _internal_has_has_cut_lane() const;
  public:
  void clear_has_cut_lane();
  const ::perception::common::Float& has_cut_lane() const;
  ::perception::common::Float* release_has_cut_lane();
  ::perception::common::Float* mutable_has_cut_lane();
  void set_allocated_has_cut_lane(::perception::common::Float* has_cut_lane);
  private:
  const ::perception::common::Float& _internal_has_cut_lane() const;
  ::perception::common::Float* _internal_mutable_has_cut_lane();
  public:
  void unsafe_arena_set_allocated_has_cut_lane(
      ::perception::common::Float* has_cut_lane);
  ::perception::common::Float* unsafe_arena_release_has_cut_lane();

  // .perception.Object.VehicleRigid veh_rigid = 23;
  bool has_veh_rigid() const;
  private:
  bool _internal_has_veh_rigid() const;
  public:
  void clear_veh_rigid();
  const ::perception::Object_VehicleRigid& veh_rigid() const;
  ::perception::Object_VehicleRigid* release_veh_rigid();
  ::perception::Object_VehicleRigid* mutable_veh_rigid();
  void set_allocated_veh_rigid(::perception::Object_VehicleRigid* veh_rigid);
  private:
  const ::perception::Object_VehicleRigid& _internal_veh_rigid() const;
  ::perception::Object_VehicleRigid* _internal_mutable_veh_rigid();
  public:
  void unsafe_arena_set_allocated_veh_rigid(
      ::perception::Object_VehicleRigid* veh_rigid);
  ::perception::Object_VehicleRigid* unsafe_arena_release_veh_rigid();

  // .perception.common.FloatArray features = 24;
  bool has_features() const;
  private:
  bool _internal_has_features() const;
  public:
  void clear_features();
  const ::perception::common::FloatArray& features() const;
  ::perception::common::FloatArray* release_features();
  ::perception::common::FloatArray* mutable_features();
  void set_allocated_features(::perception::common::FloatArray* features);
  private:
  const ::perception::common::FloatArray& _internal_features() const;
  ::perception::common::FloatArray* _internal_mutable_features();
  public:
  void unsafe_arena_set_allocated_features(
      ::perception::common::FloatArray* features);
  ::perception::common::FloatArray* unsafe_arena_release_features();

  // int32 hit_id = 1;
  void clear_hit_id();
  ::PROTOBUF_NAMESPACE_ID::int32 hit_id() const;
  void set_hit_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hit_id() const;
  void _internal_set_hit_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .perception.Object.ObjectType hit_type = 2;
  void clear_hit_type();
  ::perception::Object_ObjectType hit_type() const;
  void set_hit_type(::perception::Object_ObjectType value);
  private:
  ::perception::Object_ObjectType _internal_hit_type() const;
  void _internal_set_hit_type(::perception::Object_ObjectType value);
  public:

  // float confidence = 3;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // int32 frame_cnt = 4;
  void clear_frame_cnt();
  ::PROTOBUF_NAMESPACE_ID::int32 frame_cnt() const;
  void set_frame_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_frame_cnt() const;
  void _internal_set_frame_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint64 time_creation = 7;
  void clear_time_creation();
  ::PROTOBUF_NAMESPACE_ID::uint64 time_creation() const;
  void set_time_creation(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_time_creation() const;
  void _internal_set_time_creation(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int32 life_time = 5;
  void clear_life_time();
  ::PROTOBUF_NAMESPACE_ID::int32 life_time() const;
  void set_life_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_life_time() const;
  void _internal_set_life_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 track_status = 10;
  void clear_track_status();
  ::PROTOBUF_NAMESPACE_ID::int32 track_status() const;
  void set_track_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_track_status() const;
  void _internal_set_track_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 trace_status = 11;
  void clear_trace_status();
  ::PROTOBUF_NAMESPACE_ID::int32 trace_status() const;
  void set_trace_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trace_status() const;
  void _internal_set_trace_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 select_level = 12;
  void clear_select_level();
  ::PROTOBUF_NAMESPACE_ID::int32 select_level() const;
  void set_select_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_select_level() const;
  void _internal_set_select_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint32 id = 15;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .perception.Object.MeasureType measure_type = 17;
  void clear_measure_type();
  ::perception::Object_MeasureType measure_type() const;
  void set_measure_type(::perception::Object_MeasureType value);
  private:
  ::perception::Object_MeasureType _internal_measure_type() const;
  void _internal_set_measure_type(::perception::Object_MeasureType value);
  public:

  // uint64 timestamp = 18;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 frame_id = 19;
  void clear_frame_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id() const;
  void set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_frame_id() const;
  void _internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:perception.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object > key_components_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hit_type_str_;
  ::perception::Object_ImageInfo* image_info_;
  ::perception::Object_WorldInfo* world_info_;
  ::perception::Object_FusionInfo* fusion_info_;
  ::perception::common::Int* lane_assignment_;
  ::perception::common::Float* has_cut_lane_;
  ::perception::Object_VehicleRigid* veh_rigid_;
  ::perception::common::FloatArray* features_;
  ::PROTOBUF_NAMESPACE_ID::int32 hit_id_;
  int hit_type_;
  float confidence_;
  ::PROTOBUF_NAMESPACE_ID::int32 frame_cnt_;
  ::PROTOBUF_NAMESPACE_ID::uint64 time_creation_;
  ::PROTOBUF_NAMESPACE_ID::int32 life_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 track_status_;
  ::PROTOBUF_NAMESPACE_ID::int32 trace_status_;
  ::PROTOBUF_NAMESPACE_ID::int32 select_level_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  int measure_type_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_object_2eproto;
};
// -------------------------------------------------------------------

class ObjectList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.ObjectList) */ {
 public:
  inline ObjectList() : ObjectList(nullptr) {};
  virtual ~ObjectList();

  ObjectList(const ObjectList& from);
  ObjectList(ObjectList&& from) noexcept
    : ObjectList() {
    *this = ::std::move(from);
  }

  inline ObjectList& operator=(const ObjectList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectList& operator=(ObjectList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectList* internal_default_instance() {
    return reinterpret_cast<const ObjectList*>(
               &_ObjectList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ObjectList& a, ObjectList& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectList* New() const final {
    return CreateMaybeMessage<ObjectList>(nullptr);
  }

  ObjectList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectList& from);
  void MergeFrom(const ObjectList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.ObjectList";
  }
  protected:
  explicit ObjectList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_object_2eproto);
    return ::descriptor_table_object_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 1,
    kRoiListFieldNumber = 7,
    kProfilingTimeFieldNumber = 12,
    kVersionFieldNumber = 3,
    kWarningFieldNumber = 6,
    kCalibParamFieldNumber = 16,
    kVehicleSignalFieldNumber = 17,
    kCameraParamFieldNumber = 18,
    kCamIdFieldNumber = 19,
    kFrameIdFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kTickFieldNumber = 9,
    kStartTimeUsFieldNumber = 10,
    kEndTimeUsFieldNumber = 11,
    kDataSourceFieldNumber = 15,
    kCamPrjIdFieldNumber = 20,
  };
  // repeated .perception.Object list = 1;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::perception::Object* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object >*
      mutable_list();
  private:
  const ::perception::Object& _internal_list(int index) const;
  ::perception::Object* _internal_add_list();
  public:
  const ::perception::Object& list(int index) const;
  ::perception::Object* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object >&
      list() const;

  // repeated .perception.common.Rect2f roi_list = 7;
  int roi_list_size() const;
  private:
  int _internal_roi_list_size() const;
  public:
  void clear_roi_list();
  ::perception::common::Rect2f* mutable_roi_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Rect2f >*
      mutable_roi_list();
  private:
  const ::perception::common::Rect2f& _internal_roi_list(int index) const;
  ::perception::common::Rect2f* _internal_add_roi_list();
  public:
  const ::perception::common::Rect2f& roi_list(int index) const;
  ::perception::common::Rect2f* add_roi_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Rect2f >&
      roi_list() const;

  // repeated uint64 profiling_time = 12;
  int profiling_time_size() const;
  private:
  int _internal_profiling_time_size() const;
  public:
  void clear_profiling_time();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_profiling_time(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_profiling_time() const;
  void _internal_add_profiling_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_profiling_time();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 profiling_time(int index) const;
  void set_profiling_time(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_profiling_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      profiling_time() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_profiling_time();

  // string version = 3;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_version();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_version(
      std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .perception.object.Warning warning = 6;
  bool has_warning() const;
  private:
  bool _internal_has_warning() const;
  public:
  void clear_warning();
  const ::perception::object::Warning& warning() const;
  ::perception::object::Warning* release_warning();
  ::perception::object::Warning* mutable_warning();
  void set_allocated_warning(::perception::object::Warning* warning);
  private:
  const ::perception::object::Warning& _internal_warning() const;
  ::perception::object::Warning* _internal_mutable_warning();
  public:
  void unsafe_arena_set_allocated_warning(
      ::perception::object::Warning* warning);
  ::perception::object::Warning* unsafe_arena_release_warning();

  // .minieye.CalibParam calib_param = 16;
  bool has_calib_param() const;
  private:
  bool _internal_has_calib_param() const;
  public:
  void clear_calib_param();
  const ::minieye::CalibParam& calib_param() const;
  ::minieye::CalibParam* release_calib_param();
  ::minieye::CalibParam* mutable_calib_param();
  void set_allocated_calib_param(::minieye::CalibParam* calib_param);
  private:
  const ::minieye::CalibParam& _internal_calib_param() const;
  ::minieye::CalibParam* _internal_mutable_calib_param();
  public:
  void unsafe_arena_set_allocated_calib_param(
      ::minieye::CalibParam* calib_param);
  ::minieye::CalibParam* unsafe_arena_release_calib_param();

  // .minieye.VehicleSignal vehicle_signal = 17;
  bool has_vehicle_signal() const;
  private:
  bool _internal_has_vehicle_signal() const;
  public:
  void clear_vehicle_signal();
  const ::minieye::VehicleSignal& vehicle_signal() const;
  ::minieye::VehicleSignal* release_vehicle_signal();
  ::minieye::VehicleSignal* mutable_vehicle_signal();
  void set_allocated_vehicle_signal(::minieye::VehicleSignal* vehicle_signal);
  private:
  const ::minieye::VehicleSignal& _internal_vehicle_signal() const;
  ::minieye::VehicleSignal* _internal_mutable_vehicle_signal();
  public:
  void unsafe_arena_set_allocated_vehicle_signal(
      ::minieye::VehicleSignal* vehicle_signal);
  ::minieye::VehicleSignal* unsafe_arena_release_vehicle_signal();

  // .minieye.CameraParam camera_param = 18;
  bool has_camera_param() const;
  private:
  bool _internal_has_camera_param() const;
  public:
  void clear_camera_param();
  const ::minieye::CameraParam& camera_param() const;
  ::minieye::CameraParam* release_camera_param();
  ::minieye::CameraParam* mutable_camera_param();
  void set_allocated_camera_param(::minieye::CameraParam* camera_param);
  private:
  const ::minieye::CameraParam& _internal_camera_param() const;
  ::minieye::CameraParam* _internal_mutable_camera_param();
  public:
  void unsafe_arena_set_allocated_camera_param(
      ::minieye::CameraParam* camera_param);
  ::minieye::CameraParam* unsafe_arena_release_camera_param();

  // .minieye.CamID cam_id = 19;
  bool has_cam_id() const;
  private:
  bool _internal_has_cam_id() const;
  public:
  void clear_cam_id();
  const ::minieye::CamID& cam_id() const;
  ::minieye::CamID* release_cam_id();
  ::minieye::CamID* mutable_cam_id();
  void set_allocated_cam_id(::minieye::CamID* cam_id);
  private:
  const ::minieye::CamID& _internal_cam_id() const;
  ::minieye::CamID* _internal_mutable_cam_id();
  public:
  void unsafe_arena_set_allocated_cam_id(
      ::minieye::CamID* cam_id);
  ::minieye::CamID* unsafe_arena_release_cam_id();

  // uint64 frame_id = 4;
  void clear_frame_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id() const;
  void set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_frame_id() const;
  void _internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 timestamp = 5;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 tick = 9;
  void clear_tick();
  ::PROTOBUF_NAMESPACE_ID::uint64 tick() const;
  void set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tick() const;
  void _internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 start_time_us = 10;
  void clear_start_time_us();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_time_us() const;
  void set_start_time_us(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_start_time_us() const;
  void _internal_set_start_time_us(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 end_time_us = 11;
  void clear_end_time_us();
  ::PROTOBUF_NAMESPACE_ID::uint64 end_time_us() const;
  void set_end_time_us(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_end_time_us() const;
  void _internal_set_end_time_us(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .minieye.DataSource data_source = 15;
  void clear_data_source();
  ::minieye::DataSource data_source() const;
  void set_data_source(::minieye::DataSource value);
  private:
  ::minieye::DataSource _internal_data_source() const;
  void _internal_set_data_source(::minieye::DataSource value);
  public:

  // uint32 cam_prj_id = 20;
  void clear_cam_prj_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 cam_prj_id() const;
  void set_cam_prj_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_cam_prj_id() const;
  void _internal_set_cam_prj_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:perception.ObjectList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object > list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Rect2f > roi_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > profiling_time_;
  mutable std::atomic<int> _profiling_time_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::perception::object::Warning* warning_;
  ::minieye::CalibParam* calib_param_;
  ::minieye::VehicleSignal* vehicle_signal_;
  ::minieye::CameraParam* camera_param_;
  ::minieye::CamID* cam_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tick_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_time_us_;
  ::PROTOBUF_NAMESPACE_ID::uint64 end_time_us_;
  int data_source_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cam_prj_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_object_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Object_ImageInfo

// .perception.common.Rect2f det_rect = 1;
inline bool Object_ImageInfo::_internal_has_det_rect() const {
  return this != internal_default_instance() && det_rect_ != nullptr;
}
inline bool Object_ImageInfo::has_det_rect() const {
  return _internal_has_det_rect();
}
inline const ::perception::common::Rect2f& Object_ImageInfo::_internal_det_rect() const {
  const ::perception::common::Rect2f* p = det_rect_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Rect2f*>(
      &::perception::common::_Rect2f_default_instance_);
}
inline const ::perception::common::Rect2f& Object_ImageInfo::det_rect() const {
  // @@protoc_insertion_point(field_get:perception.Object.ImageInfo.det_rect)
  return _internal_det_rect();
}
inline void Object_ImageInfo::unsafe_arena_set_allocated_det_rect(
    ::perception::common::Rect2f* det_rect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(det_rect_);
  }
  det_rect_ = det_rect;
  if (det_rect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.ImageInfo.det_rect)
}
inline ::perception::common::Rect2f* Object_ImageInfo::release_det_rect() {
  auto temp = unsafe_arena_release_det_rect();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Rect2f* Object_ImageInfo::unsafe_arena_release_det_rect() {
  // @@protoc_insertion_point(field_release:perception.Object.ImageInfo.det_rect)
  
  ::perception::common::Rect2f* temp = det_rect_;
  det_rect_ = nullptr;
  return temp;
}
inline ::perception::common::Rect2f* Object_ImageInfo::_internal_mutable_det_rect() {
  
  if (det_rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Rect2f>(GetArena());
    det_rect_ = p;
  }
  return det_rect_;
}
inline ::perception::common::Rect2f* Object_ImageInfo::mutable_det_rect() {
  // @@protoc_insertion_point(field_mutable:perception.Object.ImageInfo.det_rect)
  return _internal_mutable_det_rect();
}
inline void Object_ImageInfo::set_allocated_det_rect(::perception::common::Rect2f* det_rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(det_rect_);
  }
  if (det_rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(det_rect)->GetArena();
    if (message_arena != submessage_arena) {
      det_rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, det_rect, submessage_arena);
    }
    
  } else {
    
  }
  det_rect_ = det_rect;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.ImageInfo.det_rect)
}

// .perception.common.Rect2f reg_rect = 2;
inline bool Object_ImageInfo::_internal_has_reg_rect() const {
  return this != internal_default_instance() && reg_rect_ != nullptr;
}
inline bool Object_ImageInfo::has_reg_rect() const {
  return _internal_has_reg_rect();
}
inline const ::perception::common::Rect2f& Object_ImageInfo::_internal_reg_rect() const {
  const ::perception::common::Rect2f* p = reg_rect_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Rect2f*>(
      &::perception::common::_Rect2f_default_instance_);
}
inline const ::perception::common::Rect2f& Object_ImageInfo::reg_rect() const {
  // @@protoc_insertion_point(field_get:perception.Object.ImageInfo.reg_rect)
  return _internal_reg_rect();
}
inline void Object_ImageInfo::unsafe_arena_set_allocated_reg_rect(
    ::perception::common::Rect2f* reg_rect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reg_rect_);
  }
  reg_rect_ = reg_rect;
  if (reg_rect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.ImageInfo.reg_rect)
}
inline ::perception::common::Rect2f* Object_ImageInfo::release_reg_rect() {
  auto temp = unsafe_arena_release_reg_rect();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Rect2f* Object_ImageInfo::unsafe_arena_release_reg_rect() {
  // @@protoc_insertion_point(field_release:perception.Object.ImageInfo.reg_rect)
  
  ::perception::common::Rect2f* temp = reg_rect_;
  reg_rect_ = nullptr;
  return temp;
}
inline ::perception::common::Rect2f* Object_ImageInfo::_internal_mutable_reg_rect() {
  
  if (reg_rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Rect2f>(GetArena());
    reg_rect_ = p;
  }
  return reg_rect_;
}
inline ::perception::common::Rect2f* Object_ImageInfo::mutable_reg_rect() {
  // @@protoc_insertion_point(field_mutable:perception.Object.ImageInfo.reg_rect)
  return _internal_mutable_reg_rect();
}
inline void Object_ImageInfo::set_allocated_reg_rect(::perception::common::Rect2f* reg_rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(reg_rect_);
  }
  if (reg_rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reg_rect)->GetArena();
    if (message_arena != submessage_arena) {
      reg_rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reg_rect, submessage_arena);
    }
    
  } else {
    
  }
  reg_rect_ = reg_rect;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.ImageInfo.reg_rect)
}

// .perception.common.Rect2f track_rect = 3;
inline bool Object_ImageInfo::_internal_has_track_rect() const {
  return this != internal_default_instance() && track_rect_ != nullptr;
}
inline bool Object_ImageInfo::has_track_rect() const {
  return _internal_has_track_rect();
}
inline const ::perception::common::Rect2f& Object_ImageInfo::_internal_track_rect() const {
  const ::perception::common::Rect2f* p = track_rect_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Rect2f*>(
      &::perception::common::_Rect2f_default_instance_);
}
inline const ::perception::common::Rect2f& Object_ImageInfo::track_rect() const {
  // @@protoc_insertion_point(field_get:perception.Object.ImageInfo.track_rect)
  return _internal_track_rect();
}
inline void Object_ImageInfo::unsafe_arena_set_allocated_track_rect(
    ::perception::common::Rect2f* track_rect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(track_rect_);
  }
  track_rect_ = track_rect;
  if (track_rect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.ImageInfo.track_rect)
}
inline ::perception::common::Rect2f* Object_ImageInfo::release_track_rect() {
  auto temp = unsafe_arena_release_track_rect();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Rect2f* Object_ImageInfo::unsafe_arena_release_track_rect() {
  // @@protoc_insertion_point(field_release:perception.Object.ImageInfo.track_rect)
  
  ::perception::common::Rect2f* temp = track_rect_;
  track_rect_ = nullptr;
  return temp;
}
inline ::perception::common::Rect2f* Object_ImageInfo::_internal_mutable_track_rect() {
  
  if (track_rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Rect2f>(GetArena());
    track_rect_ = p;
  }
  return track_rect_;
}
inline ::perception::common::Rect2f* Object_ImageInfo::mutable_track_rect() {
  // @@protoc_insertion_point(field_mutable:perception.Object.ImageInfo.track_rect)
  return _internal_mutable_track_rect();
}
inline void Object_ImageInfo::set_allocated_track_rect(::perception::common::Rect2f* track_rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(track_rect_);
  }
  if (track_rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(track_rect)->GetArena();
    if (message_arena != submessage_arena) {
      track_rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track_rect, submessage_arena);
    }
    
  } else {
    
  }
  track_rect_ = track_rect;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.ImageInfo.track_rect)
}

// .perception.common.Rect2f smooth_rect = 4;
inline bool Object_ImageInfo::_internal_has_smooth_rect() const {
  return this != internal_default_instance() && smooth_rect_ != nullptr;
}
inline bool Object_ImageInfo::has_smooth_rect() const {
  return _internal_has_smooth_rect();
}
inline const ::perception::common::Rect2f& Object_ImageInfo::_internal_smooth_rect() const {
  const ::perception::common::Rect2f* p = smooth_rect_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Rect2f*>(
      &::perception::common::_Rect2f_default_instance_);
}
inline const ::perception::common::Rect2f& Object_ImageInfo::smooth_rect() const {
  // @@protoc_insertion_point(field_get:perception.Object.ImageInfo.smooth_rect)
  return _internal_smooth_rect();
}
inline void Object_ImageInfo::unsafe_arena_set_allocated_smooth_rect(
    ::perception::common::Rect2f* smooth_rect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(smooth_rect_);
  }
  smooth_rect_ = smooth_rect;
  if (smooth_rect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.ImageInfo.smooth_rect)
}
inline ::perception::common::Rect2f* Object_ImageInfo::release_smooth_rect() {
  auto temp = unsafe_arena_release_smooth_rect();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Rect2f* Object_ImageInfo::unsafe_arena_release_smooth_rect() {
  // @@protoc_insertion_point(field_release:perception.Object.ImageInfo.smooth_rect)
  
  ::perception::common::Rect2f* temp = smooth_rect_;
  smooth_rect_ = nullptr;
  return temp;
}
inline ::perception::common::Rect2f* Object_ImageInfo::_internal_mutable_smooth_rect() {
  
  if (smooth_rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Rect2f>(GetArena());
    smooth_rect_ = p;
  }
  return smooth_rect_;
}
inline ::perception::common::Rect2f* Object_ImageInfo::mutable_smooth_rect() {
  // @@protoc_insertion_point(field_mutable:perception.Object.ImageInfo.smooth_rect)
  return _internal_mutable_smooth_rect();
}
inline void Object_ImageInfo::set_allocated_smooth_rect(::perception::common::Rect2f* smooth_rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(smooth_rect_);
  }
  if (smooth_rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(smooth_rect)->GetArena();
    if (message_arena != submessage_arena) {
      smooth_rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, smooth_rect, submessage_arena);
    }
    
  } else {
    
  }
  smooth_rect_ = smooth_rect;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.ImageInfo.smooth_rect)
}

// .perception.common.Rect2f plate_rect = 5;
inline bool Object_ImageInfo::_internal_has_plate_rect() const {
  return this != internal_default_instance() && plate_rect_ != nullptr;
}
inline bool Object_ImageInfo::has_plate_rect() const {
  return _internal_has_plate_rect();
}
inline const ::perception::common::Rect2f& Object_ImageInfo::_internal_plate_rect() const {
  const ::perception::common::Rect2f* p = plate_rect_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Rect2f*>(
      &::perception::common::_Rect2f_default_instance_);
}
inline const ::perception::common::Rect2f& Object_ImageInfo::plate_rect() const {
  // @@protoc_insertion_point(field_get:perception.Object.ImageInfo.plate_rect)
  return _internal_plate_rect();
}
inline void Object_ImageInfo::unsafe_arena_set_allocated_plate_rect(
    ::perception::common::Rect2f* plate_rect) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plate_rect_);
  }
  plate_rect_ = plate_rect;
  if (plate_rect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.ImageInfo.plate_rect)
}
inline ::perception::common::Rect2f* Object_ImageInfo::release_plate_rect() {
  auto temp = unsafe_arena_release_plate_rect();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Rect2f* Object_ImageInfo::unsafe_arena_release_plate_rect() {
  // @@protoc_insertion_point(field_release:perception.Object.ImageInfo.plate_rect)
  
  ::perception::common::Rect2f* temp = plate_rect_;
  plate_rect_ = nullptr;
  return temp;
}
inline ::perception::common::Rect2f* Object_ImageInfo::_internal_mutable_plate_rect() {
  
  if (plate_rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Rect2f>(GetArena());
    plate_rect_ = p;
  }
  return plate_rect_;
}
inline ::perception::common::Rect2f* Object_ImageInfo::mutable_plate_rect() {
  // @@protoc_insertion_point(field_mutable:perception.Object.ImageInfo.plate_rect)
  return _internal_mutable_plate_rect();
}
inline void Object_ImageInfo::set_allocated_plate_rect(::perception::common::Rect2f* plate_rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(plate_rect_);
  }
  if (plate_rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plate_rect)->GetArena();
    if (message_arena != submessage_arena) {
      plate_rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plate_rect, submessage_arena);
    }
    
  } else {
    
  }
  plate_rect_ = plate_rect;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.ImageInfo.plate_rect)
}

// repeated .perception.common.Rect2f wheel_list = 6;
inline int Object_ImageInfo::_internal_wheel_list_size() const {
  return wheel_list_.size();
}
inline int Object_ImageInfo::wheel_list_size() const {
  return _internal_wheel_list_size();
}
inline ::perception::common::Rect2f* Object_ImageInfo::mutable_wheel_list(int index) {
  // @@protoc_insertion_point(field_mutable:perception.Object.ImageInfo.wheel_list)
  return wheel_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Rect2f >*
Object_ImageInfo::mutable_wheel_list() {
  // @@protoc_insertion_point(field_mutable_list:perception.Object.ImageInfo.wheel_list)
  return &wheel_list_;
}
inline const ::perception::common::Rect2f& Object_ImageInfo::_internal_wheel_list(int index) const {
  return wheel_list_.Get(index);
}
inline const ::perception::common::Rect2f& Object_ImageInfo::wheel_list(int index) const {
  // @@protoc_insertion_point(field_get:perception.Object.ImageInfo.wheel_list)
  return _internal_wheel_list(index);
}
inline ::perception::common::Rect2f* Object_ImageInfo::_internal_add_wheel_list() {
  return wheel_list_.Add();
}
inline ::perception::common::Rect2f* Object_ImageInfo::add_wheel_list() {
  // @@protoc_insertion_point(field_add:perception.Object.ImageInfo.wheel_list)
  return _internal_add_wheel_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Rect2f >&
Object_ImageInfo::wheel_list() const {
  // @@protoc_insertion_point(field_list:perception.Object.ImageInfo.wheel_list)
  return wheel_list_;
}

// repeated .perception.common.Point2f reg_pt_list = 7;
inline int Object_ImageInfo::_internal_reg_pt_list_size() const {
  return reg_pt_list_.size();
}
inline int Object_ImageInfo::reg_pt_list_size() const {
  return _internal_reg_pt_list_size();
}
inline ::perception::common::Point2f* Object_ImageInfo::mutable_reg_pt_list(int index) {
  // @@protoc_insertion_point(field_mutable:perception.Object.ImageInfo.reg_pt_list)
  return reg_pt_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Point2f >*
Object_ImageInfo::mutable_reg_pt_list() {
  // @@protoc_insertion_point(field_mutable_list:perception.Object.ImageInfo.reg_pt_list)
  return &reg_pt_list_;
}
inline const ::perception::common::Point2f& Object_ImageInfo::_internal_reg_pt_list(int index) const {
  return reg_pt_list_.Get(index);
}
inline const ::perception::common::Point2f& Object_ImageInfo::reg_pt_list(int index) const {
  // @@protoc_insertion_point(field_get:perception.Object.ImageInfo.reg_pt_list)
  return _internal_reg_pt_list(index);
}
inline ::perception::common::Point2f* Object_ImageInfo::_internal_add_reg_pt_list() {
  return reg_pt_list_.Add();
}
inline ::perception::common::Point2f* Object_ImageInfo::add_reg_pt_list() {
  // @@protoc_insertion_point(field_add:perception.Object.ImageInfo.reg_pt_list)
  return _internal_add_reg_pt_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Point2f >&
Object_ImageInfo::reg_pt_list() const {
  // @@protoc_insertion_point(field_list:perception.Object.ImageInfo.reg_pt_list)
  return reg_pt_list_;
}

// .perception.common.Box3D box = 10;
inline bool Object_ImageInfo::_internal_has_box() const {
  return this != internal_default_instance() && box_ != nullptr;
}
inline bool Object_ImageInfo::has_box() const {
  return _internal_has_box();
}
inline const ::perception::common::Box3D& Object_ImageInfo::_internal_box() const {
  const ::perception::common::Box3D* p = box_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Box3D*>(
      &::perception::common::_Box3D_default_instance_);
}
inline const ::perception::common::Box3D& Object_ImageInfo::box() const {
  // @@protoc_insertion_point(field_get:perception.Object.ImageInfo.box)
  return _internal_box();
}
inline void Object_ImageInfo::unsafe_arena_set_allocated_box(
    ::perception::common::Box3D* box) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box_);
  }
  box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.ImageInfo.box)
}
inline ::perception::common::Box3D* Object_ImageInfo::release_box() {
  auto temp = unsafe_arena_release_box();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Box3D* Object_ImageInfo::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:perception.Object.ImageInfo.box)
  
  ::perception::common::Box3D* temp = box_;
  box_ = nullptr;
  return temp;
}
inline ::perception::common::Box3D* Object_ImageInfo::_internal_mutable_box() {
  
  if (box_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Box3D>(GetArena());
    box_ = p;
  }
  return box_;
}
inline ::perception::common::Box3D* Object_ImageInfo::mutable_box() {
  // @@protoc_insertion_point(field_mutable:perception.Object.ImageInfo.box)
  return _internal_mutable_box();
}
inline void Object_ImageInfo::set_allocated_box(::perception::common::Box3D* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(box_);
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box)->GetArena();
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    
  } else {
    
  }
  box_ = box;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.ImageInfo.box)
}

// .minieye.CamID camera_id = 11;
inline bool Object_ImageInfo::_internal_has_camera_id() const {
  return this != internal_default_instance() && camera_id_ != nullptr;
}
inline bool Object_ImageInfo::has_camera_id() const {
  return _internal_has_camera_id();
}
inline const ::minieye::CamID& Object_ImageInfo::_internal_camera_id() const {
  const ::minieye::CamID* p = camera_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::CamID*>(
      &::minieye::_CamID_default_instance_);
}
inline const ::minieye::CamID& Object_ImageInfo::camera_id() const {
  // @@protoc_insertion_point(field_get:perception.Object.ImageInfo.camera_id)
  return _internal_camera_id();
}
inline void Object_ImageInfo::unsafe_arena_set_allocated_camera_id(
    ::minieye::CamID* camera_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_id_);
  }
  camera_id_ = camera_id;
  if (camera_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.ImageInfo.camera_id)
}
inline ::minieye::CamID* Object_ImageInfo::release_camera_id() {
  auto temp = unsafe_arena_release_camera_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::CamID* Object_ImageInfo::unsafe_arena_release_camera_id() {
  // @@protoc_insertion_point(field_release:perception.Object.ImageInfo.camera_id)
  
  ::minieye::CamID* temp = camera_id_;
  camera_id_ = nullptr;
  return temp;
}
inline ::minieye::CamID* Object_ImageInfo::_internal_mutable_camera_id() {
  
  if (camera_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::CamID>(GetArena());
    camera_id_ = p;
  }
  return camera_id_;
}
inline ::minieye::CamID* Object_ImageInfo::mutable_camera_id() {
  // @@protoc_insertion_point(field_mutable:perception.Object.ImageInfo.camera_id)
  return _internal_mutable_camera_id();
}
inline void Object_ImageInfo::set_allocated_camera_id(::minieye::CamID* camera_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_id_);
  }
  if (camera_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_id)->GetArena();
    if (message_arena != submessage_arena) {
      camera_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_id, submessage_arena);
    }
    
  } else {
    
  }
  camera_id_ = camera_id;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.ImageInfo.camera_id)
}

// -------------------------------------------------------------------

// Object_VehicleRigid

// repeated .perception.common.Float meas_along_length = 1;
inline int Object_VehicleRigid::_internal_meas_along_length_size() const {
  return meas_along_length_.size();
}
inline int Object_VehicleRigid::meas_along_length_size() const {
  return _internal_meas_along_length_size();
}
inline ::perception::common::Float* Object_VehicleRigid::mutable_meas_along_length(int index) {
  // @@protoc_insertion_point(field_mutable:perception.Object.VehicleRigid.meas_along_length)
  return meas_along_length_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Float >*
Object_VehicleRigid::mutable_meas_along_length() {
  // @@protoc_insertion_point(field_mutable_list:perception.Object.VehicleRigid.meas_along_length)
  return &meas_along_length_;
}
inline const ::perception::common::Float& Object_VehicleRigid::_internal_meas_along_length(int index) const {
  return meas_along_length_.Get(index);
}
inline const ::perception::common::Float& Object_VehicleRigid::meas_along_length(int index) const {
  // @@protoc_insertion_point(field_get:perception.Object.VehicleRigid.meas_along_length)
  return _internal_meas_along_length(index);
}
inline ::perception::common::Float* Object_VehicleRigid::_internal_add_meas_along_length() {
  return meas_along_length_.Add();
}
inline ::perception::common::Float* Object_VehicleRigid::add_meas_along_length() {
  // @@protoc_insertion_point(field_add:perception.Object.VehicleRigid.meas_along_length)
  return _internal_add_meas_along_length();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Float >&
Object_VehicleRigid::meas_along_length() const {
  // @@protoc_insertion_point(field_list:perception.Object.VehicleRigid.meas_along_length)
  return meas_along_length_;
}

// .perception.common.Float w = 2;
inline bool Object_VehicleRigid::_internal_has_w() const {
  return this != internal_default_instance() && w_ != nullptr;
}
inline bool Object_VehicleRigid::has_w() const {
  return _internal_has_w();
}
inline const ::perception::common::Float& Object_VehicleRigid::_internal_w() const {
  const ::perception::common::Float* p = w_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Float*>(
      &::perception::common::_Float_default_instance_);
}
inline const ::perception::common::Float& Object_VehicleRigid::w() const {
  // @@protoc_insertion_point(field_get:perception.Object.VehicleRigid.w)
  return _internal_w();
}
inline void Object_VehicleRigid::unsafe_arena_set_allocated_w(
    ::perception::common::Float* w) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(w_);
  }
  w_ = w;
  if (w) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.VehicleRigid.w)
}
inline ::perception::common::Float* Object_VehicleRigid::release_w() {
  auto temp = unsafe_arena_release_w();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Float* Object_VehicleRigid::unsafe_arena_release_w() {
  // @@protoc_insertion_point(field_release:perception.Object.VehicleRigid.w)
  
  ::perception::common::Float* temp = w_;
  w_ = nullptr;
  return temp;
}
inline ::perception::common::Float* Object_VehicleRigid::_internal_mutable_w() {
  
  if (w_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Float>(GetArena());
    w_ = p;
  }
  return w_;
}
inline ::perception::common::Float* Object_VehicleRigid::mutable_w() {
  // @@protoc_insertion_point(field_mutable:perception.Object.VehicleRigid.w)
  return _internal_mutable_w();
}
inline void Object_VehicleRigid::set_allocated_w(::perception::common::Float* w) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(w_);
  }
  if (w) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(w)->GetArena();
    if (message_arena != submessage_arena) {
      w = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, w, submessage_arena);
    }
    
  } else {
    
  }
  w_ = w;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.VehicleRigid.w)
}

// .perception.common.Float h = 3;
inline bool Object_VehicleRigid::_internal_has_h() const {
  return this != internal_default_instance() && h_ != nullptr;
}
inline bool Object_VehicleRigid::has_h() const {
  return _internal_has_h();
}
inline const ::perception::common::Float& Object_VehicleRigid::_internal_h() const {
  const ::perception::common::Float* p = h_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Float*>(
      &::perception::common::_Float_default_instance_);
}
inline const ::perception::common::Float& Object_VehicleRigid::h() const {
  // @@protoc_insertion_point(field_get:perception.Object.VehicleRigid.h)
  return _internal_h();
}
inline void Object_VehicleRigid::unsafe_arena_set_allocated_h(
    ::perception::common::Float* h) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(h_);
  }
  h_ = h;
  if (h) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.VehicleRigid.h)
}
inline ::perception::common::Float* Object_VehicleRigid::release_h() {
  auto temp = unsafe_arena_release_h();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Float* Object_VehicleRigid::unsafe_arena_release_h() {
  // @@protoc_insertion_point(field_release:perception.Object.VehicleRigid.h)
  
  ::perception::common::Float* temp = h_;
  h_ = nullptr;
  return temp;
}
inline ::perception::common::Float* Object_VehicleRigid::_internal_mutable_h() {
  
  if (h_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Float>(GetArena());
    h_ = p;
  }
  return h_;
}
inline ::perception::common::Float* Object_VehicleRigid::mutable_h() {
  // @@protoc_insertion_point(field_mutable:perception.Object.VehicleRigid.h)
  return _internal_mutable_h();
}
inline void Object_VehicleRigid::set_allocated_h(::perception::common::Float* h) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(h_);
  }
  if (h) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(h)->GetArena();
    if (message_arena != submessage_arena) {
      h = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, h, submessage_arena);
    }
    
  } else {
    
  }
  h_ = h;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.VehicleRigid.h)
}

// -------------------------------------------------------------------

// Object_WorldInfo

// .perception.common.XYZ vel = 1;
inline bool Object_WorldInfo::_internal_has_vel() const {
  return this != internal_default_instance() && vel_ != nullptr;
}
inline bool Object_WorldInfo::has_vel() const {
  return _internal_has_vel();
}
inline const ::perception::common::XYZ& Object_WorldInfo::_internal_vel() const {
  const ::perception::common::XYZ* p = vel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::XYZ*>(
      &::perception::common::_XYZ_default_instance_);
}
inline const ::perception::common::XYZ& Object_WorldInfo::vel() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.vel)
  return _internal_vel();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_vel(
    ::perception::common::XYZ* vel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vel_);
  }
  vel_ = vel;
  if (vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.vel)
}
inline ::perception::common::XYZ* Object_WorldInfo::release_vel() {
  auto temp = unsafe_arena_release_vel();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::XYZ* Object_WorldInfo::unsafe_arena_release_vel() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.vel)
  
  ::perception::common::XYZ* temp = vel_;
  vel_ = nullptr;
  return temp;
}
inline ::perception::common::XYZ* Object_WorldInfo::_internal_mutable_vel() {
  
  if (vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::XYZ>(GetArena());
    vel_ = p;
  }
  return vel_;
}
inline ::perception::common::XYZ* Object_WorldInfo::mutable_vel() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.vel)
  return _internal_mutable_vel();
}
inline void Object_WorldInfo::set_allocated_vel(::perception::common::XYZ* vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vel_);
  }
  if (vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vel)->GetArena();
    if (message_arena != submessage_arena) {
      vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vel, submessage_arena);
    }
    
  } else {
    
  }
  vel_ = vel;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.vel)
}

// .perception.common.XYZ rel_vel = 2;
inline bool Object_WorldInfo::_internal_has_rel_vel() const {
  return this != internal_default_instance() && rel_vel_ != nullptr;
}
inline bool Object_WorldInfo::has_rel_vel() const {
  return _internal_has_rel_vel();
}
inline const ::perception::common::XYZ& Object_WorldInfo::_internal_rel_vel() const {
  const ::perception::common::XYZ* p = rel_vel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::XYZ*>(
      &::perception::common::_XYZ_default_instance_);
}
inline const ::perception::common::XYZ& Object_WorldInfo::rel_vel() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.rel_vel)
  return _internal_rel_vel();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_rel_vel(
    ::perception::common::XYZ* rel_vel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rel_vel_);
  }
  rel_vel_ = rel_vel;
  if (rel_vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.rel_vel)
}
inline ::perception::common::XYZ* Object_WorldInfo::release_rel_vel() {
  auto temp = unsafe_arena_release_rel_vel();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::XYZ* Object_WorldInfo::unsafe_arena_release_rel_vel() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.rel_vel)
  
  ::perception::common::XYZ* temp = rel_vel_;
  rel_vel_ = nullptr;
  return temp;
}
inline ::perception::common::XYZ* Object_WorldInfo::_internal_mutable_rel_vel() {
  
  if (rel_vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::XYZ>(GetArena());
    rel_vel_ = p;
  }
  return rel_vel_;
}
inline ::perception::common::XYZ* Object_WorldInfo::mutable_rel_vel() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.rel_vel)
  return _internal_mutable_rel_vel();
}
inline void Object_WorldInfo::set_allocated_rel_vel(::perception::common::XYZ* rel_vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rel_vel_);
  }
  if (rel_vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rel_vel)->GetArena();
    if (message_arena != submessage_arena) {
      rel_vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rel_vel, submessage_arena);
    }
    
  } else {
    
  }
  rel_vel_ = rel_vel;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.rel_vel)
}

// .perception.common.XYZ acc = 3;
inline bool Object_WorldInfo::_internal_has_acc() const {
  return this != internal_default_instance() && acc_ != nullptr;
}
inline bool Object_WorldInfo::has_acc() const {
  return _internal_has_acc();
}
inline const ::perception::common::XYZ& Object_WorldInfo::_internal_acc() const {
  const ::perception::common::XYZ* p = acc_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::XYZ*>(
      &::perception::common::_XYZ_default_instance_);
}
inline const ::perception::common::XYZ& Object_WorldInfo::acc() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.acc)
  return _internal_acc();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_acc(
    ::perception::common::XYZ* acc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc_);
  }
  acc_ = acc;
  if (acc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.acc)
}
inline ::perception::common::XYZ* Object_WorldInfo::release_acc() {
  auto temp = unsafe_arena_release_acc();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::XYZ* Object_WorldInfo::unsafe_arena_release_acc() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.acc)
  
  ::perception::common::XYZ* temp = acc_;
  acc_ = nullptr;
  return temp;
}
inline ::perception::common::XYZ* Object_WorldInfo::_internal_mutable_acc() {
  
  if (acc_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::XYZ>(GetArena());
    acc_ = p;
  }
  return acc_;
}
inline ::perception::common::XYZ* Object_WorldInfo::mutable_acc() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.acc)
  return _internal_mutable_acc();
}
inline void Object_WorldInfo::set_allocated_acc(::perception::common::XYZ* acc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc_);
  }
  if (acc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc)->GetArena();
    if (message_arena != submessage_arena) {
      acc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acc, submessage_arena);
    }
    
  } else {
    
  }
  acc_ = acc;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.acc)
}

// .perception.common.XYZ pos = 4;
inline bool Object_WorldInfo::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool Object_WorldInfo::has_pos() const {
  return _internal_has_pos();
}
inline const ::perception::common::XYZ& Object_WorldInfo::_internal_pos() const {
  const ::perception::common::XYZ* p = pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::XYZ*>(
      &::perception::common::_XYZ_default_instance_);
}
inline const ::perception::common::XYZ& Object_WorldInfo::pos() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.pos)
  return _internal_pos();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_pos(
    ::perception::common::XYZ* pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.pos)
}
inline ::perception::common::XYZ* Object_WorldInfo::release_pos() {
  auto temp = unsafe_arena_release_pos();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::XYZ* Object_WorldInfo::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.pos)
  
  ::perception::common::XYZ* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::perception::common::XYZ* Object_WorldInfo::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::XYZ>(GetArena());
    pos_ = p;
  }
  return pos_;
}
inline ::perception::common::XYZ* Object_WorldInfo::mutable_pos() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.pos)
  return _internal_mutable_pos();
}
inline void Object_WorldInfo::set_allocated_pos(::perception::common::XYZ* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos)->GetArena();
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.pos)
}

// .perception.common.Size3D size = 5;
inline bool Object_WorldInfo::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool Object_WorldInfo::has_size() const {
  return _internal_has_size();
}
inline const ::perception::common::Size3D& Object_WorldInfo::_internal_size() const {
  const ::perception::common::Size3D* p = size_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Size3D*>(
      &::perception::common::_Size3D_default_instance_);
}
inline const ::perception::common::Size3D& Object_WorldInfo::size() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.size)
  return _internal_size();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_size(
    ::perception::common::Size3D* size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.size)
}
inline ::perception::common::Size3D* Object_WorldInfo::release_size() {
  auto temp = unsafe_arena_release_size();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Size3D* Object_WorldInfo::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.size)
  
  ::perception::common::Size3D* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::perception::common::Size3D* Object_WorldInfo::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Size3D>(GetArena());
    size_ = p;
  }
  return size_;
}
inline ::perception::common::Size3D* Object_WorldInfo::mutable_size() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.size)
  return _internal_mutable_size();
}
inline void Object_WorldInfo::set_allocated_size(::perception::common::Size3D* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size)->GetArena();
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.size)
}

// .perception.common.Angle3f angle = 6;
inline bool Object_WorldInfo::_internal_has_angle() const {
  return this != internal_default_instance() && angle_ != nullptr;
}
inline bool Object_WorldInfo::has_angle() const {
  return _internal_has_angle();
}
inline const ::perception::common::Angle3f& Object_WorldInfo::_internal_angle() const {
  const ::perception::common::Angle3f* p = angle_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Angle3f*>(
      &::perception::common::_Angle3f_default_instance_);
}
inline const ::perception::common::Angle3f& Object_WorldInfo::angle() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.angle)
  return _internal_angle();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_angle(
    ::perception::common::Angle3f* angle) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angle_);
  }
  angle_ = angle;
  if (angle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.angle)
}
inline ::perception::common::Angle3f* Object_WorldInfo::release_angle() {
  auto temp = unsafe_arena_release_angle();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Angle3f* Object_WorldInfo::unsafe_arena_release_angle() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.angle)
  
  ::perception::common::Angle3f* temp = angle_;
  angle_ = nullptr;
  return temp;
}
inline ::perception::common::Angle3f* Object_WorldInfo::_internal_mutable_angle() {
  
  if (angle_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Angle3f>(GetArena());
    angle_ = p;
  }
  return angle_;
}
inline ::perception::common::Angle3f* Object_WorldInfo::mutable_angle() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.angle)
  return _internal_mutable_angle();
}
inline void Object_WorldInfo::set_allocated_angle(::perception::common::Angle3f* angle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(angle_);
  }
  if (angle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angle)->GetArena();
    if (message_arena != submessage_arena) {
      angle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angle, submessage_arena);
    }
    
  } else {
    
  }
  angle_ = angle;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.angle)
}

// .perception.common.Box3D box = 10;
inline bool Object_WorldInfo::_internal_has_box() const {
  return this != internal_default_instance() && box_ != nullptr;
}
inline bool Object_WorldInfo::has_box() const {
  return _internal_has_box();
}
inline const ::perception::common::Box3D& Object_WorldInfo::_internal_box() const {
  const ::perception::common::Box3D* p = box_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Box3D*>(
      &::perception::common::_Box3D_default_instance_);
}
inline const ::perception::common::Box3D& Object_WorldInfo::box() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.box)
  return _internal_box();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_box(
    ::perception::common::Box3D* box) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box_);
  }
  box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.box)
}
inline ::perception::common::Box3D* Object_WorldInfo::release_box() {
  auto temp = unsafe_arena_release_box();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Box3D* Object_WorldInfo::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.box)
  
  ::perception::common::Box3D* temp = box_;
  box_ = nullptr;
  return temp;
}
inline ::perception::common::Box3D* Object_WorldInfo::_internal_mutable_box() {
  
  if (box_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Box3D>(GetArena());
    box_ = p;
  }
  return box_;
}
inline ::perception::common::Box3D* Object_WorldInfo::mutable_box() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.box)
  return _internal_mutable_box();
}
inline void Object_WorldInfo::set_allocated_box(::perception::common::Box3D* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(box_);
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box)->GetArena();
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    
  } else {
    
  }
  box_ = box;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.box)
}

// uint32 id = 11;
inline void Object_WorldInfo::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Object_WorldInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Object_WorldInfo::id() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.id)
  return _internal_id();
}
inline void Object_WorldInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void Object_WorldInfo::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:perception.Object.WorldInfo.id)
}

// .perception.common.Int cls = 12;
inline bool Object_WorldInfo::_internal_has_cls() const {
  return this != internal_default_instance() && cls_ != nullptr;
}
inline bool Object_WorldInfo::has_cls() const {
  return _internal_has_cls();
}
inline const ::perception::common::Int& Object_WorldInfo::_internal_cls() const {
  const ::perception::common::Int* p = cls_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Int*>(
      &::perception::common::_Int_default_instance_);
}
inline const ::perception::common::Int& Object_WorldInfo::cls() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.cls)
  return _internal_cls();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_cls(
    ::perception::common::Int* cls) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cls_);
  }
  cls_ = cls;
  if (cls) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.cls)
}
inline ::perception::common::Int* Object_WorldInfo::release_cls() {
  auto temp = unsafe_arena_release_cls();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Int* Object_WorldInfo::unsafe_arena_release_cls() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.cls)
  
  ::perception::common::Int* temp = cls_;
  cls_ = nullptr;
  return temp;
}
inline ::perception::common::Int* Object_WorldInfo::_internal_mutable_cls() {
  
  if (cls_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Int>(GetArena());
    cls_ = p;
  }
  return cls_;
}
inline ::perception::common::Int* Object_WorldInfo::mutable_cls() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.cls)
  return _internal_mutable_cls();
}
inline void Object_WorldInfo::set_allocated_cls(::perception::common::Int* cls) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cls_);
  }
  if (cls) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cls)->GetArena();
    if (message_arena != submessage_arena) {
      cls = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cls, submessage_arena);
    }
    
  } else {
    
  }
  cls_ = cls;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.cls)
}

// float val = 13;
inline void Object_WorldInfo::clear_val() {
  val_ = 0;
}
inline float Object_WorldInfo::_internal_val() const {
  return val_;
}
inline float Object_WorldInfo::val() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.val)
  return _internal_val();
}
inline void Object_WorldInfo::_internal_set_val(float value) {
  
  val_ = value;
}
inline void Object_WorldInfo::set_val(float value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:perception.Object.WorldInfo.val)
}

// .perception.common.Int pose = 14;
inline bool Object_WorldInfo::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool Object_WorldInfo::has_pose() const {
  return _internal_has_pose();
}
inline const ::perception::common::Int& Object_WorldInfo::_internal_pose() const {
  const ::perception::common::Int* p = pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Int*>(
      &::perception::common::_Int_default_instance_);
}
inline const ::perception::common::Int& Object_WorldInfo::pose() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.pose)
  return _internal_pose();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_pose(
    ::perception::common::Int* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.pose)
}
inline ::perception::common::Int* Object_WorldInfo::release_pose() {
  auto temp = unsafe_arena_release_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Int* Object_WorldInfo::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.pose)
  
  ::perception::common::Int* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::perception::common::Int* Object_WorldInfo::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Int>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::perception::common::Int* Object_WorldInfo::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.pose)
  return _internal_mutable_pose();
}
inline void Object_WorldInfo::set_allocated_pose(::perception::common::Int* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose)->GetArena();
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.pose)
}

// float ttc = 15;
inline void Object_WorldInfo::clear_ttc() {
  ttc_ = 0;
}
inline float Object_WorldInfo::_internal_ttc() const {
  return ttc_;
}
inline float Object_WorldInfo::ttc() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.ttc)
  return _internal_ttc();
}
inline void Object_WorldInfo::_internal_set_ttc(float value) {
  
  ttc_ = value;
}
inline void Object_WorldInfo::set_ttc(float value) {
  _internal_set_ttc(value);
  // @@protoc_insertion_point(field_set:perception.Object.WorldInfo.ttc)
}

// float headway = 16;
inline void Object_WorldInfo::clear_headway() {
  headway_ = 0;
}
inline float Object_WorldInfo::_internal_headway() const {
  return headway_;
}
inline float Object_WorldInfo::headway() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.headway)
  return _internal_headway();
}
inline void Object_WorldInfo::_internal_set_headway(float value) {
  
  headway_ = value;
}
inline void Object_WorldInfo::set_headway(float value) {
  _internal_set_headway(value);
  // @@protoc_insertion_point(field_set:perception.Object.WorldInfo.headway)
}

// int32 cipv = 17;
inline void Object_WorldInfo::clear_cipv() {
  cipv_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object_WorldInfo::_internal_cipv() const {
  return cipv_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object_WorldInfo::cipv() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.cipv)
  return _internal_cipv();
}
inline void Object_WorldInfo::_internal_set_cipv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cipv_ = value;
}
inline void Object_WorldInfo::set_cipv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cipv(value);
  // @@protoc_insertion_point(field_set:perception.Object.WorldInfo.cipv)
}

// int32 cipp = 18;
inline void Object_WorldInfo::clear_cipp() {
  cipp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object_WorldInfo::_internal_cipp() const {
  return cipp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object_WorldInfo::cipp() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.cipp)
  return _internal_cipp();
}
inline void Object_WorldInfo::_internal_set_cipp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cipp_ = value;
}
inline void Object_WorldInfo::set_cipp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cipp(value);
  // @@protoc_insertion_point(field_set:perception.Object.WorldInfo.cipp)
}

// .perception.common.PoseAngle pose_angle = 19;
inline bool Object_WorldInfo::_internal_has_pose_angle() const {
  return this != internal_default_instance() && pose_angle_ != nullptr;
}
inline bool Object_WorldInfo::has_pose_angle() const {
  return _internal_has_pose_angle();
}
inline const ::perception::common::PoseAngle& Object_WorldInfo::_internal_pose_angle() const {
  const ::perception::common::PoseAngle* p = pose_angle_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::PoseAngle*>(
      &::perception::common::_PoseAngle_default_instance_);
}
inline const ::perception::common::PoseAngle& Object_WorldInfo::pose_angle() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.pose_angle)
  return _internal_pose_angle();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_pose_angle(
    ::perception::common::PoseAngle* pose_angle) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_angle_);
  }
  pose_angle_ = pose_angle;
  if (pose_angle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.pose_angle)
}
inline ::perception::common::PoseAngle* Object_WorldInfo::release_pose_angle() {
  auto temp = unsafe_arena_release_pose_angle();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::PoseAngle* Object_WorldInfo::unsafe_arena_release_pose_angle() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.pose_angle)
  
  ::perception::common::PoseAngle* temp = pose_angle_;
  pose_angle_ = nullptr;
  return temp;
}
inline ::perception::common::PoseAngle* Object_WorldInfo::_internal_mutable_pose_angle() {
  
  if (pose_angle_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::PoseAngle>(GetArena());
    pose_angle_ = p;
  }
  return pose_angle_;
}
inline ::perception::common::PoseAngle* Object_WorldInfo::mutable_pose_angle() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.pose_angle)
  return _internal_mutable_pose_angle();
}
inline void Object_WorldInfo::set_allocated_pose_angle(::perception::common::PoseAngle* pose_angle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_angle_);
  }
  if (pose_angle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_angle)->GetArena();
    if (message_arena != submessage_arena) {
      pose_angle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose_angle, submessage_arena);
    }
    
  } else {
    
  }
  pose_angle_ = pose_angle;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.pose_angle)
}

// .perception.common.Int motion_state = 20;
inline bool Object_WorldInfo::_internal_has_motion_state() const {
  return this != internal_default_instance() && motion_state_ != nullptr;
}
inline bool Object_WorldInfo::has_motion_state() const {
  return _internal_has_motion_state();
}
inline const ::perception::common::Int& Object_WorldInfo::_internal_motion_state() const {
  const ::perception::common::Int* p = motion_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Int*>(
      &::perception::common::_Int_default_instance_);
}
inline const ::perception::common::Int& Object_WorldInfo::motion_state() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.motion_state)
  return _internal_motion_state();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_motion_state(
    ::perception::common::Int* motion_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_state_);
  }
  motion_state_ = motion_state;
  if (motion_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.motion_state)
}
inline ::perception::common::Int* Object_WorldInfo::release_motion_state() {
  auto temp = unsafe_arena_release_motion_state();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Int* Object_WorldInfo::unsafe_arena_release_motion_state() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.motion_state)
  
  ::perception::common::Int* temp = motion_state_;
  motion_state_ = nullptr;
  return temp;
}
inline ::perception::common::Int* Object_WorldInfo::_internal_mutable_motion_state() {
  
  if (motion_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Int>(GetArena());
    motion_state_ = p;
  }
  return motion_state_;
}
inline ::perception::common::Int* Object_WorldInfo::mutable_motion_state() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.motion_state)
  return _internal_mutable_motion_state();
}
inline void Object_WorldInfo::set_allocated_motion_state(::perception::common::Int* motion_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_state_);
  }
  if (motion_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_state)->GetArena();
    if (message_arena != submessage_arena) {
      motion_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motion_state, submessage_arena);
    }
    
  } else {
    
  }
  motion_state_ = motion_state;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.motion_state)
}

// .perception.Object.AnchorPtInfo anchor = 21;
inline void Object_WorldInfo::clear_anchor() {
  anchor_ = 0;
}
inline ::perception::Object_AnchorPtInfo Object_WorldInfo::_internal_anchor() const {
  return static_cast< ::perception::Object_AnchorPtInfo >(anchor_);
}
inline ::perception::Object_AnchorPtInfo Object_WorldInfo::anchor() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.anchor)
  return _internal_anchor();
}
inline void Object_WorldInfo::_internal_set_anchor(::perception::Object_AnchorPtInfo value) {
  
  anchor_ = value;
}
inline void Object_WorldInfo::set_anchor(::perception::Object_AnchorPtInfo value) {
  _internal_set_anchor(value);
  // @@protoc_insertion_point(field_set:perception.Object.WorldInfo.anchor)
}

// .perception.common.Point3D pos_var = 22;
inline bool Object_WorldInfo::_internal_has_pos_var() const {
  return this != internal_default_instance() && pos_var_ != nullptr;
}
inline bool Object_WorldInfo::has_pos_var() const {
  return _internal_has_pos_var();
}
inline const ::perception::common::Point3D& Object_WorldInfo::_internal_pos_var() const {
  const ::perception::common::Point3D* p = pos_var_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point3D*>(
      &::perception::common::_Point3D_default_instance_);
}
inline const ::perception::common::Point3D& Object_WorldInfo::pos_var() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.pos_var)
  return _internal_pos_var();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_pos_var(
    ::perception::common::Point3D* pos_var) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_var_);
  }
  pos_var_ = pos_var;
  if (pos_var) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.pos_var)
}
inline ::perception::common::Point3D* Object_WorldInfo::release_pos_var() {
  auto temp = unsafe_arena_release_pos_var();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point3D* Object_WorldInfo::unsafe_arena_release_pos_var() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.pos_var)
  
  ::perception::common::Point3D* temp = pos_var_;
  pos_var_ = nullptr;
  return temp;
}
inline ::perception::common::Point3D* Object_WorldInfo::_internal_mutable_pos_var() {
  
  if (pos_var_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point3D>(GetArena());
    pos_var_ = p;
  }
  return pos_var_;
}
inline ::perception::common::Point3D* Object_WorldInfo::mutable_pos_var() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.pos_var)
  return _internal_mutable_pos_var();
}
inline void Object_WorldInfo::set_allocated_pos_var(::perception::common::Point3D* pos_var) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_var_);
  }
  if (pos_var) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_var)->GetArena();
    if (message_arena != submessage_arena) {
      pos_var = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos_var, submessage_arena);
    }
    
  } else {
    
  }
  pos_var_ = pos_var;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.pos_var)
}

// .perception.common.Point3D size_var = 23;
inline bool Object_WorldInfo::_internal_has_size_var() const {
  return this != internal_default_instance() && size_var_ != nullptr;
}
inline bool Object_WorldInfo::has_size_var() const {
  return _internal_has_size_var();
}
inline const ::perception::common::Point3D& Object_WorldInfo::_internal_size_var() const {
  const ::perception::common::Point3D* p = size_var_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point3D*>(
      &::perception::common::_Point3D_default_instance_);
}
inline const ::perception::common::Point3D& Object_WorldInfo::size_var() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.size_var)
  return _internal_size_var();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_size_var(
    ::perception::common::Point3D* size_var) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_var_);
  }
  size_var_ = size_var;
  if (size_var) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.size_var)
}
inline ::perception::common::Point3D* Object_WorldInfo::release_size_var() {
  auto temp = unsafe_arena_release_size_var();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point3D* Object_WorldInfo::unsafe_arena_release_size_var() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.size_var)
  
  ::perception::common::Point3D* temp = size_var_;
  size_var_ = nullptr;
  return temp;
}
inline ::perception::common::Point3D* Object_WorldInfo::_internal_mutable_size_var() {
  
  if (size_var_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point3D>(GetArena());
    size_var_ = p;
  }
  return size_var_;
}
inline ::perception::common::Point3D* Object_WorldInfo::mutable_size_var() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.size_var)
  return _internal_mutable_size_var();
}
inline void Object_WorldInfo::set_allocated_size_var(::perception::common::Point3D* size_var) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_var_);
  }
  if (size_var) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_var)->GetArena();
    if (message_arena != submessage_arena) {
      size_var = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size_var, submessage_arena);
    }
    
  } else {
    
  }
  size_var_ = size_var;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.size_var)
}

// .perception.common.Point3D pose_angle_var = 24;
inline bool Object_WorldInfo::_internal_has_pose_angle_var() const {
  return this != internal_default_instance() && pose_angle_var_ != nullptr;
}
inline bool Object_WorldInfo::has_pose_angle_var() const {
  return _internal_has_pose_angle_var();
}
inline const ::perception::common::Point3D& Object_WorldInfo::_internal_pose_angle_var() const {
  const ::perception::common::Point3D* p = pose_angle_var_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point3D*>(
      &::perception::common::_Point3D_default_instance_);
}
inline const ::perception::common::Point3D& Object_WorldInfo::pose_angle_var() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.pose_angle_var)
  return _internal_pose_angle_var();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_pose_angle_var(
    ::perception::common::Point3D* pose_angle_var) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_angle_var_);
  }
  pose_angle_var_ = pose_angle_var;
  if (pose_angle_var) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.pose_angle_var)
}
inline ::perception::common::Point3D* Object_WorldInfo::release_pose_angle_var() {
  auto temp = unsafe_arena_release_pose_angle_var();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point3D* Object_WorldInfo::unsafe_arena_release_pose_angle_var() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.pose_angle_var)
  
  ::perception::common::Point3D* temp = pose_angle_var_;
  pose_angle_var_ = nullptr;
  return temp;
}
inline ::perception::common::Point3D* Object_WorldInfo::_internal_mutable_pose_angle_var() {
  
  if (pose_angle_var_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point3D>(GetArena());
    pose_angle_var_ = p;
  }
  return pose_angle_var_;
}
inline ::perception::common::Point3D* Object_WorldInfo::mutable_pose_angle_var() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.pose_angle_var)
  return _internal_mutable_pose_angle_var();
}
inline void Object_WorldInfo::set_allocated_pose_angle_var(::perception::common::Point3D* pose_angle_var) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_angle_var_);
  }
  if (pose_angle_var) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_angle_var)->GetArena();
    if (message_arena != submessage_arena) {
      pose_angle_var = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose_angle_var, submessage_arena);
    }
    
  } else {
    
  }
  pose_angle_var_ = pose_angle_var;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.pose_angle_var)
}

// .perception.common.XYZ anchor_offset = 25;
inline bool Object_WorldInfo::_internal_has_anchor_offset() const {
  return this != internal_default_instance() && anchor_offset_ != nullptr;
}
inline bool Object_WorldInfo::has_anchor_offset() const {
  return _internal_has_anchor_offset();
}
inline const ::perception::common::XYZ& Object_WorldInfo::_internal_anchor_offset() const {
  const ::perception::common::XYZ* p = anchor_offset_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::XYZ*>(
      &::perception::common::_XYZ_default_instance_);
}
inline const ::perception::common::XYZ& Object_WorldInfo::anchor_offset() const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.anchor_offset)
  return _internal_anchor_offset();
}
inline void Object_WorldInfo::unsafe_arena_set_allocated_anchor_offset(
    ::perception::common::XYZ* anchor_offset) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(anchor_offset_);
  }
  anchor_offset_ = anchor_offset;
  if (anchor_offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.WorldInfo.anchor_offset)
}
inline ::perception::common::XYZ* Object_WorldInfo::release_anchor_offset() {
  auto temp = unsafe_arena_release_anchor_offset();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::XYZ* Object_WorldInfo::unsafe_arena_release_anchor_offset() {
  // @@protoc_insertion_point(field_release:perception.Object.WorldInfo.anchor_offset)
  
  ::perception::common::XYZ* temp = anchor_offset_;
  anchor_offset_ = nullptr;
  return temp;
}
inline ::perception::common::XYZ* Object_WorldInfo::_internal_mutable_anchor_offset() {
  
  if (anchor_offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::XYZ>(GetArena());
    anchor_offset_ = p;
  }
  return anchor_offset_;
}
inline ::perception::common::XYZ* Object_WorldInfo::mutable_anchor_offset() {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.anchor_offset)
  return _internal_mutable_anchor_offset();
}
inline void Object_WorldInfo::set_allocated_anchor_offset(::perception::common::XYZ* anchor_offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(anchor_offset_);
  }
  if (anchor_offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(anchor_offset)->GetArena();
    if (message_arena != submessage_arena) {
      anchor_offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anchor_offset, submessage_arena);
    }
    
  } else {
    
  }
  anchor_offset_ = anchor_offset;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.WorldInfo.anchor_offset)
}

// repeated .perception.common.XY odom_trace = 26;
inline int Object_WorldInfo::_internal_odom_trace_size() const {
  return odom_trace_.size();
}
inline int Object_WorldInfo::odom_trace_size() const {
  return _internal_odom_trace_size();
}
inline ::perception::common::XY* Object_WorldInfo::mutable_odom_trace(int index) {
  // @@protoc_insertion_point(field_mutable:perception.Object.WorldInfo.odom_trace)
  return odom_trace_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::XY >*
Object_WorldInfo::mutable_odom_trace() {
  // @@protoc_insertion_point(field_mutable_list:perception.Object.WorldInfo.odom_trace)
  return &odom_trace_;
}
inline const ::perception::common::XY& Object_WorldInfo::_internal_odom_trace(int index) const {
  return odom_trace_.Get(index);
}
inline const ::perception::common::XY& Object_WorldInfo::odom_trace(int index) const {
  // @@protoc_insertion_point(field_get:perception.Object.WorldInfo.odom_trace)
  return _internal_odom_trace(index);
}
inline ::perception::common::XY* Object_WorldInfo::_internal_add_odom_trace() {
  return odom_trace_.Add();
}
inline ::perception::common::XY* Object_WorldInfo::add_odom_trace() {
  // @@protoc_insertion_point(field_add:perception.Object.WorldInfo.odom_trace)
  return _internal_add_odom_trace();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::XY >&
Object_WorldInfo::odom_trace() const {
  // @@protoc_insertion_point(field_list:perception.Object.WorldInfo.odom_trace)
  return odom_trace_;
}

// -------------------------------------------------------------------

// Object_FusionInfo

// repeated .perception.Object.ImageInfo associated_image_infos = 1;
inline int Object_FusionInfo::_internal_associated_image_infos_size() const {
  return associated_image_infos_.size();
}
inline int Object_FusionInfo::associated_image_infos_size() const {
  return _internal_associated_image_infos_size();
}
inline void Object_FusionInfo::clear_associated_image_infos() {
  associated_image_infos_.Clear();
}
inline ::perception::Object_ImageInfo* Object_FusionInfo::mutable_associated_image_infos(int index) {
  // @@protoc_insertion_point(field_mutable:perception.Object.FusionInfo.associated_image_infos)
  return associated_image_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object_ImageInfo >*
Object_FusionInfo::mutable_associated_image_infos() {
  // @@protoc_insertion_point(field_mutable_list:perception.Object.FusionInfo.associated_image_infos)
  return &associated_image_infos_;
}
inline const ::perception::Object_ImageInfo& Object_FusionInfo::_internal_associated_image_infos(int index) const {
  return associated_image_infos_.Get(index);
}
inline const ::perception::Object_ImageInfo& Object_FusionInfo::associated_image_infos(int index) const {
  // @@protoc_insertion_point(field_get:perception.Object.FusionInfo.associated_image_infos)
  return _internal_associated_image_infos(index);
}
inline ::perception::Object_ImageInfo* Object_FusionInfo::_internal_add_associated_image_infos() {
  return associated_image_infos_.Add();
}
inline ::perception::Object_ImageInfo* Object_FusionInfo::add_associated_image_infos() {
  // @@protoc_insertion_point(field_add:perception.Object.FusionInfo.associated_image_infos)
  return _internal_add_associated_image_infos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object_ImageInfo >&
Object_FusionInfo::associated_image_infos() const {
  // @@protoc_insertion_point(field_list:perception.Object.FusionInfo.associated_image_infos)
  return associated_image_infos_;
}

// repeated .perception.Object.WorldInfo associated_world_infos = 2;
inline int Object_FusionInfo::_internal_associated_world_infos_size() const {
  return associated_world_infos_.size();
}
inline int Object_FusionInfo::associated_world_infos_size() const {
  return _internal_associated_world_infos_size();
}
inline void Object_FusionInfo::clear_associated_world_infos() {
  associated_world_infos_.Clear();
}
inline ::perception::Object_WorldInfo* Object_FusionInfo::mutable_associated_world_infos(int index) {
  // @@protoc_insertion_point(field_mutable:perception.Object.FusionInfo.associated_world_infos)
  return associated_world_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object_WorldInfo >*
Object_FusionInfo::mutable_associated_world_infos() {
  // @@protoc_insertion_point(field_mutable_list:perception.Object.FusionInfo.associated_world_infos)
  return &associated_world_infos_;
}
inline const ::perception::Object_WorldInfo& Object_FusionInfo::_internal_associated_world_infos(int index) const {
  return associated_world_infos_.Get(index);
}
inline const ::perception::Object_WorldInfo& Object_FusionInfo::associated_world_infos(int index) const {
  // @@protoc_insertion_point(field_get:perception.Object.FusionInfo.associated_world_infos)
  return _internal_associated_world_infos(index);
}
inline ::perception::Object_WorldInfo* Object_FusionInfo::_internal_add_associated_world_infos() {
  return associated_world_infos_.Add();
}
inline ::perception::Object_WorldInfo* Object_FusionInfo::add_associated_world_infos() {
  // @@protoc_insertion_point(field_add:perception.Object.FusionInfo.associated_world_infos)
  return _internal_add_associated_world_infos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object_WorldInfo >&
Object_FusionInfo::associated_world_infos() const {
  // @@protoc_insertion_point(field_list:perception.Object.FusionInfo.associated_world_infos)
  return associated_world_infos_;
}

// repeated float associated_conf_matrix = 3;
inline int Object_FusionInfo::_internal_associated_conf_matrix_size() const {
  return associated_conf_matrix_.size();
}
inline int Object_FusionInfo::associated_conf_matrix_size() const {
  return _internal_associated_conf_matrix_size();
}
inline void Object_FusionInfo::clear_associated_conf_matrix() {
  associated_conf_matrix_.Clear();
}
inline float Object_FusionInfo::_internal_associated_conf_matrix(int index) const {
  return associated_conf_matrix_.Get(index);
}
inline float Object_FusionInfo::associated_conf_matrix(int index) const {
  // @@protoc_insertion_point(field_get:perception.Object.FusionInfo.associated_conf_matrix)
  return _internal_associated_conf_matrix(index);
}
inline void Object_FusionInfo::set_associated_conf_matrix(int index, float value) {
  associated_conf_matrix_.Set(index, value);
  // @@protoc_insertion_point(field_set:perception.Object.FusionInfo.associated_conf_matrix)
}
inline void Object_FusionInfo::_internal_add_associated_conf_matrix(float value) {
  associated_conf_matrix_.Add(value);
}
inline void Object_FusionInfo::add_associated_conf_matrix(float value) {
  _internal_add_associated_conf_matrix(value);
  // @@protoc_insertion_point(field_add:perception.Object.FusionInfo.associated_conf_matrix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Object_FusionInfo::_internal_associated_conf_matrix() const {
  return associated_conf_matrix_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Object_FusionInfo::associated_conf_matrix() const {
  // @@protoc_insertion_point(field_list:perception.Object.FusionInfo.associated_conf_matrix)
  return _internal_associated_conf_matrix();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Object_FusionInfo::_internal_mutable_associated_conf_matrix() {
  return &associated_conf_matrix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Object_FusionInfo::mutable_associated_conf_matrix() {
  // @@protoc_insertion_point(field_mutable_list:perception.Object.FusionInfo.associated_conf_matrix)
  return _internal_mutable_associated_conf_matrix();
}

// .perception.Object.WorldInfo fusion_world_info = 4;
inline bool Object_FusionInfo::_internal_has_fusion_world_info() const {
  return this != internal_default_instance() && fusion_world_info_ != nullptr;
}
inline bool Object_FusionInfo::has_fusion_world_info() const {
  return _internal_has_fusion_world_info();
}
inline void Object_FusionInfo::clear_fusion_world_info() {
  if (GetArena() == nullptr && fusion_world_info_ != nullptr) {
    delete fusion_world_info_;
  }
  fusion_world_info_ = nullptr;
}
inline const ::perception::Object_WorldInfo& Object_FusionInfo::_internal_fusion_world_info() const {
  const ::perception::Object_WorldInfo* p = fusion_world_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::Object_WorldInfo*>(
      &::perception::_Object_WorldInfo_default_instance_);
}
inline const ::perception::Object_WorldInfo& Object_FusionInfo::fusion_world_info() const {
  // @@protoc_insertion_point(field_get:perception.Object.FusionInfo.fusion_world_info)
  return _internal_fusion_world_info();
}
inline void Object_FusionInfo::unsafe_arena_set_allocated_fusion_world_info(
    ::perception::Object_WorldInfo* fusion_world_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fusion_world_info_);
  }
  fusion_world_info_ = fusion_world_info;
  if (fusion_world_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.FusionInfo.fusion_world_info)
}
inline ::perception::Object_WorldInfo* Object_FusionInfo::release_fusion_world_info() {
  auto temp = unsafe_arena_release_fusion_world_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::Object_WorldInfo* Object_FusionInfo::unsafe_arena_release_fusion_world_info() {
  // @@protoc_insertion_point(field_release:perception.Object.FusionInfo.fusion_world_info)
  
  ::perception::Object_WorldInfo* temp = fusion_world_info_;
  fusion_world_info_ = nullptr;
  return temp;
}
inline ::perception::Object_WorldInfo* Object_FusionInfo::_internal_mutable_fusion_world_info() {
  
  if (fusion_world_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::Object_WorldInfo>(GetArena());
    fusion_world_info_ = p;
  }
  return fusion_world_info_;
}
inline ::perception::Object_WorldInfo* Object_FusionInfo::mutable_fusion_world_info() {
  // @@protoc_insertion_point(field_mutable:perception.Object.FusionInfo.fusion_world_info)
  return _internal_mutable_fusion_world_info();
}
inline void Object_FusionInfo::set_allocated_fusion_world_info(::perception::Object_WorldInfo* fusion_world_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fusion_world_info_;
  }
  if (fusion_world_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fusion_world_info);
    if (message_arena != submessage_arena) {
      fusion_world_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fusion_world_info, submessage_arena);
    }
    
  } else {
    
  }
  fusion_world_info_ = fusion_world_info;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.FusionInfo.fusion_world_info)
}

// -------------------------------------------------------------------

// Object

// int32 hit_id = 1;
inline void Object::clear_hit_id() {
  hit_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::_internal_hit_id() const {
  return hit_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::hit_id() const {
  // @@protoc_insertion_point(field_get:perception.Object.hit_id)
  return _internal_hit_id();
}
inline void Object::_internal_set_hit_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hit_id_ = value;
}
inline void Object::set_hit_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hit_id(value);
  // @@protoc_insertion_point(field_set:perception.Object.hit_id)
}

// .perception.Object.ObjectType hit_type = 2;
inline void Object::clear_hit_type() {
  hit_type_ = 0;
}
inline ::perception::Object_ObjectType Object::_internal_hit_type() const {
  return static_cast< ::perception::Object_ObjectType >(hit_type_);
}
inline ::perception::Object_ObjectType Object::hit_type() const {
  // @@protoc_insertion_point(field_get:perception.Object.hit_type)
  return _internal_hit_type();
}
inline void Object::_internal_set_hit_type(::perception::Object_ObjectType value) {
  
  hit_type_ = value;
}
inline void Object::set_hit_type(::perception::Object_ObjectType value) {
  _internal_set_hit_type(value);
  // @@protoc_insertion_point(field_set:perception.Object.hit_type)
}

// string hit_type_str = 6;
inline void Object::clear_hit_type_str() {
  hit_type_str_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Object::hit_type_str() const {
  // @@protoc_insertion_point(field_get:perception.Object.hit_type_str)
  return _internal_hit_type_str();
}
inline void Object::set_hit_type_str(const std::string& value) {
  _internal_set_hit_type_str(value);
  // @@protoc_insertion_point(field_set:perception.Object.hit_type_str)
}
inline std::string* Object::mutable_hit_type_str() {
  // @@protoc_insertion_point(field_mutable:perception.Object.hit_type_str)
  return _internal_mutable_hit_type_str();
}
inline const std::string& Object::_internal_hit_type_str() const {
  return hit_type_str_.Get();
}
inline void Object::_internal_set_hit_type_str(const std::string& value) {
  
  hit_type_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Object::set_hit_type_str(std::string&& value) {
  
  hit_type_str_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:perception.Object.hit_type_str)
}
inline void Object::set_hit_type_str(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hit_type_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:perception.Object.hit_type_str)
}
inline void Object::set_hit_type_str(const char* value,
    size_t size) {
  
  hit_type_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:perception.Object.hit_type_str)
}
inline std::string* Object::_internal_mutable_hit_type_str() {
  
  return hit_type_str_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Object::release_hit_type_str() {
  // @@protoc_insertion_point(field_release:perception.Object.hit_type_str)
  return hit_type_str_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Object::set_allocated_hit_type_str(std::string* hit_type_str) {
  if (hit_type_str != nullptr) {
    
  } else {
    
  }
  hit_type_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hit_type_str,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:perception.Object.hit_type_str)
}
inline std::string* Object::unsafe_arena_release_hit_type_str() {
  // @@protoc_insertion_point(field_unsafe_arena_release:perception.Object.hit_type_str)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return hit_type_str_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Object::unsafe_arena_set_allocated_hit_type_str(
    std::string* hit_type_str) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (hit_type_str != nullptr) {
    
  } else {
    
  }
  hit_type_str_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      hit_type_str, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.hit_type_str)
}

// float confidence = 3;
inline void Object::clear_confidence() {
  confidence_ = 0;
}
inline float Object::_internal_confidence() const {
  return confidence_;
}
inline float Object::confidence() const {
  // @@protoc_insertion_point(field_get:perception.Object.confidence)
  return _internal_confidence();
}
inline void Object::_internal_set_confidence(float value) {
  
  confidence_ = value;
}
inline void Object::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:perception.Object.confidence)
}

// int32 frame_cnt = 4;
inline void Object::clear_frame_cnt() {
  frame_cnt_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::_internal_frame_cnt() const {
  return frame_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::frame_cnt() const {
  // @@protoc_insertion_point(field_get:perception.Object.frame_cnt)
  return _internal_frame_cnt();
}
inline void Object::_internal_set_frame_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  frame_cnt_ = value;
}
inline void Object::set_frame_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_frame_cnt(value);
  // @@protoc_insertion_point(field_set:perception.Object.frame_cnt)
}

// int32 life_time = 5;
inline void Object::clear_life_time() {
  life_time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::_internal_life_time() const {
  return life_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::life_time() const {
  // @@protoc_insertion_point(field_get:perception.Object.life_time)
  return _internal_life_time();
}
inline void Object::_internal_set_life_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  life_time_ = value;
}
inline void Object::set_life_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_life_time(value);
  // @@protoc_insertion_point(field_set:perception.Object.life_time)
}

// uint64 time_creation = 7;
inline void Object::clear_time_creation() {
  time_creation_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Object::_internal_time_creation() const {
  return time_creation_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Object::time_creation() const {
  // @@protoc_insertion_point(field_get:perception.Object.time_creation)
  return _internal_time_creation();
}
inline void Object::_internal_set_time_creation(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  time_creation_ = value;
}
inline void Object::set_time_creation(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_time_creation(value);
  // @@protoc_insertion_point(field_set:perception.Object.time_creation)
}

// .perception.Object.ImageInfo image_info = 8;
inline bool Object::_internal_has_image_info() const {
  return this != internal_default_instance() && image_info_ != nullptr;
}
inline bool Object::has_image_info() const {
  return _internal_has_image_info();
}
inline void Object::clear_image_info() {
  if (GetArena() == nullptr && image_info_ != nullptr) {
    delete image_info_;
  }
  image_info_ = nullptr;
}
inline const ::perception::Object_ImageInfo& Object::_internal_image_info() const {
  const ::perception::Object_ImageInfo* p = image_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::Object_ImageInfo*>(
      &::perception::_Object_ImageInfo_default_instance_);
}
inline const ::perception::Object_ImageInfo& Object::image_info() const {
  // @@protoc_insertion_point(field_get:perception.Object.image_info)
  return _internal_image_info();
}
inline void Object::unsafe_arena_set_allocated_image_info(
    ::perception::Object_ImageInfo* image_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_info_);
  }
  image_info_ = image_info;
  if (image_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.image_info)
}
inline ::perception::Object_ImageInfo* Object::release_image_info() {
  auto temp = unsafe_arena_release_image_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::Object_ImageInfo* Object::unsafe_arena_release_image_info() {
  // @@protoc_insertion_point(field_release:perception.Object.image_info)
  
  ::perception::Object_ImageInfo* temp = image_info_;
  image_info_ = nullptr;
  return temp;
}
inline ::perception::Object_ImageInfo* Object::_internal_mutable_image_info() {
  
  if (image_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::Object_ImageInfo>(GetArena());
    image_info_ = p;
  }
  return image_info_;
}
inline ::perception::Object_ImageInfo* Object::mutable_image_info() {
  // @@protoc_insertion_point(field_mutable:perception.Object.image_info)
  return _internal_mutable_image_info();
}
inline void Object::set_allocated_image_info(::perception::Object_ImageInfo* image_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete image_info_;
  }
  if (image_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(image_info);
    if (message_arena != submessage_arena) {
      image_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_info, submessage_arena);
    }
    
  } else {
    
  }
  image_info_ = image_info;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.image_info)
}

// .perception.Object.WorldInfo world_info = 9;
inline bool Object::_internal_has_world_info() const {
  return this != internal_default_instance() && world_info_ != nullptr;
}
inline bool Object::has_world_info() const {
  return _internal_has_world_info();
}
inline void Object::clear_world_info() {
  if (GetArena() == nullptr && world_info_ != nullptr) {
    delete world_info_;
  }
  world_info_ = nullptr;
}
inline const ::perception::Object_WorldInfo& Object::_internal_world_info() const {
  const ::perception::Object_WorldInfo* p = world_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::Object_WorldInfo*>(
      &::perception::_Object_WorldInfo_default_instance_);
}
inline const ::perception::Object_WorldInfo& Object::world_info() const {
  // @@protoc_insertion_point(field_get:perception.Object.world_info)
  return _internal_world_info();
}
inline void Object::unsafe_arena_set_allocated_world_info(
    ::perception::Object_WorldInfo* world_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_info_);
  }
  world_info_ = world_info;
  if (world_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.world_info)
}
inline ::perception::Object_WorldInfo* Object::release_world_info() {
  auto temp = unsafe_arena_release_world_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::Object_WorldInfo* Object::unsafe_arena_release_world_info() {
  // @@protoc_insertion_point(field_release:perception.Object.world_info)
  
  ::perception::Object_WorldInfo* temp = world_info_;
  world_info_ = nullptr;
  return temp;
}
inline ::perception::Object_WorldInfo* Object::_internal_mutable_world_info() {
  
  if (world_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::Object_WorldInfo>(GetArena());
    world_info_ = p;
  }
  return world_info_;
}
inline ::perception::Object_WorldInfo* Object::mutable_world_info() {
  // @@protoc_insertion_point(field_mutable:perception.Object.world_info)
  return _internal_mutable_world_info();
}
inline void Object::set_allocated_world_info(::perception::Object_WorldInfo* world_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete world_info_;
  }
  if (world_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(world_info);
    if (message_arena != submessage_arena) {
      world_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_info, submessage_arena);
    }
    
  } else {
    
  }
  world_info_ = world_info;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.world_info)
}

// int32 track_status = 10;
inline void Object::clear_track_status() {
  track_status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::_internal_track_status() const {
  return track_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::track_status() const {
  // @@protoc_insertion_point(field_get:perception.Object.track_status)
  return _internal_track_status();
}
inline void Object::_internal_set_track_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  track_status_ = value;
}
inline void Object::set_track_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_track_status(value);
  // @@protoc_insertion_point(field_set:perception.Object.track_status)
}

// int32 trace_status = 11;
inline void Object::clear_trace_status() {
  trace_status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::_internal_trace_status() const {
  return trace_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::trace_status() const {
  // @@protoc_insertion_point(field_get:perception.Object.trace_status)
  return _internal_trace_status();
}
inline void Object::_internal_set_trace_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trace_status_ = value;
}
inline void Object::set_trace_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trace_status(value);
  // @@protoc_insertion_point(field_set:perception.Object.trace_status)
}

// int32 select_level = 12;
inline void Object::clear_select_level() {
  select_level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::_internal_select_level() const {
  return select_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Object::select_level() const {
  // @@protoc_insertion_point(field_get:perception.Object.select_level)
  return _internal_select_level();
}
inline void Object::_internal_set_select_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  select_level_ = value;
}
inline void Object::set_select_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_select_level(value);
  // @@protoc_insertion_point(field_set:perception.Object.select_level)
}

// uint32 id = 15;
inline void Object::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Object::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Object::id() const {
  // @@protoc_insertion_point(field_get:perception.Object.id)
  return _internal_id();
}
inline void Object::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void Object::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:perception.Object.id)
}

// .perception.Object.FusionInfo fusion_info = 16;
inline bool Object::_internal_has_fusion_info() const {
  return this != internal_default_instance() && fusion_info_ != nullptr;
}
inline bool Object::has_fusion_info() const {
  return _internal_has_fusion_info();
}
inline void Object::clear_fusion_info() {
  if (GetArena() == nullptr && fusion_info_ != nullptr) {
    delete fusion_info_;
  }
  fusion_info_ = nullptr;
}
inline const ::perception::Object_FusionInfo& Object::_internal_fusion_info() const {
  const ::perception::Object_FusionInfo* p = fusion_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::Object_FusionInfo*>(
      &::perception::_Object_FusionInfo_default_instance_);
}
inline const ::perception::Object_FusionInfo& Object::fusion_info() const {
  // @@protoc_insertion_point(field_get:perception.Object.fusion_info)
  return _internal_fusion_info();
}
inline void Object::unsafe_arena_set_allocated_fusion_info(
    ::perception::Object_FusionInfo* fusion_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fusion_info_);
  }
  fusion_info_ = fusion_info;
  if (fusion_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.fusion_info)
}
inline ::perception::Object_FusionInfo* Object::release_fusion_info() {
  auto temp = unsafe_arena_release_fusion_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::Object_FusionInfo* Object::unsafe_arena_release_fusion_info() {
  // @@protoc_insertion_point(field_release:perception.Object.fusion_info)
  
  ::perception::Object_FusionInfo* temp = fusion_info_;
  fusion_info_ = nullptr;
  return temp;
}
inline ::perception::Object_FusionInfo* Object::_internal_mutable_fusion_info() {
  
  if (fusion_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::Object_FusionInfo>(GetArena());
    fusion_info_ = p;
  }
  return fusion_info_;
}
inline ::perception::Object_FusionInfo* Object::mutable_fusion_info() {
  // @@protoc_insertion_point(field_mutable:perception.Object.fusion_info)
  return _internal_mutable_fusion_info();
}
inline void Object::set_allocated_fusion_info(::perception::Object_FusionInfo* fusion_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fusion_info_;
  }
  if (fusion_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fusion_info);
    if (message_arena != submessage_arena) {
      fusion_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fusion_info, submessage_arena);
    }
    
  } else {
    
  }
  fusion_info_ = fusion_info;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.fusion_info)
}

// .perception.Object.MeasureType measure_type = 17;
inline void Object::clear_measure_type() {
  measure_type_ = 0;
}
inline ::perception::Object_MeasureType Object::_internal_measure_type() const {
  return static_cast< ::perception::Object_MeasureType >(measure_type_);
}
inline ::perception::Object_MeasureType Object::measure_type() const {
  // @@protoc_insertion_point(field_get:perception.Object.measure_type)
  return _internal_measure_type();
}
inline void Object::_internal_set_measure_type(::perception::Object_MeasureType value) {
  
  measure_type_ = value;
}
inline void Object::set_measure_type(::perception::Object_MeasureType value) {
  _internal_set_measure_type(value);
  // @@protoc_insertion_point(field_set:perception.Object.measure_type)
}

// uint64 timestamp = 18;
inline void Object::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Object::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Object::timestamp() const {
  // @@protoc_insertion_point(field_get:perception.Object.timestamp)
  return _internal_timestamp();
}
inline void Object::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void Object::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:perception.Object.timestamp)
}

// uint64 frame_id = 19;
inline void Object::clear_frame_id() {
  frame_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Object::_internal_frame_id() const {
  return frame_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Object::frame_id() const {
  // @@protoc_insertion_point(field_get:perception.Object.frame_id)
  return _internal_frame_id();
}
inline void Object::_internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  frame_id_ = value;
}
inline void Object::set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:perception.Object.frame_id)
}

// .perception.common.Int lane_assignment = 21;
inline bool Object::_internal_has_lane_assignment() const {
  return this != internal_default_instance() && lane_assignment_ != nullptr;
}
inline bool Object::has_lane_assignment() const {
  return _internal_has_lane_assignment();
}
inline const ::perception::common::Int& Object::_internal_lane_assignment() const {
  const ::perception::common::Int* p = lane_assignment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Int*>(
      &::perception::common::_Int_default_instance_);
}
inline const ::perception::common::Int& Object::lane_assignment() const {
  // @@protoc_insertion_point(field_get:perception.Object.lane_assignment)
  return _internal_lane_assignment();
}
inline void Object::unsafe_arena_set_allocated_lane_assignment(
    ::perception::common::Int* lane_assignment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lane_assignment_);
  }
  lane_assignment_ = lane_assignment;
  if (lane_assignment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.lane_assignment)
}
inline ::perception::common::Int* Object::release_lane_assignment() {
  auto temp = unsafe_arena_release_lane_assignment();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Int* Object::unsafe_arena_release_lane_assignment() {
  // @@protoc_insertion_point(field_release:perception.Object.lane_assignment)
  
  ::perception::common::Int* temp = lane_assignment_;
  lane_assignment_ = nullptr;
  return temp;
}
inline ::perception::common::Int* Object::_internal_mutable_lane_assignment() {
  
  if (lane_assignment_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Int>(GetArena());
    lane_assignment_ = p;
  }
  return lane_assignment_;
}
inline ::perception::common::Int* Object::mutable_lane_assignment() {
  // @@protoc_insertion_point(field_mutable:perception.Object.lane_assignment)
  return _internal_mutable_lane_assignment();
}
inline void Object::set_allocated_lane_assignment(::perception::common::Int* lane_assignment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lane_assignment_);
  }
  if (lane_assignment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lane_assignment)->GetArena();
    if (message_arena != submessage_arena) {
      lane_assignment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lane_assignment, submessage_arena);
    }
    
  } else {
    
  }
  lane_assignment_ = lane_assignment;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.lane_assignment)
}

// .perception.common.Float has_cut_lane = 22;
inline bool Object::_internal_has_has_cut_lane() const {
  return this != internal_default_instance() && has_cut_lane_ != nullptr;
}
inline bool Object::has_has_cut_lane() const {
  return _internal_has_has_cut_lane();
}
inline const ::perception::common::Float& Object::_internal_has_cut_lane() const {
  const ::perception::common::Float* p = has_cut_lane_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Float*>(
      &::perception::common::_Float_default_instance_);
}
inline const ::perception::common::Float& Object::has_cut_lane() const {
  // @@protoc_insertion_point(field_get:perception.Object.has_cut_lane)
  return _internal_has_cut_lane();
}
inline void Object::unsafe_arena_set_allocated_has_cut_lane(
    ::perception::common::Float* has_cut_lane) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(has_cut_lane_);
  }
  has_cut_lane_ = has_cut_lane;
  if (has_cut_lane) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.has_cut_lane)
}
inline ::perception::common::Float* Object::release_has_cut_lane() {
  auto temp = unsafe_arena_release_has_cut_lane();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Float* Object::unsafe_arena_release_has_cut_lane() {
  // @@protoc_insertion_point(field_release:perception.Object.has_cut_lane)
  
  ::perception::common::Float* temp = has_cut_lane_;
  has_cut_lane_ = nullptr;
  return temp;
}
inline ::perception::common::Float* Object::_internal_mutable_has_cut_lane() {
  
  if (has_cut_lane_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Float>(GetArena());
    has_cut_lane_ = p;
  }
  return has_cut_lane_;
}
inline ::perception::common::Float* Object::mutable_has_cut_lane() {
  // @@protoc_insertion_point(field_mutable:perception.Object.has_cut_lane)
  return _internal_mutable_has_cut_lane();
}
inline void Object::set_allocated_has_cut_lane(::perception::common::Float* has_cut_lane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(has_cut_lane_);
  }
  if (has_cut_lane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(has_cut_lane)->GetArena();
    if (message_arena != submessage_arena) {
      has_cut_lane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, has_cut_lane, submessage_arena);
    }
    
  } else {
    
  }
  has_cut_lane_ = has_cut_lane;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.has_cut_lane)
}

// .perception.Object.VehicleRigid veh_rigid = 23;
inline bool Object::_internal_has_veh_rigid() const {
  return this != internal_default_instance() && veh_rigid_ != nullptr;
}
inline bool Object::has_veh_rigid() const {
  return _internal_has_veh_rigid();
}
inline void Object::clear_veh_rigid() {
  if (GetArena() == nullptr && veh_rigid_ != nullptr) {
    delete veh_rigid_;
  }
  veh_rigid_ = nullptr;
}
inline const ::perception::Object_VehicleRigid& Object::_internal_veh_rigid() const {
  const ::perception::Object_VehicleRigid* p = veh_rigid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::Object_VehicleRigid*>(
      &::perception::_Object_VehicleRigid_default_instance_);
}
inline const ::perception::Object_VehicleRigid& Object::veh_rigid() const {
  // @@protoc_insertion_point(field_get:perception.Object.veh_rigid)
  return _internal_veh_rigid();
}
inline void Object::unsafe_arena_set_allocated_veh_rigid(
    ::perception::Object_VehicleRigid* veh_rigid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(veh_rigid_);
  }
  veh_rigid_ = veh_rigid;
  if (veh_rigid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.veh_rigid)
}
inline ::perception::Object_VehicleRigid* Object::release_veh_rigid() {
  auto temp = unsafe_arena_release_veh_rigid();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::Object_VehicleRigid* Object::unsafe_arena_release_veh_rigid() {
  // @@protoc_insertion_point(field_release:perception.Object.veh_rigid)
  
  ::perception::Object_VehicleRigid* temp = veh_rigid_;
  veh_rigid_ = nullptr;
  return temp;
}
inline ::perception::Object_VehicleRigid* Object::_internal_mutable_veh_rigid() {
  
  if (veh_rigid_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::Object_VehicleRigid>(GetArena());
    veh_rigid_ = p;
  }
  return veh_rigid_;
}
inline ::perception::Object_VehicleRigid* Object::mutable_veh_rigid() {
  // @@protoc_insertion_point(field_mutable:perception.Object.veh_rigid)
  return _internal_mutable_veh_rigid();
}
inline void Object::set_allocated_veh_rigid(::perception::Object_VehicleRigid* veh_rigid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete veh_rigid_;
  }
  if (veh_rigid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(veh_rigid);
    if (message_arena != submessage_arena) {
      veh_rigid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, veh_rigid, submessage_arena);
    }
    
  } else {
    
  }
  veh_rigid_ = veh_rigid;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.veh_rigid)
}

// .perception.common.FloatArray features = 24;
inline bool Object::_internal_has_features() const {
  return this != internal_default_instance() && features_ != nullptr;
}
inline bool Object::has_features() const {
  return _internal_has_features();
}
inline const ::perception::common::FloatArray& Object::_internal_features() const {
  const ::perception::common::FloatArray* p = features_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::FloatArray*>(
      &::perception::common::_FloatArray_default_instance_);
}
inline const ::perception::common::FloatArray& Object::features() const {
  // @@protoc_insertion_point(field_get:perception.Object.features)
  return _internal_features();
}
inline void Object::unsafe_arena_set_allocated_features(
    ::perception::common::FloatArray* features) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(features_);
  }
  features_ = features;
  if (features) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.Object.features)
}
inline ::perception::common::FloatArray* Object::release_features() {
  auto temp = unsafe_arena_release_features();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::FloatArray* Object::unsafe_arena_release_features() {
  // @@protoc_insertion_point(field_release:perception.Object.features)
  
  ::perception::common::FloatArray* temp = features_;
  features_ = nullptr;
  return temp;
}
inline ::perception::common::FloatArray* Object::_internal_mutable_features() {
  
  if (features_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::FloatArray>(GetArena());
    features_ = p;
  }
  return features_;
}
inline ::perception::common::FloatArray* Object::mutable_features() {
  // @@protoc_insertion_point(field_mutable:perception.Object.features)
  return _internal_mutable_features();
}
inline void Object::set_allocated_features(::perception::common::FloatArray* features) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(features_);
  }
  if (features) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(features)->GetArena();
    if (message_arena != submessage_arena) {
      features = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, features, submessage_arena);
    }
    
  } else {
    
  }
  features_ = features;
  // @@protoc_insertion_point(field_set_allocated:perception.Object.features)
}

// repeated .perception.Object key_components = 60;
inline int Object::_internal_key_components_size() const {
  return key_components_.size();
}
inline int Object::key_components_size() const {
  return _internal_key_components_size();
}
inline void Object::clear_key_components() {
  key_components_.Clear();
}
inline ::perception::Object* Object::mutable_key_components(int index) {
  // @@protoc_insertion_point(field_mutable:perception.Object.key_components)
  return key_components_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object >*
Object::mutable_key_components() {
  // @@protoc_insertion_point(field_mutable_list:perception.Object.key_components)
  return &key_components_;
}
inline const ::perception::Object& Object::_internal_key_components(int index) const {
  return key_components_.Get(index);
}
inline const ::perception::Object& Object::key_components(int index) const {
  // @@protoc_insertion_point(field_get:perception.Object.key_components)
  return _internal_key_components(index);
}
inline ::perception::Object* Object::_internal_add_key_components() {
  return key_components_.Add();
}
inline ::perception::Object* Object::add_key_components() {
  // @@protoc_insertion_point(field_add:perception.Object.key_components)
  return _internal_add_key_components();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object >&
Object::key_components() const {
  // @@protoc_insertion_point(field_list:perception.Object.key_components)
  return key_components_;
}

// -------------------------------------------------------------------

// ObjectList

// repeated .perception.Object list = 1;
inline int ObjectList::_internal_list_size() const {
  return list_.size();
}
inline int ObjectList::list_size() const {
  return _internal_list_size();
}
inline void ObjectList::clear_list() {
  list_.Clear();
}
inline ::perception::Object* ObjectList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:perception.ObjectList.list)
  return list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object >*
ObjectList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:perception.ObjectList.list)
  return &list_;
}
inline const ::perception::Object& ObjectList::_internal_list(int index) const {
  return list_.Get(index);
}
inline const ::perception::Object& ObjectList::list(int index) const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.list)
  return _internal_list(index);
}
inline ::perception::Object* ObjectList::_internal_add_list() {
  return list_.Add();
}
inline ::perception::Object* ObjectList::add_list() {
  // @@protoc_insertion_point(field_add:perception.ObjectList.list)
  return _internal_add_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::Object >&
ObjectList::list() const {
  // @@protoc_insertion_point(field_list:perception.ObjectList.list)
  return list_;
}

// string version = 3;
inline void ObjectList::clear_version() {
  version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ObjectList::version() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.version)
  return _internal_version();
}
inline void ObjectList::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:perception.ObjectList.version)
}
inline std::string* ObjectList::mutable_version() {
  // @@protoc_insertion_point(field_mutable:perception.ObjectList.version)
  return _internal_mutable_version();
}
inline const std::string& ObjectList::_internal_version() const {
  return version_.Get();
}
inline void ObjectList::_internal_set_version(const std::string& value) {
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ObjectList::set_version(std::string&& value) {
  
  version_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:perception.ObjectList.version)
}
inline void ObjectList::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:perception.ObjectList.version)
}
inline void ObjectList::set_version(const char* value,
    size_t size) {
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:perception.ObjectList.version)
}
inline std::string* ObjectList::_internal_mutable_version() {
  
  return version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ObjectList::release_version() {
  // @@protoc_insertion_point(field_release:perception.ObjectList.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ObjectList::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:perception.ObjectList.version)
}
inline std::string* ObjectList::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:perception.ObjectList.version)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return version_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ObjectList::unsafe_arena_set_allocated_version(
    std::string* version) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (version != nullptr) {
    
  } else {
    
  }
  version_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      version, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.ObjectList.version)
}

// uint64 frame_id = 4;
inline void ObjectList::clear_frame_id() {
  frame_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::_internal_frame_id() const {
  return frame_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::frame_id() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.frame_id)
  return _internal_frame_id();
}
inline void ObjectList::_internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  frame_id_ = value;
}
inline void ObjectList::set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:perception.ObjectList.frame_id)
}

// uint64 timestamp = 5;
inline void ObjectList::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::timestamp() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.timestamp)
  return _internal_timestamp();
}
inline void ObjectList::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void ObjectList::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:perception.ObjectList.timestamp)
}

// .perception.object.Warning warning = 6;
inline bool ObjectList::_internal_has_warning() const {
  return this != internal_default_instance() && warning_ != nullptr;
}
inline bool ObjectList::has_warning() const {
  return _internal_has_warning();
}
inline const ::perception::object::Warning& ObjectList::_internal_warning() const {
  const ::perception::object::Warning* p = warning_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::object::Warning*>(
      &::perception::object::_Warning_default_instance_);
}
inline const ::perception::object::Warning& ObjectList::warning() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.warning)
  return _internal_warning();
}
inline void ObjectList::unsafe_arena_set_allocated_warning(
    ::perception::object::Warning* warning) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(warning_);
  }
  warning_ = warning;
  if (warning) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.ObjectList.warning)
}
inline ::perception::object::Warning* ObjectList::release_warning() {
  auto temp = unsafe_arena_release_warning();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::object::Warning* ObjectList::unsafe_arena_release_warning() {
  // @@protoc_insertion_point(field_release:perception.ObjectList.warning)
  
  ::perception::object::Warning* temp = warning_;
  warning_ = nullptr;
  return temp;
}
inline ::perception::object::Warning* ObjectList::_internal_mutable_warning() {
  
  if (warning_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::object::Warning>(GetArena());
    warning_ = p;
  }
  return warning_;
}
inline ::perception::object::Warning* ObjectList::mutable_warning() {
  // @@protoc_insertion_point(field_mutable:perception.ObjectList.warning)
  return _internal_mutable_warning();
}
inline void ObjectList::set_allocated_warning(::perception::object::Warning* warning) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(warning_);
  }
  if (warning) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(warning)->GetArena();
    if (message_arena != submessage_arena) {
      warning = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, warning, submessage_arena);
    }
    
  } else {
    
  }
  warning_ = warning;
  // @@protoc_insertion_point(field_set_allocated:perception.ObjectList.warning)
}

// repeated .perception.common.Rect2f roi_list = 7;
inline int ObjectList::_internal_roi_list_size() const {
  return roi_list_.size();
}
inline int ObjectList::roi_list_size() const {
  return _internal_roi_list_size();
}
inline ::perception::common::Rect2f* ObjectList::mutable_roi_list(int index) {
  // @@protoc_insertion_point(field_mutable:perception.ObjectList.roi_list)
  return roi_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Rect2f >*
ObjectList::mutable_roi_list() {
  // @@protoc_insertion_point(field_mutable_list:perception.ObjectList.roi_list)
  return &roi_list_;
}
inline const ::perception::common::Rect2f& ObjectList::_internal_roi_list(int index) const {
  return roi_list_.Get(index);
}
inline const ::perception::common::Rect2f& ObjectList::roi_list(int index) const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.roi_list)
  return _internal_roi_list(index);
}
inline ::perception::common::Rect2f* ObjectList::_internal_add_roi_list() {
  return roi_list_.Add();
}
inline ::perception::common::Rect2f* ObjectList::add_roi_list() {
  // @@protoc_insertion_point(field_add:perception.ObjectList.roi_list)
  return _internal_add_roi_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::common::Rect2f >&
ObjectList::roi_list() const {
  // @@protoc_insertion_point(field_list:perception.ObjectList.roi_list)
  return roi_list_;
}

// uint64 tick = 9;
inline void ObjectList::clear_tick() {
  tick_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::_internal_tick() const {
  return tick_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::tick() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.tick)
  return _internal_tick();
}
inline void ObjectList::_internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  tick_ = value;
}
inline void ObjectList::set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:perception.ObjectList.tick)
}

// uint64 start_time_us = 10;
inline void ObjectList::clear_start_time_us() {
  start_time_us_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::_internal_start_time_us() const {
  return start_time_us_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::start_time_us() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.start_time_us)
  return _internal_start_time_us();
}
inline void ObjectList::_internal_set_start_time_us(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  start_time_us_ = value;
}
inline void ObjectList::set_start_time_us(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_start_time_us(value);
  // @@protoc_insertion_point(field_set:perception.ObjectList.start_time_us)
}

// uint64 end_time_us = 11;
inline void ObjectList::clear_end_time_us() {
  end_time_us_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::_internal_end_time_us() const {
  return end_time_us_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::end_time_us() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.end_time_us)
  return _internal_end_time_us();
}
inline void ObjectList::_internal_set_end_time_us(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  end_time_us_ = value;
}
inline void ObjectList::set_end_time_us(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_end_time_us(value);
  // @@protoc_insertion_point(field_set:perception.ObjectList.end_time_us)
}

// repeated uint64 profiling_time = 12;
inline int ObjectList::_internal_profiling_time_size() const {
  return profiling_time_.size();
}
inline int ObjectList::profiling_time_size() const {
  return _internal_profiling_time_size();
}
inline void ObjectList::clear_profiling_time() {
  profiling_time_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::_internal_profiling_time(int index) const {
  return profiling_time_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ObjectList::profiling_time(int index) const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.profiling_time)
  return _internal_profiling_time(index);
}
inline void ObjectList::set_profiling_time(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  profiling_time_.Set(index, value);
  // @@protoc_insertion_point(field_set:perception.ObjectList.profiling_time)
}
inline void ObjectList::_internal_add_profiling_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  profiling_time_.Add(value);
}
inline void ObjectList::add_profiling_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_profiling_time(value);
  // @@protoc_insertion_point(field_add:perception.ObjectList.profiling_time)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
ObjectList::_internal_profiling_time() const {
  return profiling_time_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
ObjectList::profiling_time() const {
  // @@protoc_insertion_point(field_list:perception.ObjectList.profiling_time)
  return _internal_profiling_time();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
ObjectList::_internal_mutable_profiling_time() {
  return &profiling_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
ObjectList::mutable_profiling_time() {
  // @@protoc_insertion_point(field_mutable_list:perception.ObjectList.profiling_time)
  return _internal_mutable_profiling_time();
}

// .minieye.DataSource data_source = 15;
inline void ObjectList::clear_data_source() {
  data_source_ = 0;
}
inline ::minieye::DataSource ObjectList::_internal_data_source() const {
  return static_cast< ::minieye::DataSource >(data_source_);
}
inline ::minieye::DataSource ObjectList::data_source() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.data_source)
  return _internal_data_source();
}
inline void ObjectList::_internal_set_data_source(::minieye::DataSource value) {
  
  data_source_ = value;
}
inline void ObjectList::set_data_source(::minieye::DataSource value) {
  _internal_set_data_source(value);
  // @@protoc_insertion_point(field_set:perception.ObjectList.data_source)
}

// .minieye.CalibParam calib_param = 16;
inline bool ObjectList::_internal_has_calib_param() const {
  return this != internal_default_instance() && calib_param_ != nullptr;
}
inline bool ObjectList::has_calib_param() const {
  return _internal_has_calib_param();
}
inline const ::minieye::CalibParam& ObjectList::_internal_calib_param() const {
  const ::minieye::CalibParam* p = calib_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::CalibParam*>(
      &::minieye::_CalibParam_default_instance_);
}
inline const ::minieye::CalibParam& ObjectList::calib_param() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.calib_param)
  return _internal_calib_param();
}
inline void ObjectList::unsafe_arena_set_allocated_calib_param(
    ::minieye::CalibParam* calib_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(calib_param_);
  }
  calib_param_ = calib_param;
  if (calib_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.ObjectList.calib_param)
}
inline ::minieye::CalibParam* ObjectList::release_calib_param() {
  auto temp = unsafe_arena_release_calib_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::CalibParam* ObjectList::unsafe_arena_release_calib_param() {
  // @@protoc_insertion_point(field_release:perception.ObjectList.calib_param)
  
  ::minieye::CalibParam* temp = calib_param_;
  calib_param_ = nullptr;
  return temp;
}
inline ::minieye::CalibParam* ObjectList::_internal_mutable_calib_param() {
  
  if (calib_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::CalibParam>(GetArena());
    calib_param_ = p;
  }
  return calib_param_;
}
inline ::minieye::CalibParam* ObjectList::mutable_calib_param() {
  // @@protoc_insertion_point(field_mutable:perception.ObjectList.calib_param)
  return _internal_mutable_calib_param();
}
inline void ObjectList::set_allocated_calib_param(::minieye::CalibParam* calib_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(calib_param_);
  }
  if (calib_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(calib_param)->GetArena();
    if (message_arena != submessage_arena) {
      calib_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, calib_param, submessage_arena);
    }
    
  } else {
    
  }
  calib_param_ = calib_param;
  // @@protoc_insertion_point(field_set_allocated:perception.ObjectList.calib_param)
}

// .minieye.VehicleSignal vehicle_signal = 17;
inline bool ObjectList::_internal_has_vehicle_signal() const {
  return this != internal_default_instance() && vehicle_signal_ != nullptr;
}
inline bool ObjectList::has_vehicle_signal() const {
  return _internal_has_vehicle_signal();
}
inline const ::minieye::VehicleSignal& ObjectList::_internal_vehicle_signal() const {
  const ::minieye::VehicleSignal* p = vehicle_signal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::VehicleSignal*>(
      &::minieye::_VehicleSignal_default_instance_);
}
inline const ::minieye::VehicleSignal& ObjectList::vehicle_signal() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.vehicle_signal)
  return _internal_vehicle_signal();
}
inline void ObjectList::unsafe_arena_set_allocated_vehicle_signal(
    ::minieye::VehicleSignal* vehicle_signal) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehicle_signal_);
  }
  vehicle_signal_ = vehicle_signal;
  if (vehicle_signal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.ObjectList.vehicle_signal)
}
inline ::minieye::VehicleSignal* ObjectList::release_vehicle_signal() {
  auto temp = unsafe_arena_release_vehicle_signal();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::VehicleSignal* ObjectList::unsafe_arena_release_vehicle_signal() {
  // @@protoc_insertion_point(field_release:perception.ObjectList.vehicle_signal)
  
  ::minieye::VehicleSignal* temp = vehicle_signal_;
  vehicle_signal_ = nullptr;
  return temp;
}
inline ::minieye::VehicleSignal* ObjectList::_internal_mutable_vehicle_signal() {
  
  if (vehicle_signal_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::VehicleSignal>(GetArena());
    vehicle_signal_ = p;
  }
  return vehicle_signal_;
}
inline ::minieye::VehicleSignal* ObjectList::mutable_vehicle_signal() {
  // @@protoc_insertion_point(field_mutable:perception.ObjectList.vehicle_signal)
  return _internal_mutable_vehicle_signal();
}
inline void ObjectList::set_allocated_vehicle_signal(::minieye::VehicleSignal* vehicle_signal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehicle_signal_);
  }
  if (vehicle_signal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehicle_signal)->GetArena();
    if (message_arena != submessage_arena) {
      vehicle_signal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle_signal, submessage_arena);
    }
    
  } else {
    
  }
  vehicle_signal_ = vehicle_signal;
  // @@protoc_insertion_point(field_set_allocated:perception.ObjectList.vehicle_signal)
}

// .minieye.CameraParam camera_param = 18;
inline bool ObjectList::_internal_has_camera_param() const {
  return this != internal_default_instance() && camera_param_ != nullptr;
}
inline bool ObjectList::has_camera_param() const {
  return _internal_has_camera_param();
}
inline const ::minieye::CameraParam& ObjectList::_internal_camera_param() const {
  const ::minieye::CameraParam* p = camera_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::CameraParam*>(
      &::minieye::_CameraParam_default_instance_);
}
inline const ::minieye::CameraParam& ObjectList::camera_param() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.camera_param)
  return _internal_camera_param();
}
inline void ObjectList::unsafe_arena_set_allocated_camera_param(
    ::minieye::CameraParam* camera_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_param_);
  }
  camera_param_ = camera_param;
  if (camera_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.ObjectList.camera_param)
}
inline ::minieye::CameraParam* ObjectList::release_camera_param() {
  auto temp = unsafe_arena_release_camera_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::CameraParam* ObjectList::unsafe_arena_release_camera_param() {
  // @@protoc_insertion_point(field_release:perception.ObjectList.camera_param)
  
  ::minieye::CameraParam* temp = camera_param_;
  camera_param_ = nullptr;
  return temp;
}
inline ::minieye::CameraParam* ObjectList::_internal_mutable_camera_param() {
  
  if (camera_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::CameraParam>(GetArena());
    camera_param_ = p;
  }
  return camera_param_;
}
inline ::minieye::CameraParam* ObjectList::mutable_camera_param() {
  // @@protoc_insertion_point(field_mutable:perception.ObjectList.camera_param)
  return _internal_mutable_camera_param();
}
inline void ObjectList::set_allocated_camera_param(::minieye::CameraParam* camera_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_param_);
  }
  if (camera_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_param)->GetArena();
    if (message_arena != submessage_arena) {
      camera_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_param, submessage_arena);
    }
    
  } else {
    
  }
  camera_param_ = camera_param;
  // @@protoc_insertion_point(field_set_allocated:perception.ObjectList.camera_param)
}

// .minieye.CamID cam_id = 19;
inline bool ObjectList::_internal_has_cam_id() const {
  return this != internal_default_instance() && cam_id_ != nullptr;
}
inline bool ObjectList::has_cam_id() const {
  return _internal_has_cam_id();
}
inline const ::minieye::CamID& ObjectList::_internal_cam_id() const {
  const ::minieye::CamID* p = cam_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::CamID*>(
      &::minieye::_CamID_default_instance_);
}
inline const ::minieye::CamID& ObjectList::cam_id() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.cam_id)
  return _internal_cam_id();
}
inline void ObjectList::unsafe_arena_set_allocated_cam_id(
    ::minieye::CamID* cam_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cam_id_);
  }
  cam_id_ = cam_id;
  if (cam_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.ObjectList.cam_id)
}
inline ::minieye::CamID* ObjectList::release_cam_id() {
  auto temp = unsafe_arena_release_cam_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::CamID* ObjectList::unsafe_arena_release_cam_id() {
  // @@protoc_insertion_point(field_release:perception.ObjectList.cam_id)
  
  ::minieye::CamID* temp = cam_id_;
  cam_id_ = nullptr;
  return temp;
}
inline ::minieye::CamID* ObjectList::_internal_mutable_cam_id() {
  
  if (cam_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::CamID>(GetArena());
    cam_id_ = p;
  }
  return cam_id_;
}
inline ::minieye::CamID* ObjectList::mutable_cam_id() {
  // @@protoc_insertion_point(field_mutable:perception.ObjectList.cam_id)
  return _internal_mutable_cam_id();
}
inline void ObjectList::set_allocated_cam_id(::minieye::CamID* cam_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cam_id_);
  }
  if (cam_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cam_id)->GetArena();
    if (message_arena != submessage_arena) {
      cam_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cam_id, submessage_arena);
    }
    
  } else {
    
  }
  cam_id_ = cam_id;
  // @@protoc_insertion_point(field_set_allocated:perception.ObjectList.cam_id)
}

// uint32 cam_prj_id = 20;
inline void ObjectList::clear_cam_prj_id() {
  cam_prj_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ObjectList::_internal_cam_prj_id() const {
  return cam_prj_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ObjectList::cam_prj_id() const {
  // @@protoc_insertion_point(field_get:perception.ObjectList.cam_prj_id)
  return _internal_cam_prj_id();
}
inline void ObjectList::_internal_set_cam_prj_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  cam_prj_id_ = value;
}
inline void ObjectList::set_cam_prj_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_cam_prj_id(value);
  // @@protoc_insertion_point(field_set:perception.ObjectList.cam_prj_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::perception::Object_ObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_ObjectType>() {
  return ::perception::Object_ObjectType_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_VehiclePose> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_VehiclePose>() {
  return ::perception::Object_VehiclePose_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_AnchorPtInfo> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_AnchorPtInfo>() {
  return ::perception::Object_AnchorPtInfo_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_MeasureType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_MeasureType>() {
  return ::perception::Object_MeasureType_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_VehicleClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_VehicleClass>() {
  return ::perception::Object_VehicleClass_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_TrafficLightClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_TrafficLightClass>() {
  return ::perception::Object_TrafficLightClass_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_TrafficLightStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_TrafficLightStatus>() {
  return ::perception::Object_TrafficLightStatus_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_VehicleLightClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_VehicleLightClass>() {
  return ::perception::Object_VehicleLightClass_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_VehicleLightStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_VehicleLightStatus>() {
  return ::perception::Object_VehicleLightStatus_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_MoveState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_MoveState>() {
  return ::perception::Object_MoveState_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_VehicleRigidAnchor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_VehicleRigidAnchor>() {
  return ::perception::Object_VehicleRigidAnchor_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_TrackStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_TrackStatus>() {
  return ::perception::Object_TrackStatus_descriptor();
}
template <> struct is_proto_enum< ::perception::Object_SelectLevelStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::Object_SelectLevelStatus>() {
  return ::perception::Object_SelectLevelStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_object_2eproto
