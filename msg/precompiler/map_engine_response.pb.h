// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map_engine_response.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_map_5fengine_5fresponse_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_map_5fengine_5fresponse_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "planning.pb.h"
#include "odometry_3d.pb.h"
#include "parkingspace.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_map_5fengine_5fresponse_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_map_5fengine_5fresponse_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_map_5fengine_5fresponse_2eproto;
namespace minieye {
namespace parking {
class MapEngineResponse;
class MapEngineResponseDefaultTypeInternal;
extern MapEngineResponseDefaultTypeInternal _MapEngineResponse_default_instance_;
class MapEngineResponse_Semantic;
class MapEngineResponse_SemanticDefaultTypeInternal;
extern MapEngineResponse_SemanticDefaultTypeInternal _MapEngineResponse_Semantic_default_instance_;
class MapEngineResponse_Slope;
class MapEngineResponse_SlopeDefaultTypeInternal;
extern MapEngineResponse_SlopeDefaultTypeInternal _MapEngineResponse_Slope_default_instance_;
class MapEngineResponse_Turn;
class MapEngineResponse_TurnDefaultTypeInternal;
extern MapEngineResponse_TurnDefaultTypeInternal _MapEngineResponse_Turn_default_instance_;
}  // namespace parking
}  // namespace minieye
PROTOBUF_NAMESPACE_OPEN
template<> ::minieye::parking::MapEngineResponse* Arena::CreateMaybeMessage<::minieye::parking::MapEngineResponse>(Arena*);
template<> ::minieye::parking::MapEngineResponse_Semantic* Arena::CreateMaybeMessage<::minieye::parking::MapEngineResponse_Semantic>(Arena*);
template<> ::minieye::parking::MapEngineResponse_Slope* Arena::CreateMaybeMessage<::minieye::parking::MapEngineResponse_Slope>(Arena*);
template<> ::minieye::parking::MapEngineResponse_Turn* Arena::CreateMaybeMessage<::minieye::parking::MapEngineResponse_Turn>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace minieye {
namespace parking {

enum MapEngineResponse_Turn_TurnType : int {
  MapEngineResponse_Turn_TurnType_U = 0,
  MapEngineResponse_Turn_TurnType_ClockWise = 1,
  MapEngineResponse_Turn_TurnType_AntiClockWise = 2,
  MapEngineResponse_Turn_TurnType_MapEngineResponse_Turn_TurnType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MapEngineResponse_Turn_TurnType_MapEngineResponse_Turn_TurnType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MapEngineResponse_Turn_TurnType_IsValid(int value);
constexpr MapEngineResponse_Turn_TurnType MapEngineResponse_Turn_TurnType_TurnType_MIN = MapEngineResponse_Turn_TurnType_U;
constexpr MapEngineResponse_Turn_TurnType MapEngineResponse_Turn_TurnType_TurnType_MAX = MapEngineResponse_Turn_TurnType_AntiClockWise;
constexpr int MapEngineResponse_Turn_TurnType_TurnType_ARRAYSIZE = MapEngineResponse_Turn_TurnType_TurnType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MapEngineResponse_Turn_TurnType_descriptor();
template<typename T>
inline const std::string& MapEngineResponse_Turn_TurnType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MapEngineResponse_Turn_TurnType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MapEngineResponse_Turn_TurnType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MapEngineResponse_Turn_TurnType_descriptor(), enum_t_value);
}
inline bool MapEngineResponse_Turn_TurnType_Parse(
    const std::string& name, MapEngineResponse_Turn_TurnType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MapEngineResponse_Turn_TurnType>(
    MapEngineResponse_Turn_TurnType_descriptor(), name, value);
}
enum MapEngineResponse_Slope_SlopeType : int {
  MapEngineResponse_Slope_SlopeType_Up = 0,
  MapEngineResponse_Slope_SlopeType_Down = 1,
  MapEngineResponse_Slope_SlopeType_MapEngineResponse_Slope_SlopeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MapEngineResponse_Slope_SlopeType_MapEngineResponse_Slope_SlopeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MapEngineResponse_Slope_SlopeType_IsValid(int value);
constexpr MapEngineResponse_Slope_SlopeType MapEngineResponse_Slope_SlopeType_SlopeType_MIN = MapEngineResponse_Slope_SlopeType_Up;
constexpr MapEngineResponse_Slope_SlopeType MapEngineResponse_Slope_SlopeType_SlopeType_MAX = MapEngineResponse_Slope_SlopeType_Down;
constexpr int MapEngineResponse_Slope_SlopeType_SlopeType_ARRAYSIZE = MapEngineResponse_Slope_SlopeType_SlopeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MapEngineResponse_Slope_SlopeType_descriptor();
template<typename T>
inline const std::string& MapEngineResponse_Slope_SlopeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MapEngineResponse_Slope_SlopeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MapEngineResponse_Slope_SlopeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MapEngineResponse_Slope_SlopeType_descriptor(), enum_t_value);
}
inline bool MapEngineResponse_Slope_SlopeType_Parse(
    const std::string& name, MapEngineResponse_Slope_SlopeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MapEngineResponse_Slope_SlopeType>(
    MapEngineResponse_Slope_SlopeType_descriptor(), name, value);
}
enum MapEngineResponse_Semantic_SemanticType : int {
  MapEngineResponse_Semantic_SemanticType_ParkingSlot = 0,
  MapEngineResponse_Semantic_SemanticType_Lane = 1,
  MapEngineResponse_Semantic_SemanticType_SpeedBump = 2,
  MapEngineResponse_Semantic_SemanticType_Pillar = 3,
  MapEngineResponse_Semantic_SemanticType_MapEngineResponse_Semantic_SemanticType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MapEngineResponse_Semantic_SemanticType_MapEngineResponse_Semantic_SemanticType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MapEngineResponse_Semantic_SemanticType_IsValid(int value);
constexpr MapEngineResponse_Semantic_SemanticType MapEngineResponse_Semantic_SemanticType_SemanticType_MIN = MapEngineResponse_Semantic_SemanticType_ParkingSlot;
constexpr MapEngineResponse_Semantic_SemanticType MapEngineResponse_Semantic_SemanticType_SemanticType_MAX = MapEngineResponse_Semantic_SemanticType_Pillar;
constexpr int MapEngineResponse_Semantic_SemanticType_SemanticType_ARRAYSIZE = MapEngineResponse_Semantic_SemanticType_SemanticType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MapEngineResponse_Semantic_SemanticType_descriptor();
template<typename T>
inline const std::string& MapEngineResponse_Semantic_SemanticType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MapEngineResponse_Semantic_SemanticType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MapEngineResponse_Semantic_SemanticType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MapEngineResponse_Semantic_SemanticType_descriptor(), enum_t_value);
}
inline bool MapEngineResponse_Semantic_SemanticType_Parse(
    const std::string& name, MapEngineResponse_Semantic_SemanticType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MapEngineResponse_Semantic_SemanticType>(
    MapEngineResponse_Semantic_SemanticType_descriptor(), name, value);
}
// ===================================================================

class MapEngineResponse_Turn PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.parking.MapEngineResponse.Turn) */ {
 public:
  inline MapEngineResponse_Turn() : MapEngineResponse_Turn(nullptr) {};
  virtual ~MapEngineResponse_Turn();

  MapEngineResponse_Turn(const MapEngineResponse_Turn& from);
  MapEngineResponse_Turn(MapEngineResponse_Turn&& from) noexcept
    : MapEngineResponse_Turn() {
    *this = ::std::move(from);
  }

  inline MapEngineResponse_Turn& operator=(const MapEngineResponse_Turn& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapEngineResponse_Turn& operator=(MapEngineResponse_Turn&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MapEngineResponse_Turn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapEngineResponse_Turn* internal_default_instance() {
    return reinterpret_cast<const MapEngineResponse_Turn*>(
               &_MapEngineResponse_Turn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MapEngineResponse_Turn& a, MapEngineResponse_Turn& b) {
    a.Swap(&b);
  }
  inline void Swap(MapEngineResponse_Turn* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapEngineResponse_Turn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapEngineResponse_Turn* New() const final {
    return CreateMaybeMessage<MapEngineResponse_Turn>(nullptr);
  }

  MapEngineResponse_Turn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapEngineResponse_Turn>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MapEngineResponse_Turn& from);
  void MergeFrom(const MapEngineResponse_Turn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapEngineResponse_Turn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.parking.MapEngineResponse.Turn";
  }
  protected:
  explicit MapEngineResponse_Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_map_5fengine_5fresponse_2eproto);
    return ::descriptor_table_map_5fengine_5fresponse_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MapEngineResponse_Turn_TurnType TurnType;
  static constexpr TurnType U =
    MapEngineResponse_Turn_TurnType_U;
  static constexpr TurnType ClockWise =
    MapEngineResponse_Turn_TurnType_ClockWise;
  static constexpr TurnType AntiClockWise =
    MapEngineResponse_Turn_TurnType_AntiClockWise;
  static inline bool TurnType_IsValid(int value) {
    return MapEngineResponse_Turn_TurnType_IsValid(value);
  }
  static constexpr TurnType TurnType_MIN =
    MapEngineResponse_Turn_TurnType_TurnType_MIN;
  static constexpr TurnType TurnType_MAX =
    MapEngineResponse_Turn_TurnType_TurnType_MAX;
  static constexpr int TurnType_ARRAYSIZE =
    MapEngineResponse_Turn_TurnType_TurnType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TurnType_descriptor() {
    return MapEngineResponse_Turn_TurnType_descriptor();
  }
  template<typename T>
  static inline const std::string& TurnType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TurnType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TurnType_Name.");
    return MapEngineResponse_Turn_TurnType_Name(enum_t_value);
  }
  static inline bool TurnType_Parse(const std::string& name,
      TurnType* value) {
    return MapEngineResponse_Turn_TurnType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTurnStartFieldNumber = 1,
    kTurnEndFieldNumber = 2,
    kTrueTypeFieldNumber = 3,
  };
  // .minieye.Point3d turn_start = 1;
  bool has_turn_start() const;
  private:
  bool _internal_has_turn_start() const;
  public:
  void clear_turn_start();
  const ::minieye::Point3d& turn_start() const;
  ::minieye::Point3d* release_turn_start();
  ::minieye::Point3d* mutable_turn_start();
  void set_allocated_turn_start(::minieye::Point3d* turn_start);
  private:
  const ::minieye::Point3d& _internal_turn_start() const;
  ::minieye::Point3d* _internal_mutable_turn_start();
  public:
  void unsafe_arena_set_allocated_turn_start(
      ::minieye::Point3d* turn_start);
  ::minieye::Point3d* unsafe_arena_release_turn_start();

  // .minieye.Point3d turn_end = 2;
  bool has_turn_end() const;
  private:
  bool _internal_has_turn_end() const;
  public:
  void clear_turn_end();
  const ::minieye::Point3d& turn_end() const;
  ::minieye::Point3d* release_turn_end();
  ::minieye::Point3d* mutable_turn_end();
  void set_allocated_turn_end(::minieye::Point3d* turn_end);
  private:
  const ::minieye::Point3d& _internal_turn_end() const;
  ::minieye::Point3d* _internal_mutable_turn_end();
  public:
  void unsafe_arena_set_allocated_turn_end(
      ::minieye::Point3d* turn_end);
  ::minieye::Point3d* unsafe_arena_release_turn_end();

  // .minieye.parking.MapEngineResponse.Turn.TurnType true_type = 3;
  void clear_true_type();
  ::minieye::parking::MapEngineResponse_Turn_TurnType true_type() const;
  void set_true_type(::minieye::parking::MapEngineResponse_Turn_TurnType value);
  private:
  ::minieye::parking::MapEngineResponse_Turn_TurnType _internal_true_type() const;
  void _internal_set_true_type(::minieye::parking::MapEngineResponse_Turn_TurnType value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.parking.MapEngineResponse.Turn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minieye::Point3d* turn_start_;
  ::minieye::Point3d* turn_end_;
  int true_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_map_5fengine_5fresponse_2eproto;
};
// -------------------------------------------------------------------

class MapEngineResponse_Slope PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.parking.MapEngineResponse.Slope) */ {
 public:
  inline MapEngineResponse_Slope() : MapEngineResponse_Slope(nullptr) {};
  virtual ~MapEngineResponse_Slope();

  MapEngineResponse_Slope(const MapEngineResponse_Slope& from);
  MapEngineResponse_Slope(MapEngineResponse_Slope&& from) noexcept
    : MapEngineResponse_Slope() {
    *this = ::std::move(from);
  }

  inline MapEngineResponse_Slope& operator=(const MapEngineResponse_Slope& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapEngineResponse_Slope& operator=(MapEngineResponse_Slope&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MapEngineResponse_Slope& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapEngineResponse_Slope* internal_default_instance() {
    return reinterpret_cast<const MapEngineResponse_Slope*>(
               &_MapEngineResponse_Slope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MapEngineResponse_Slope& a, MapEngineResponse_Slope& b) {
    a.Swap(&b);
  }
  inline void Swap(MapEngineResponse_Slope* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapEngineResponse_Slope* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapEngineResponse_Slope* New() const final {
    return CreateMaybeMessage<MapEngineResponse_Slope>(nullptr);
  }

  MapEngineResponse_Slope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapEngineResponse_Slope>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MapEngineResponse_Slope& from);
  void MergeFrom(const MapEngineResponse_Slope& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapEngineResponse_Slope* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.parking.MapEngineResponse.Slope";
  }
  protected:
  explicit MapEngineResponse_Slope(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_map_5fengine_5fresponse_2eproto);
    return ::descriptor_table_map_5fengine_5fresponse_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MapEngineResponse_Slope_SlopeType SlopeType;
  static constexpr SlopeType Up =
    MapEngineResponse_Slope_SlopeType_Up;
  static constexpr SlopeType Down =
    MapEngineResponse_Slope_SlopeType_Down;
  static inline bool SlopeType_IsValid(int value) {
    return MapEngineResponse_Slope_SlopeType_IsValid(value);
  }
  static constexpr SlopeType SlopeType_MIN =
    MapEngineResponse_Slope_SlopeType_SlopeType_MIN;
  static constexpr SlopeType SlopeType_MAX =
    MapEngineResponse_Slope_SlopeType_SlopeType_MAX;
  static constexpr int SlopeType_ARRAYSIZE =
    MapEngineResponse_Slope_SlopeType_SlopeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SlopeType_descriptor() {
    return MapEngineResponse_Slope_SlopeType_descriptor();
  }
  template<typename T>
  static inline const std::string& SlopeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SlopeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SlopeType_Name.");
    return MapEngineResponse_Slope_SlopeType_Name(enum_t_value);
  }
  static inline bool SlopeType_Parse(const std::string& name,
      SlopeType* value) {
    return MapEngineResponse_Slope_SlopeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSlopeStartFieldNumber = 1,
    kSlopeEndFieldNumber = 2,
    kSlopeTypeFieldNumber = 3,
  };
  // .minieye.Point3d slope_start = 1;
  bool has_slope_start() const;
  private:
  bool _internal_has_slope_start() const;
  public:
  void clear_slope_start();
  const ::minieye::Point3d& slope_start() const;
  ::minieye::Point3d* release_slope_start();
  ::minieye::Point3d* mutable_slope_start();
  void set_allocated_slope_start(::minieye::Point3d* slope_start);
  private:
  const ::minieye::Point3d& _internal_slope_start() const;
  ::minieye::Point3d* _internal_mutable_slope_start();
  public:
  void unsafe_arena_set_allocated_slope_start(
      ::minieye::Point3d* slope_start);
  ::minieye::Point3d* unsafe_arena_release_slope_start();

  // .minieye.Point3d slope_end = 2;
  bool has_slope_end() const;
  private:
  bool _internal_has_slope_end() const;
  public:
  void clear_slope_end();
  const ::minieye::Point3d& slope_end() const;
  ::minieye::Point3d* release_slope_end();
  ::minieye::Point3d* mutable_slope_end();
  void set_allocated_slope_end(::minieye::Point3d* slope_end);
  private:
  const ::minieye::Point3d& _internal_slope_end() const;
  ::minieye::Point3d* _internal_mutable_slope_end();
  public:
  void unsafe_arena_set_allocated_slope_end(
      ::minieye::Point3d* slope_end);
  ::minieye::Point3d* unsafe_arena_release_slope_end();

  // .minieye.parking.MapEngineResponse.Slope.SlopeType slope_type = 3;
  void clear_slope_type();
  ::minieye::parking::MapEngineResponse_Slope_SlopeType slope_type() const;
  void set_slope_type(::minieye::parking::MapEngineResponse_Slope_SlopeType value);
  private:
  ::minieye::parking::MapEngineResponse_Slope_SlopeType _internal_slope_type() const;
  void _internal_set_slope_type(::minieye::parking::MapEngineResponse_Slope_SlopeType value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.parking.MapEngineResponse.Slope)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minieye::Point3d* slope_start_;
  ::minieye::Point3d* slope_end_;
  int slope_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_map_5fengine_5fresponse_2eproto;
};
// -------------------------------------------------------------------

class MapEngineResponse_Semantic PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.parking.MapEngineResponse.Semantic) */ {
 public:
  inline MapEngineResponse_Semantic() : MapEngineResponse_Semantic(nullptr) {};
  virtual ~MapEngineResponse_Semantic();

  MapEngineResponse_Semantic(const MapEngineResponse_Semantic& from);
  MapEngineResponse_Semantic(MapEngineResponse_Semantic&& from) noexcept
    : MapEngineResponse_Semantic() {
    *this = ::std::move(from);
  }

  inline MapEngineResponse_Semantic& operator=(const MapEngineResponse_Semantic& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapEngineResponse_Semantic& operator=(MapEngineResponse_Semantic&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MapEngineResponse_Semantic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapEngineResponse_Semantic* internal_default_instance() {
    return reinterpret_cast<const MapEngineResponse_Semantic*>(
               &_MapEngineResponse_Semantic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MapEngineResponse_Semantic& a, MapEngineResponse_Semantic& b) {
    a.Swap(&b);
  }
  inline void Swap(MapEngineResponse_Semantic* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapEngineResponse_Semantic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapEngineResponse_Semantic* New() const final {
    return CreateMaybeMessage<MapEngineResponse_Semantic>(nullptr);
  }

  MapEngineResponse_Semantic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapEngineResponse_Semantic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MapEngineResponse_Semantic& from);
  void MergeFrom(const MapEngineResponse_Semantic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapEngineResponse_Semantic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.parking.MapEngineResponse.Semantic";
  }
  protected:
  explicit MapEngineResponse_Semantic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_map_5fengine_5fresponse_2eproto);
    return ::descriptor_table_map_5fengine_5fresponse_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MapEngineResponse_Semantic_SemanticType SemanticType;
  static constexpr SemanticType ParkingSlot =
    MapEngineResponse_Semantic_SemanticType_ParkingSlot;
  static constexpr SemanticType Lane =
    MapEngineResponse_Semantic_SemanticType_Lane;
  static constexpr SemanticType SpeedBump =
    MapEngineResponse_Semantic_SemanticType_SpeedBump;
  static constexpr SemanticType Pillar =
    MapEngineResponse_Semantic_SemanticType_Pillar;
  static inline bool SemanticType_IsValid(int value) {
    return MapEngineResponse_Semantic_SemanticType_IsValid(value);
  }
  static constexpr SemanticType SemanticType_MIN =
    MapEngineResponse_Semantic_SemanticType_SemanticType_MIN;
  static constexpr SemanticType SemanticType_MAX =
    MapEngineResponse_Semantic_SemanticType_SemanticType_MAX;
  static constexpr int SemanticType_ARRAYSIZE =
    MapEngineResponse_Semantic_SemanticType_SemanticType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SemanticType_descriptor() {
    return MapEngineResponse_Semantic_SemanticType_descriptor();
  }
  template<typename T>
  static inline const std::string& SemanticType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SemanticType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SemanticType_Name.");
    return MapEngineResponse_Semantic_SemanticType_Name(enum_t_value);
  }
  static inline bool SemanticType_Parse(const std::string& name,
      SemanticType* value) {
    return MapEngineResponse_Semantic_SemanticType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContourPointsFieldNumber = 2,
    kSemanticTypeFieldNumber = 1,
  };
  // repeated .minieye.Point3d contour_points = 2;
  int contour_points_size() const;
  private:
  int _internal_contour_points_size() const;
  public:
  void clear_contour_points();
  ::minieye::Point3d* mutable_contour_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Point3d >*
      mutable_contour_points();
  private:
  const ::minieye::Point3d& _internal_contour_points(int index) const;
  ::minieye::Point3d* _internal_add_contour_points();
  public:
  const ::minieye::Point3d& contour_points(int index) const;
  ::minieye::Point3d* add_contour_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Point3d >&
      contour_points() const;

  // .minieye.parking.MapEngineResponse.Semantic.SemanticType semantic_type = 1;
  void clear_semantic_type();
  ::minieye::parking::MapEngineResponse_Semantic_SemanticType semantic_type() const;
  void set_semantic_type(::minieye::parking::MapEngineResponse_Semantic_SemanticType value);
  private:
  ::minieye::parking::MapEngineResponse_Semantic_SemanticType _internal_semantic_type() const;
  void _internal_set_semantic_type(::minieye::parking::MapEngineResponse_Semantic_SemanticType value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.parking.MapEngineResponse.Semantic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Point3d > contour_points_;
  int semantic_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_map_5fengine_5fresponse_2eproto;
};
// -------------------------------------------------------------------

class MapEngineResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.parking.MapEngineResponse) */ {
 public:
  inline MapEngineResponse() : MapEngineResponse(nullptr) {};
  virtual ~MapEngineResponse();

  MapEngineResponse(const MapEngineResponse& from);
  MapEngineResponse(MapEngineResponse&& from) noexcept
    : MapEngineResponse() {
    *this = ::std::move(from);
  }

  inline MapEngineResponse& operator=(const MapEngineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapEngineResponse& operator=(MapEngineResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MapEngineResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapEngineResponse* internal_default_instance() {
    return reinterpret_cast<const MapEngineResponse*>(
               &_MapEngineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MapEngineResponse& a, MapEngineResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MapEngineResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapEngineResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapEngineResponse* New() const final {
    return CreateMaybeMessage<MapEngineResponse>(nullptr);
  }

  MapEngineResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapEngineResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MapEngineResponse& from);
  void MergeFrom(const MapEngineResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapEngineResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.parking.MapEngineResponse";
  }
  protected:
  explicit MapEngineResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_map_5fengine_5fresponse_2eproto);
    return ::descriptor_table_map_5fengine_5fresponse_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MapEngineResponse_Turn Turn;
  typedef MapEngineResponse_Slope Slope;
  typedef MapEngineResponse_Semantic Semantic;

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryFieldNumber = 6,
    kTurnFieldNumber = 8,
    kSlopeFieldNumber = 9,
    kSemanticFieldNumber = 10,
    kPlanningFieldNumber = 4,
    kMappingTrigerPointFieldNumber = 5,
    kTargetParkingSlotFieldNumber = 7,
    kMappingEndPoseFieldNumber = 11,
    kTimestampFieldNumber = 1,
    kTickFieldNumber = 2,
    kFrameIdFieldNumber = 3,
  };
  // repeated .minieye.Point3d trajectory = 6;
  int trajectory_size() const;
  private:
  int _internal_trajectory_size() const;
  public:
  void clear_trajectory();
  ::minieye::Point3d* mutable_trajectory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Point3d >*
      mutable_trajectory();
  private:
  const ::minieye::Point3d& _internal_trajectory(int index) const;
  ::minieye::Point3d* _internal_add_trajectory();
  public:
  const ::minieye::Point3d& trajectory(int index) const;
  ::minieye::Point3d* add_trajectory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Point3d >&
      trajectory() const;

  // repeated .minieye.parking.MapEngineResponse.Turn turn = 8;
  int turn_size() const;
  private:
  int _internal_turn_size() const;
  public:
  void clear_turn();
  ::minieye::parking::MapEngineResponse_Turn* mutable_turn(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Turn >*
      mutable_turn();
  private:
  const ::minieye::parking::MapEngineResponse_Turn& _internal_turn(int index) const;
  ::minieye::parking::MapEngineResponse_Turn* _internal_add_turn();
  public:
  const ::minieye::parking::MapEngineResponse_Turn& turn(int index) const;
  ::minieye::parking::MapEngineResponse_Turn* add_turn();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Turn >&
      turn() const;

  // repeated .minieye.parking.MapEngineResponse.Slope slope = 9;
  int slope_size() const;
  private:
  int _internal_slope_size() const;
  public:
  void clear_slope();
  ::minieye::parking::MapEngineResponse_Slope* mutable_slope(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Slope >*
      mutable_slope();
  private:
  const ::minieye::parking::MapEngineResponse_Slope& _internal_slope(int index) const;
  ::minieye::parking::MapEngineResponse_Slope* _internal_add_slope();
  public:
  const ::minieye::parking::MapEngineResponse_Slope& slope(int index) const;
  ::minieye::parking::MapEngineResponse_Slope* add_slope();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Slope >&
      slope() const;

  // repeated .minieye.parking.MapEngineResponse.Semantic semantic = 10;
  int semantic_size() const;
  private:
  int _internal_semantic_size() const;
  public:
  void clear_semantic();
  ::minieye::parking::MapEngineResponse_Semantic* mutable_semantic(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Semantic >*
      mutable_semantic();
  private:
  const ::minieye::parking::MapEngineResponse_Semantic& _internal_semantic(int index) const;
  ::minieye::parking::MapEngineResponse_Semantic* _internal_add_semantic();
  public:
  const ::minieye::parking::MapEngineResponse_Semantic& semantic(int index) const;
  ::minieye::parking::MapEngineResponse_Semantic* add_semantic();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Semantic >&
      semantic() const;

  // .minieye.Planning planning = 4;
  bool has_planning() const;
  private:
  bool _internal_has_planning() const;
  public:
  void clear_planning();
  const ::minieye::Planning& planning() const;
  ::minieye::Planning* release_planning();
  ::minieye::Planning* mutable_planning();
  void set_allocated_planning(::minieye::Planning* planning);
  private:
  const ::minieye::Planning& _internal_planning() const;
  ::minieye::Planning* _internal_mutable_planning();
  public:
  void unsafe_arena_set_allocated_planning(
      ::minieye::Planning* planning);
  ::minieye::Planning* unsafe_arena_release_planning();

  // .minieye.Point3d mapping_triger_point = 5;
  bool has_mapping_triger_point() const;
  private:
  bool _internal_has_mapping_triger_point() const;
  public:
  void clear_mapping_triger_point();
  const ::minieye::Point3d& mapping_triger_point() const;
  ::minieye::Point3d* release_mapping_triger_point();
  ::minieye::Point3d* mutable_mapping_triger_point();
  void set_allocated_mapping_triger_point(::minieye::Point3d* mapping_triger_point);
  private:
  const ::minieye::Point3d& _internal_mapping_triger_point() const;
  ::minieye::Point3d* _internal_mutable_mapping_triger_point();
  public:
  void unsafe_arena_set_allocated_mapping_triger_point(
      ::minieye::Point3d* mapping_triger_point);
  ::minieye::Point3d* unsafe_arena_release_mapping_triger_point();

  // .perception.ParkingSlot target_parking_slot = 7;
  bool has_target_parking_slot() const;
  private:
  bool _internal_has_target_parking_slot() const;
  public:
  void clear_target_parking_slot();
  const ::perception::ParkingSlot& target_parking_slot() const;
  ::perception::ParkingSlot* release_target_parking_slot();
  ::perception::ParkingSlot* mutable_target_parking_slot();
  void set_allocated_target_parking_slot(::perception::ParkingSlot* target_parking_slot);
  private:
  const ::perception::ParkingSlot& _internal_target_parking_slot() const;
  ::perception::ParkingSlot* _internal_mutable_target_parking_slot();
  public:
  void unsafe_arena_set_allocated_target_parking_slot(
      ::perception::ParkingSlot* target_parking_slot);
  ::perception::ParkingSlot* unsafe_arena_release_target_parking_slot();

  // .minieye.Pose6d mapping_end_pose = 11;
  bool has_mapping_end_pose() const;
  private:
  bool _internal_has_mapping_end_pose() const;
  public:
  void clear_mapping_end_pose();
  const ::minieye::Pose6d& mapping_end_pose() const;
  ::minieye::Pose6d* release_mapping_end_pose();
  ::minieye::Pose6d* mutable_mapping_end_pose();
  void set_allocated_mapping_end_pose(::minieye::Pose6d* mapping_end_pose);
  private:
  const ::minieye::Pose6d& _internal_mapping_end_pose() const;
  ::minieye::Pose6d* _internal_mutable_mapping_end_pose();
  public:
  void unsafe_arena_set_allocated_mapping_end_pose(
      ::minieye::Pose6d* mapping_end_pose);
  ::minieye::Pose6d* unsafe_arena_release_mapping_end_pose();

  // uint64 timestamp = 1;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 tick = 2;
  void clear_tick();
  ::PROTOBUF_NAMESPACE_ID::uint64 tick() const;
  void set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tick() const;
  void _internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 frame_id = 3;
  void clear_frame_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id() const;
  void set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_frame_id() const;
  void _internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.parking.MapEngineResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Point3d > trajectory_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Turn > turn_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Slope > slope_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Semantic > semantic_;
  ::minieye::Planning* planning_;
  ::minieye::Point3d* mapping_triger_point_;
  ::perception::ParkingSlot* target_parking_slot_;
  ::minieye::Pose6d* mapping_end_pose_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tick_;
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_map_5fengine_5fresponse_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MapEngineResponse_Turn

// .minieye.Point3d turn_start = 1;
inline bool MapEngineResponse_Turn::_internal_has_turn_start() const {
  return this != internal_default_instance() && turn_start_ != nullptr;
}
inline bool MapEngineResponse_Turn::has_turn_start() const {
  return _internal_has_turn_start();
}
inline const ::minieye::Point3d& MapEngineResponse_Turn::_internal_turn_start() const {
  const ::minieye::Point3d* p = turn_start_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::Point3d*>(
      &::minieye::_Point3d_default_instance_);
}
inline const ::minieye::Point3d& MapEngineResponse_Turn::turn_start() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.Turn.turn_start)
  return _internal_turn_start();
}
inline void MapEngineResponse_Turn::unsafe_arena_set_allocated_turn_start(
    ::minieye::Point3d* turn_start) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(turn_start_);
  }
  turn_start_ = turn_start;
  if (turn_start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.parking.MapEngineResponse.Turn.turn_start)
}
inline ::minieye::Point3d* MapEngineResponse_Turn::release_turn_start() {
  auto temp = unsafe_arena_release_turn_start();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::Point3d* MapEngineResponse_Turn::unsafe_arena_release_turn_start() {
  // @@protoc_insertion_point(field_release:minieye.parking.MapEngineResponse.Turn.turn_start)
  
  ::minieye::Point3d* temp = turn_start_;
  turn_start_ = nullptr;
  return temp;
}
inline ::minieye::Point3d* MapEngineResponse_Turn::_internal_mutable_turn_start() {
  
  if (turn_start_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::Point3d>(GetArena());
    turn_start_ = p;
  }
  return turn_start_;
}
inline ::minieye::Point3d* MapEngineResponse_Turn::mutable_turn_start() {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.Turn.turn_start)
  return _internal_mutable_turn_start();
}
inline void MapEngineResponse_Turn::set_allocated_turn_start(::minieye::Point3d* turn_start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(turn_start_);
  }
  if (turn_start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(turn_start)->GetArena();
    if (message_arena != submessage_arena) {
      turn_start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn_start, submessage_arena);
    }
    
  } else {
    
  }
  turn_start_ = turn_start;
  // @@protoc_insertion_point(field_set_allocated:minieye.parking.MapEngineResponse.Turn.turn_start)
}

// .minieye.Point3d turn_end = 2;
inline bool MapEngineResponse_Turn::_internal_has_turn_end() const {
  return this != internal_default_instance() && turn_end_ != nullptr;
}
inline bool MapEngineResponse_Turn::has_turn_end() const {
  return _internal_has_turn_end();
}
inline const ::minieye::Point3d& MapEngineResponse_Turn::_internal_turn_end() const {
  const ::minieye::Point3d* p = turn_end_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::Point3d*>(
      &::minieye::_Point3d_default_instance_);
}
inline const ::minieye::Point3d& MapEngineResponse_Turn::turn_end() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.Turn.turn_end)
  return _internal_turn_end();
}
inline void MapEngineResponse_Turn::unsafe_arena_set_allocated_turn_end(
    ::minieye::Point3d* turn_end) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(turn_end_);
  }
  turn_end_ = turn_end;
  if (turn_end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.parking.MapEngineResponse.Turn.turn_end)
}
inline ::minieye::Point3d* MapEngineResponse_Turn::release_turn_end() {
  auto temp = unsafe_arena_release_turn_end();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::Point3d* MapEngineResponse_Turn::unsafe_arena_release_turn_end() {
  // @@protoc_insertion_point(field_release:minieye.parking.MapEngineResponse.Turn.turn_end)
  
  ::minieye::Point3d* temp = turn_end_;
  turn_end_ = nullptr;
  return temp;
}
inline ::minieye::Point3d* MapEngineResponse_Turn::_internal_mutable_turn_end() {
  
  if (turn_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::Point3d>(GetArena());
    turn_end_ = p;
  }
  return turn_end_;
}
inline ::minieye::Point3d* MapEngineResponse_Turn::mutable_turn_end() {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.Turn.turn_end)
  return _internal_mutable_turn_end();
}
inline void MapEngineResponse_Turn::set_allocated_turn_end(::minieye::Point3d* turn_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(turn_end_);
  }
  if (turn_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(turn_end)->GetArena();
    if (message_arena != submessage_arena) {
      turn_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, turn_end, submessage_arena);
    }
    
  } else {
    
  }
  turn_end_ = turn_end;
  // @@protoc_insertion_point(field_set_allocated:minieye.parking.MapEngineResponse.Turn.turn_end)
}

// .minieye.parking.MapEngineResponse.Turn.TurnType true_type = 3;
inline void MapEngineResponse_Turn::clear_true_type() {
  true_type_ = 0;
}
inline ::minieye::parking::MapEngineResponse_Turn_TurnType MapEngineResponse_Turn::_internal_true_type() const {
  return static_cast< ::minieye::parking::MapEngineResponse_Turn_TurnType >(true_type_);
}
inline ::minieye::parking::MapEngineResponse_Turn_TurnType MapEngineResponse_Turn::true_type() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.Turn.true_type)
  return _internal_true_type();
}
inline void MapEngineResponse_Turn::_internal_set_true_type(::minieye::parking::MapEngineResponse_Turn_TurnType value) {
  
  true_type_ = value;
}
inline void MapEngineResponse_Turn::set_true_type(::minieye::parking::MapEngineResponse_Turn_TurnType value) {
  _internal_set_true_type(value);
  // @@protoc_insertion_point(field_set:minieye.parking.MapEngineResponse.Turn.true_type)
}

// -------------------------------------------------------------------

// MapEngineResponse_Slope

// .minieye.Point3d slope_start = 1;
inline bool MapEngineResponse_Slope::_internal_has_slope_start() const {
  return this != internal_default_instance() && slope_start_ != nullptr;
}
inline bool MapEngineResponse_Slope::has_slope_start() const {
  return _internal_has_slope_start();
}
inline const ::minieye::Point3d& MapEngineResponse_Slope::_internal_slope_start() const {
  const ::minieye::Point3d* p = slope_start_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::Point3d*>(
      &::minieye::_Point3d_default_instance_);
}
inline const ::minieye::Point3d& MapEngineResponse_Slope::slope_start() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.Slope.slope_start)
  return _internal_slope_start();
}
inline void MapEngineResponse_Slope::unsafe_arena_set_allocated_slope_start(
    ::minieye::Point3d* slope_start) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slope_start_);
  }
  slope_start_ = slope_start;
  if (slope_start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.parking.MapEngineResponse.Slope.slope_start)
}
inline ::minieye::Point3d* MapEngineResponse_Slope::release_slope_start() {
  auto temp = unsafe_arena_release_slope_start();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::Point3d* MapEngineResponse_Slope::unsafe_arena_release_slope_start() {
  // @@protoc_insertion_point(field_release:minieye.parking.MapEngineResponse.Slope.slope_start)
  
  ::minieye::Point3d* temp = slope_start_;
  slope_start_ = nullptr;
  return temp;
}
inline ::minieye::Point3d* MapEngineResponse_Slope::_internal_mutable_slope_start() {
  
  if (slope_start_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::Point3d>(GetArena());
    slope_start_ = p;
  }
  return slope_start_;
}
inline ::minieye::Point3d* MapEngineResponse_Slope::mutable_slope_start() {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.Slope.slope_start)
  return _internal_mutable_slope_start();
}
inline void MapEngineResponse_Slope::set_allocated_slope_start(::minieye::Point3d* slope_start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(slope_start_);
  }
  if (slope_start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slope_start)->GetArena();
    if (message_arena != submessage_arena) {
      slope_start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slope_start, submessage_arena);
    }
    
  } else {
    
  }
  slope_start_ = slope_start;
  // @@protoc_insertion_point(field_set_allocated:minieye.parking.MapEngineResponse.Slope.slope_start)
}

// .minieye.Point3d slope_end = 2;
inline bool MapEngineResponse_Slope::_internal_has_slope_end() const {
  return this != internal_default_instance() && slope_end_ != nullptr;
}
inline bool MapEngineResponse_Slope::has_slope_end() const {
  return _internal_has_slope_end();
}
inline const ::minieye::Point3d& MapEngineResponse_Slope::_internal_slope_end() const {
  const ::minieye::Point3d* p = slope_end_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::Point3d*>(
      &::minieye::_Point3d_default_instance_);
}
inline const ::minieye::Point3d& MapEngineResponse_Slope::slope_end() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.Slope.slope_end)
  return _internal_slope_end();
}
inline void MapEngineResponse_Slope::unsafe_arena_set_allocated_slope_end(
    ::minieye::Point3d* slope_end) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slope_end_);
  }
  slope_end_ = slope_end;
  if (slope_end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.parking.MapEngineResponse.Slope.slope_end)
}
inline ::minieye::Point3d* MapEngineResponse_Slope::release_slope_end() {
  auto temp = unsafe_arena_release_slope_end();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::Point3d* MapEngineResponse_Slope::unsafe_arena_release_slope_end() {
  // @@protoc_insertion_point(field_release:minieye.parking.MapEngineResponse.Slope.slope_end)
  
  ::minieye::Point3d* temp = slope_end_;
  slope_end_ = nullptr;
  return temp;
}
inline ::minieye::Point3d* MapEngineResponse_Slope::_internal_mutable_slope_end() {
  
  if (slope_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::Point3d>(GetArena());
    slope_end_ = p;
  }
  return slope_end_;
}
inline ::minieye::Point3d* MapEngineResponse_Slope::mutable_slope_end() {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.Slope.slope_end)
  return _internal_mutable_slope_end();
}
inline void MapEngineResponse_Slope::set_allocated_slope_end(::minieye::Point3d* slope_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(slope_end_);
  }
  if (slope_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slope_end)->GetArena();
    if (message_arena != submessage_arena) {
      slope_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slope_end, submessage_arena);
    }
    
  } else {
    
  }
  slope_end_ = slope_end;
  // @@protoc_insertion_point(field_set_allocated:minieye.parking.MapEngineResponse.Slope.slope_end)
}

// .minieye.parking.MapEngineResponse.Slope.SlopeType slope_type = 3;
inline void MapEngineResponse_Slope::clear_slope_type() {
  slope_type_ = 0;
}
inline ::minieye::parking::MapEngineResponse_Slope_SlopeType MapEngineResponse_Slope::_internal_slope_type() const {
  return static_cast< ::minieye::parking::MapEngineResponse_Slope_SlopeType >(slope_type_);
}
inline ::minieye::parking::MapEngineResponse_Slope_SlopeType MapEngineResponse_Slope::slope_type() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.Slope.slope_type)
  return _internal_slope_type();
}
inline void MapEngineResponse_Slope::_internal_set_slope_type(::minieye::parking::MapEngineResponse_Slope_SlopeType value) {
  
  slope_type_ = value;
}
inline void MapEngineResponse_Slope::set_slope_type(::minieye::parking::MapEngineResponse_Slope_SlopeType value) {
  _internal_set_slope_type(value);
  // @@protoc_insertion_point(field_set:minieye.parking.MapEngineResponse.Slope.slope_type)
}

// -------------------------------------------------------------------

// MapEngineResponse_Semantic

// .minieye.parking.MapEngineResponse.Semantic.SemanticType semantic_type = 1;
inline void MapEngineResponse_Semantic::clear_semantic_type() {
  semantic_type_ = 0;
}
inline ::minieye::parking::MapEngineResponse_Semantic_SemanticType MapEngineResponse_Semantic::_internal_semantic_type() const {
  return static_cast< ::minieye::parking::MapEngineResponse_Semantic_SemanticType >(semantic_type_);
}
inline ::minieye::parking::MapEngineResponse_Semantic_SemanticType MapEngineResponse_Semantic::semantic_type() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.Semantic.semantic_type)
  return _internal_semantic_type();
}
inline void MapEngineResponse_Semantic::_internal_set_semantic_type(::minieye::parking::MapEngineResponse_Semantic_SemanticType value) {
  
  semantic_type_ = value;
}
inline void MapEngineResponse_Semantic::set_semantic_type(::minieye::parking::MapEngineResponse_Semantic_SemanticType value) {
  _internal_set_semantic_type(value);
  // @@protoc_insertion_point(field_set:minieye.parking.MapEngineResponse.Semantic.semantic_type)
}

// repeated .minieye.Point3d contour_points = 2;
inline int MapEngineResponse_Semantic::_internal_contour_points_size() const {
  return contour_points_.size();
}
inline int MapEngineResponse_Semantic::contour_points_size() const {
  return _internal_contour_points_size();
}
inline ::minieye::Point3d* MapEngineResponse_Semantic::mutable_contour_points(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.Semantic.contour_points)
  return contour_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Point3d >*
MapEngineResponse_Semantic::mutable_contour_points() {
  // @@protoc_insertion_point(field_mutable_list:minieye.parking.MapEngineResponse.Semantic.contour_points)
  return &contour_points_;
}
inline const ::minieye::Point3d& MapEngineResponse_Semantic::_internal_contour_points(int index) const {
  return contour_points_.Get(index);
}
inline const ::minieye::Point3d& MapEngineResponse_Semantic::contour_points(int index) const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.Semantic.contour_points)
  return _internal_contour_points(index);
}
inline ::minieye::Point3d* MapEngineResponse_Semantic::_internal_add_contour_points() {
  return contour_points_.Add();
}
inline ::minieye::Point3d* MapEngineResponse_Semantic::add_contour_points() {
  // @@protoc_insertion_point(field_add:minieye.parking.MapEngineResponse.Semantic.contour_points)
  return _internal_add_contour_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Point3d >&
MapEngineResponse_Semantic::contour_points() const {
  // @@protoc_insertion_point(field_list:minieye.parking.MapEngineResponse.Semantic.contour_points)
  return contour_points_;
}

// -------------------------------------------------------------------

// MapEngineResponse

// uint64 timestamp = 1;
inline void MapEngineResponse::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MapEngineResponse::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MapEngineResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.timestamp)
  return _internal_timestamp();
}
inline void MapEngineResponse::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void MapEngineResponse::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:minieye.parking.MapEngineResponse.timestamp)
}

// uint64 tick = 2;
inline void MapEngineResponse::clear_tick() {
  tick_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MapEngineResponse::_internal_tick() const {
  return tick_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MapEngineResponse::tick() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.tick)
  return _internal_tick();
}
inline void MapEngineResponse::_internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  tick_ = value;
}
inline void MapEngineResponse::set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:minieye.parking.MapEngineResponse.tick)
}

// uint64 frame_id = 3;
inline void MapEngineResponse::clear_frame_id() {
  frame_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MapEngineResponse::_internal_frame_id() const {
  return frame_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MapEngineResponse::frame_id() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.frame_id)
  return _internal_frame_id();
}
inline void MapEngineResponse::_internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  frame_id_ = value;
}
inline void MapEngineResponse::set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:minieye.parking.MapEngineResponse.frame_id)
}

// .minieye.Planning planning = 4;
inline bool MapEngineResponse::_internal_has_planning() const {
  return this != internal_default_instance() && planning_ != nullptr;
}
inline bool MapEngineResponse::has_planning() const {
  return _internal_has_planning();
}
inline const ::minieye::Planning& MapEngineResponse::_internal_planning() const {
  const ::minieye::Planning* p = planning_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::Planning*>(
      &::minieye::_Planning_default_instance_);
}
inline const ::minieye::Planning& MapEngineResponse::planning() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.planning)
  return _internal_planning();
}
inline void MapEngineResponse::unsafe_arena_set_allocated_planning(
    ::minieye::Planning* planning) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(planning_);
  }
  planning_ = planning;
  if (planning) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.parking.MapEngineResponse.planning)
}
inline ::minieye::Planning* MapEngineResponse::release_planning() {
  auto temp = unsafe_arena_release_planning();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::Planning* MapEngineResponse::unsafe_arena_release_planning() {
  // @@protoc_insertion_point(field_release:minieye.parking.MapEngineResponse.planning)
  
  ::minieye::Planning* temp = planning_;
  planning_ = nullptr;
  return temp;
}
inline ::minieye::Planning* MapEngineResponse::_internal_mutable_planning() {
  
  if (planning_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::Planning>(GetArena());
    planning_ = p;
  }
  return planning_;
}
inline ::minieye::Planning* MapEngineResponse::mutable_planning() {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.planning)
  return _internal_mutable_planning();
}
inline void MapEngineResponse::set_allocated_planning(::minieye::Planning* planning) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(planning_);
  }
  if (planning) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(planning)->GetArena();
    if (message_arena != submessage_arena) {
      planning = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, planning, submessage_arena);
    }
    
  } else {
    
  }
  planning_ = planning;
  // @@protoc_insertion_point(field_set_allocated:minieye.parking.MapEngineResponse.planning)
}

// .minieye.Point3d mapping_triger_point = 5;
inline bool MapEngineResponse::_internal_has_mapping_triger_point() const {
  return this != internal_default_instance() && mapping_triger_point_ != nullptr;
}
inline bool MapEngineResponse::has_mapping_triger_point() const {
  return _internal_has_mapping_triger_point();
}
inline const ::minieye::Point3d& MapEngineResponse::_internal_mapping_triger_point() const {
  const ::minieye::Point3d* p = mapping_triger_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::Point3d*>(
      &::minieye::_Point3d_default_instance_);
}
inline const ::minieye::Point3d& MapEngineResponse::mapping_triger_point() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.mapping_triger_point)
  return _internal_mapping_triger_point();
}
inline void MapEngineResponse::unsafe_arena_set_allocated_mapping_triger_point(
    ::minieye::Point3d* mapping_triger_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapping_triger_point_);
  }
  mapping_triger_point_ = mapping_triger_point;
  if (mapping_triger_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.parking.MapEngineResponse.mapping_triger_point)
}
inline ::minieye::Point3d* MapEngineResponse::release_mapping_triger_point() {
  auto temp = unsafe_arena_release_mapping_triger_point();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::Point3d* MapEngineResponse::unsafe_arena_release_mapping_triger_point() {
  // @@protoc_insertion_point(field_release:minieye.parking.MapEngineResponse.mapping_triger_point)
  
  ::minieye::Point3d* temp = mapping_triger_point_;
  mapping_triger_point_ = nullptr;
  return temp;
}
inline ::minieye::Point3d* MapEngineResponse::_internal_mutable_mapping_triger_point() {
  
  if (mapping_triger_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::Point3d>(GetArena());
    mapping_triger_point_ = p;
  }
  return mapping_triger_point_;
}
inline ::minieye::Point3d* MapEngineResponse::mutable_mapping_triger_point() {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.mapping_triger_point)
  return _internal_mutable_mapping_triger_point();
}
inline void MapEngineResponse::set_allocated_mapping_triger_point(::minieye::Point3d* mapping_triger_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapping_triger_point_);
  }
  if (mapping_triger_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapping_triger_point)->GetArena();
    if (message_arena != submessage_arena) {
      mapping_triger_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mapping_triger_point, submessage_arena);
    }
    
  } else {
    
  }
  mapping_triger_point_ = mapping_triger_point;
  // @@protoc_insertion_point(field_set_allocated:minieye.parking.MapEngineResponse.mapping_triger_point)
}

// repeated .minieye.Point3d trajectory = 6;
inline int MapEngineResponse::_internal_trajectory_size() const {
  return trajectory_.size();
}
inline int MapEngineResponse::trajectory_size() const {
  return _internal_trajectory_size();
}
inline ::minieye::Point3d* MapEngineResponse::mutable_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.trajectory)
  return trajectory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Point3d >*
MapEngineResponse::mutable_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:minieye.parking.MapEngineResponse.trajectory)
  return &trajectory_;
}
inline const ::minieye::Point3d& MapEngineResponse::_internal_trajectory(int index) const {
  return trajectory_.Get(index);
}
inline const ::minieye::Point3d& MapEngineResponse::trajectory(int index) const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.trajectory)
  return _internal_trajectory(index);
}
inline ::minieye::Point3d* MapEngineResponse::_internal_add_trajectory() {
  return trajectory_.Add();
}
inline ::minieye::Point3d* MapEngineResponse::add_trajectory() {
  // @@protoc_insertion_point(field_add:minieye.parking.MapEngineResponse.trajectory)
  return _internal_add_trajectory();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Point3d >&
MapEngineResponse::trajectory() const {
  // @@protoc_insertion_point(field_list:minieye.parking.MapEngineResponse.trajectory)
  return trajectory_;
}

// .perception.ParkingSlot target_parking_slot = 7;
inline bool MapEngineResponse::_internal_has_target_parking_slot() const {
  return this != internal_default_instance() && target_parking_slot_ != nullptr;
}
inline bool MapEngineResponse::has_target_parking_slot() const {
  return _internal_has_target_parking_slot();
}
inline const ::perception::ParkingSlot& MapEngineResponse::_internal_target_parking_slot() const {
  const ::perception::ParkingSlot* p = target_parking_slot_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::ParkingSlot*>(
      &::perception::_ParkingSlot_default_instance_);
}
inline const ::perception::ParkingSlot& MapEngineResponse::target_parking_slot() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.target_parking_slot)
  return _internal_target_parking_slot();
}
inline void MapEngineResponse::unsafe_arena_set_allocated_target_parking_slot(
    ::perception::ParkingSlot* target_parking_slot) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_parking_slot_);
  }
  target_parking_slot_ = target_parking_slot;
  if (target_parking_slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.parking.MapEngineResponse.target_parking_slot)
}
inline ::perception::ParkingSlot* MapEngineResponse::release_target_parking_slot() {
  auto temp = unsafe_arena_release_target_parking_slot();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::ParkingSlot* MapEngineResponse::unsafe_arena_release_target_parking_slot() {
  // @@protoc_insertion_point(field_release:minieye.parking.MapEngineResponse.target_parking_slot)
  
  ::perception::ParkingSlot* temp = target_parking_slot_;
  target_parking_slot_ = nullptr;
  return temp;
}
inline ::perception::ParkingSlot* MapEngineResponse::_internal_mutable_target_parking_slot() {
  
  if (target_parking_slot_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::ParkingSlot>(GetArena());
    target_parking_slot_ = p;
  }
  return target_parking_slot_;
}
inline ::perception::ParkingSlot* MapEngineResponse::mutable_target_parking_slot() {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.target_parking_slot)
  return _internal_mutable_target_parking_slot();
}
inline void MapEngineResponse::set_allocated_target_parking_slot(::perception::ParkingSlot* target_parking_slot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_parking_slot_);
  }
  if (target_parking_slot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_parking_slot)->GetArena();
    if (message_arena != submessage_arena) {
      target_parking_slot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_parking_slot, submessage_arena);
    }
    
  } else {
    
  }
  target_parking_slot_ = target_parking_slot;
  // @@protoc_insertion_point(field_set_allocated:minieye.parking.MapEngineResponse.target_parking_slot)
}

// repeated .minieye.parking.MapEngineResponse.Turn turn = 8;
inline int MapEngineResponse::_internal_turn_size() const {
  return turn_.size();
}
inline int MapEngineResponse::turn_size() const {
  return _internal_turn_size();
}
inline void MapEngineResponse::clear_turn() {
  turn_.Clear();
}
inline ::minieye::parking::MapEngineResponse_Turn* MapEngineResponse::mutable_turn(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.turn)
  return turn_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Turn >*
MapEngineResponse::mutable_turn() {
  // @@protoc_insertion_point(field_mutable_list:minieye.parking.MapEngineResponse.turn)
  return &turn_;
}
inline const ::minieye::parking::MapEngineResponse_Turn& MapEngineResponse::_internal_turn(int index) const {
  return turn_.Get(index);
}
inline const ::minieye::parking::MapEngineResponse_Turn& MapEngineResponse::turn(int index) const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.turn)
  return _internal_turn(index);
}
inline ::minieye::parking::MapEngineResponse_Turn* MapEngineResponse::_internal_add_turn() {
  return turn_.Add();
}
inline ::minieye::parking::MapEngineResponse_Turn* MapEngineResponse::add_turn() {
  // @@protoc_insertion_point(field_add:minieye.parking.MapEngineResponse.turn)
  return _internal_add_turn();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Turn >&
MapEngineResponse::turn() const {
  // @@protoc_insertion_point(field_list:minieye.parking.MapEngineResponse.turn)
  return turn_;
}

// repeated .minieye.parking.MapEngineResponse.Slope slope = 9;
inline int MapEngineResponse::_internal_slope_size() const {
  return slope_.size();
}
inline int MapEngineResponse::slope_size() const {
  return _internal_slope_size();
}
inline void MapEngineResponse::clear_slope() {
  slope_.Clear();
}
inline ::minieye::parking::MapEngineResponse_Slope* MapEngineResponse::mutable_slope(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.slope)
  return slope_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Slope >*
MapEngineResponse::mutable_slope() {
  // @@protoc_insertion_point(field_mutable_list:minieye.parking.MapEngineResponse.slope)
  return &slope_;
}
inline const ::minieye::parking::MapEngineResponse_Slope& MapEngineResponse::_internal_slope(int index) const {
  return slope_.Get(index);
}
inline const ::minieye::parking::MapEngineResponse_Slope& MapEngineResponse::slope(int index) const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.slope)
  return _internal_slope(index);
}
inline ::minieye::parking::MapEngineResponse_Slope* MapEngineResponse::_internal_add_slope() {
  return slope_.Add();
}
inline ::minieye::parking::MapEngineResponse_Slope* MapEngineResponse::add_slope() {
  // @@protoc_insertion_point(field_add:minieye.parking.MapEngineResponse.slope)
  return _internal_add_slope();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Slope >&
MapEngineResponse::slope() const {
  // @@protoc_insertion_point(field_list:minieye.parking.MapEngineResponse.slope)
  return slope_;
}

// repeated .minieye.parking.MapEngineResponse.Semantic semantic = 10;
inline int MapEngineResponse::_internal_semantic_size() const {
  return semantic_.size();
}
inline int MapEngineResponse::semantic_size() const {
  return _internal_semantic_size();
}
inline void MapEngineResponse::clear_semantic() {
  semantic_.Clear();
}
inline ::minieye::parking::MapEngineResponse_Semantic* MapEngineResponse::mutable_semantic(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.semantic)
  return semantic_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Semantic >*
MapEngineResponse::mutable_semantic() {
  // @@protoc_insertion_point(field_mutable_list:minieye.parking.MapEngineResponse.semantic)
  return &semantic_;
}
inline const ::minieye::parking::MapEngineResponse_Semantic& MapEngineResponse::_internal_semantic(int index) const {
  return semantic_.Get(index);
}
inline const ::minieye::parking::MapEngineResponse_Semantic& MapEngineResponse::semantic(int index) const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.semantic)
  return _internal_semantic(index);
}
inline ::minieye::parking::MapEngineResponse_Semantic* MapEngineResponse::_internal_add_semantic() {
  return semantic_.Add();
}
inline ::minieye::parking::MapEngineResponse_Semantic* MapEngineResponse::add_semantic() {
  // @@protoc_insertion_point(field_add:minieye.parking.MapEngineResponse.semantic)
  return _internal_add_semantic();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::parking::MapEngineResponse_Semantic >&
MapEngineResponse::semantic() const {
  // @@protoc_insertion_point(field_list:minieye.parking.MapEngineResponse.semantic)
  return semantic_;
}

// .minieye.Pose6d mapping_end_pose = 11;
inline bool MapEngineResponse::_internal_has_mapping_end_pose() const {
  return this != internal_default_instance() && mapping_end_pose_ != nullptr;
}
inline bool MapEngineResponse::has_mapping_end_pose() const {
  return _internal_has_mapping_end_pose();
}
inline const ::minieye::Pose6d& MapEngineResponse::_internal_mapping_end_pose() const {
  const ::minieye::Pose6d* p = mapping_end_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::Pose6d*>(
      &::minieye::_Pose6d_default_instance_);
}
inline const ::minieye::Pose6d& MapEngineResponse::mapping_end_pose() const {
  // @@protoc_insertion_point(field_get:minieye.parking.MapEngineResponse.mapping_end_pose)
  return _internal_mapping_end_pose();
}
inline void MapEngineResponse::unsafe_arena_set_allocated_mapping_end_pose(
    ::minieye::Pose6d* mapping_end_pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapping_end_pose_);
  }
  mapping_end_pose_ = mapping_end_pose;
  if (mapping_end_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.parking.MapEngineResponse.mapping_end_pose)
}
inline ::minieye::Pose6d* MapEngineResponse::release_mapping_end_pose() {
  auto temp = unsafe_arena_release_mapping_end_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::Pose6d* MapEngineResponse::unsafe_arena_release_mapping_end_pose() {
  // @@protoc_insertion_point(field_release:minieye.parking.MapEngineResponse.mapping_end_pose)
  
  ::minieye::Pose6d* temp = mapping_end_pose_;
  mapping_end_pose_ = nullptr;
  return temp;
}
inline ::minieye::Pose6d* MapEngineResponse::_internal_mutable_mapping_end_pose() {
  
  if (mapping_end_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::Pose6d>(GetArena());
    mapping_end_pose_ = p;
  }
  return mapping_end_pose_;
}
inline ::minieye::Pose6d* MapEngineResponse::mutable_mapping_end_pose() {
  // @@protoc_insertion_point(field_mutable:minieye.parking.MapEngineResponse.mapping_end_pose)
  return _internal_mutable_mapping_end_pose();
}
inline void MapEngineResponse::set_allocated_mapping_end_pose(::minieye::Pose6d* mapping_end_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapping_end_pose_);
  }
  if (mapping_end_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapping_end_pose)->GetArena();
    if (message_arena != submessage_arena) {
      mapping_end_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mapping_end_pose, submessage_arena);
    }
    
  } else {
    
  }
  mapping_end_pose_ = mapping_end_pose;
  // @@protoc_insertion_point(field_set_allocated:minieye.parking.MapEngineResponse.mapping_end_pose)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace parking
}  // namespace minieye

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::minieye::parking::MapEngineResponse_Turn_TurnType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::parking::MapEngineResponse_Turn_TurnType>() {
  return ::minieye::parking::MapEngineResponse_Turn_TurnType_descriptor();
}
template <> struct is_proto_enum< ::minieye::parking::MapEngineResponse_Slope_SlopeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::parking::MapEngineResponse_Slope_SlopeType>() {
  return ::minieye::parking::MapEngineResponse_Slope_SlopeType_descriptor();
}
template <> struct is_proto_enum< ::minieye::parking::MapEngineResponse_Semantic_SemanticType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::parking::MapEngineResponse_Semantic_SemanticType>() {
  return ::minieye::parking::MapEngineResponse_Semantic_SemanticType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_map_5fengine_5fresponse_2eproto
