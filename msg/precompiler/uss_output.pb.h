// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: uss_output.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_uss_5foutput_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_uss_5foutput_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_uss_5foutput_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_uss_5foutput_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_uss_5foutput_2eproto;
namespace minieye {
class CornerPt;
class CornerPtDefaultTypeInternal;
extern CornerPtDefaultTypeInternal _CornerPt_default_instance_;
class Emap;
class EmapDefaultTypeInternal;
extern EmapDefaultTypeInternal _Emap_default_instance_;
class Obstacle;
class ObstacleDefaultTypeInternal;
extern ObstacleDefaultTypeInternal _Obstacle_default_instance_;
class Point2D;
class Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class UssOutput;
class UssOutputDefaultTypeInternal;
extern UssOutputDefaultTypeInternal _UssOutput_default_instance_;
class UssOutputList;
class UssOutputListDefaultTypeInternal;
extern UssOutputListDefaultTypeInternal _UssOutputList_default_instance_;
class UssParkingSlot;
class UssParkingSlotDefaultTypeInternal;
extern UssParkingSlotDefaultTypeInternal _UssParkingSlot_default_instance_;
}  // namespace minieye
PROTOBUF_NAMESPACE_OPEN
template<> ::minieye::CornerPt* Arena::CreateMaybeMessage<::minieye::CornerPt>(Arena*);
template<> ::minieye::Emap* Arena::CreateMaybeMessage<::minieye::Emap>(Arena*);
template<> ::minieye::Obstacle* Arena::CreateMaybeMessage<::minieye::Obstacle>(Arena*);
template<> ::minieye::Point2D* Arena::CreateMaybeMessage<::minieye::Point2D>(Arena*);
template<> ::minieye::UssOutput* Arena::CreateMaybeMessage<::minieye::UssOutput>(Arena*);
template<> ::minieye::UssOutputList* Arena::CreateMaybeMessage<::minieye::UssOutputList>(Arena*);
template<> ::minieye::UssParkingSlot* Arena::CreateMaybeMessage<::minieye::UssParkingSlot>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace minieye {

enum UssParkingSlot_SlotType : int {
  UssParkingSlot_SlotType_kUnknown = 0,
  UssParkingSlot_SlotType_kVertical = 1,
  UssParkingSlot_SlotType_KParallel = 2,
  UssParkingSlot_SlotType_KDiamond = 3,
  UssParkingSlot_SlotType_UssParkingSlot_SlotType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UssParkingSlot_SlotType_UssParkingSlot_SlotType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UssParkingSlot_SlotType_IsValid(int value);
constexpr UssParkingSlot_SlotType UssParkingSlot_SlotType_SlotType_MIN = UssParkingSlot_SlotType_kUnknown;
constexpr UssParkingSlot_SlotType UssParkingSlot_SlotType_SlotType_MAX = UssParkingSlot_SlotType_KDiamond;
constexpr int UssParkingSlot_SlotType_SlotType_ARRAYSIZE = UssParkingSlot_SlotType_SlotType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UssParkingSlot_SlotType_descriptor();
template<typename T>
inline const std::string& UssParkingSlot_SlotType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UssParkingSlot_SlotType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UssParkingSlot_SlotType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UssParkingSlot_SlotType_descriptor(), enum_t_value);
}
inline bool UssParkingSlot_SlotType_Parse(
    const std::string& name, UssParkingSlot_SlotType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UssParkingSlot_SlotType>(
    UssParkingSlot_SlotType_descriptor(), name, value);
}
enum UssParkingSlot_ParkingStage : int {
  UssParkingSlot_ParkingStage_kPsDefault = 0,
  UssParkingSlot_ParkingStage_kPsDiscontent = 1,
  UssParkingSlot_ParkingStage_kPsOutside = 2,
  UssParkingSlot_ParkingStage_kPsInside = 3,
  UssParkingSlot_ParkingStage_KInsideContinuously = 4,
  UssParkingSlot_ParkingStage_UssParkingSlot_ParkingStage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UssParkingSlot_ParkingStage_UssParkingSlot_ParkingStage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UssParkingSlot_ParkingStage_IsValid(int value);
constexpr UssParkingSlot_ParkingStage UssParkingSlot_ParkingStage_ParkingStage_MIN = UssParkingSlot_ParkingStage_kPsDefault;
constexpr UssParkingSlot_ParkingStage UssParkingSlot_ParkingStage_ParkingStage_MAX = UssParkingSlot_ParkingStage_KInsideContinuously;
constexpr int UssParkingSlot_ParkingStage_ParkingStage_ARRAYSIZE = UssParkingSlot_ParkingStage_ParkingStage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UssParkingSlot_ParkingStage_descriptor();
template<typename T>
inline const std::string& UssParkingSlot_ParkingStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UssParkingSlot_ParkingStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UssParkingSlot_ParkingStage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UssParkingSlot_ParkingStage_descriptor(), enum_t_value);
}
inline bool UssParkingSlot_ParkingStage_Parse(
    const std::string& name, UssParkingSlot_ParkingStage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UssParkingSlot_ParkingStage>(
    UssParkingSlot_ParkingStage_descriptor(), name, value);
}
enum Emap_EMapConfidence : int {
  Emap_EMapConfidence_kEMCDegreeNull = 0,
  Emap_EMapConfidence_kEMCDegreeLow = 1,
  Emap_EMapConfidence_kEMCDegreeFuzzy = 2,
  Emap_EMapConfidence_kEMCDegreeHigh = 3,
  Emap_EMapConfidence_Emap_EMapConfidence_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Emap_EMapConfidence_Emap_EMapConfidence_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Emap_EMapConfidence_IsValid(int value);
constexpr Emap_EMapConfidence Emap_EMapConfidence_EMapConfidence_MIN = Emap_EMapConfidence_kEMCDegreeNull;
constexpr Emap_EMapConfidence Emap_EMapConfidence_EMapConfidence_MAX = Emap_EMapConfidence_kEMCDegreeHigh;
constexpr int Emap_EMapConfidence_EMapConfidence_ARRAYSIZE = Emap_EMapConfidence_EMapConfidence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Emap_EMapConfidence_descriptor();
template<typename T>
inline const std::string& Emap_EMapConfidence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Emap_EMapConfidence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Emap_EMapConfidence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Emap_EMapConfidence_descriptor(), enum_t_value);
}
inline bool Emap_EMapConfidence_Parse(
    const std::string& name, Emap_EMapConfidence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Emap_EMapConfidence>(
    Emap_EMapConfidence_descriptor(), name, value);
}
enum ObstacleType : int {
  kNone = 0,
  kPoint = 1,
  kSegment = 2,
  ObstacleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ObstacleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ObstacleType_IsValid(int value);
constexpr ObstacleType ObstacleType_MIN = kNone;
constexpr ObstacleType ObstacleType_MAX = kSegment;
constexpr int ObstacleType_ARRAYSIZE = ObstacleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObstacleType_descriptor();
template<typename T>
inline const std::string& ObstacleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObstacleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObstacleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObstacleType_descriptor(), enum_t_value);
}
inline bool ObstacleType_Parse(
    const std::string& name, ObstacleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObstacleType>(
    ObstacleType_descriptor(), name, value);
}
enum TriangleType : int {
  kTriangleRS_R = 0,
  kTriangleR_RM = 1,
  kTriangleRM_LM = 2,
  kTriangleLM_L = 3,
  kTriangleL_LS = 4,
  TriangleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TriangleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TriangleType_IsValid(int value);
constexpr TriangleType TriangleType_MIN = kTriangleRS_R;
constexpr TriangleType TriangleType_MAX = kTriangleL_LS;
constexpr int TriangleType_ARRAYSIZE = TriangleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TriangleType_descriptor();
template<typename T>
inline const std::string& TriangleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TriangleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TriangleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TriangleType_descriptor(), enum_t_value);
}
inline bool TriangleType_Parse(
    const std::string& name, TriangleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TriangleType>(
    TriangleType_descriptor(), name, value);
}
// ===================================================================

class Point2D PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.Point2D) */ {
 public:
  inline Point2D() : Point2D(nullptr) {};
  virtual ~Point2D();

  Point2D(const Point2D& from);
  Point2D(Point2D&& from) noexcept
    : Point2D() {
    *this = ::std::move(from);
  }

  inline Point2D& operator=(const Point2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point2D& operator=(Point2D&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Point2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point2D* internal_default_instance() {
    return reinterpret_cast<const Point2D*>(
               &_Point2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Point2D& a, Point2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Point2D* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Point2D* New() const final {
    return CreateMaybeMessage<Point2D>(nullptr);
  }

  Point2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Point2D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Point2D& from);
  void MergeFrom(const Point2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.Point2D";
  }
  protected:
  explicit Point2D(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_uss_5foutput_2eproto);
    return ::descriptor_table_uss_5foutput_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.Point2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uss_5foutput_2eproto;
};
// -------------------------------------------------------------------

class CornerPt PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.CornerPt) */ {
 public:
  inline CornerPt() : CornerPt(nullptr) {};
  virtual ~CornerPt();

  CornerPt(const CornerPt& from);
  CornerPt(CornerPt&& from) noexcept
    : CornerPt() {
    *this = ::std::move(from);
  }

  inline CornerPt& operator=(const CornerPt& from) {
    CopyFrom(from);
    return *this;
  }
  inline CornerPt& operator=(CornerPt&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CornerPt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CornerPt* internal_default_instance() {
    return reinterpret_cast<const CornerPt*>(
               &_CornerPt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CornerPt& a, CornerPt& b) {
    a.Swap(&b);
  }
  inline void Swap(CornerPt* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CornerPt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CornerPt* New() const final {
    return CreateMaybeMessage<CornerPt>(nullptr);
  }

  CornerPt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CornerPt>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CornerPt& from);
  void MergeFrom(const CornerPt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CornerPt* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.CornerPt";
  }
  protected:
  explicit CornerPt(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_uss_5foutput_2eproto);
    return ::descriptor_table_uss_5foutput_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehiclePtFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // .minieye.Point2D vehicle_pt = 2;
  bool has_vehicle_pt() const;
  private:
  bool _internal_has_vehicle_pt() const;
  public:
  void clear_vehicle_pt();
  const ::minieye::Point2D& vehicle_pt() const;
  ::minieye::Point2D* release_vehicle_pt();
  ::minieye::Point2D* mutable_vehicle_pt();
  void set_allocated_vehicle_pt(::minieye::Point2D* vehicle_pt);
  private:
  const ::minieye::Point2D& _internal_vehicle_pt() const;
  ::minieye::Point2D* _internal_mutable_vehicle_pt();
  public:
  void unsafe_arena_set_allocated_vehicle_pt(
      ::minieye::Point2D* vehicle_pt);
  ::minieye::Point2D* unsafe_arena_release_vehicle_pt();

  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.CornerPt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minieye::Point2D* vehicle_pt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uss_5foutput_2eproto;
};
// -------------------------------------------------------------------

class UssParkingSlot PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.UssParkingSlot) */ {
 public:
  inline UssParkingSlot() : UssParkingSlot(nullptr) {};
  virtual ~UssParkingSlot();

  UssParkingSlot(const UssParkingSlot& from);
  UssParkingSlot(UssParkingSlot&& from) noexcept
    : UssParkingSlot() {
    *this = ::std::move(from);
  }

  inline UssParkingSlot& operator=(const UssParkingSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline UssParkingSlot& operator=(UssParkingSlot&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UssParkingSlot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UssParkingSlot* internal_default_instance() {
    return reinterpret_cast<const UssParkingSlot*>(
               &_UssParkingSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UssParkingSlot& a, UssParkingSlot& b) {
    a.Swap(&b);
  }
  inline void Swap(UssParkingSlot* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UssParkingSlot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UssParkingSlot* New() const final {
    return CreateMaybeMessage<UssParkingSlot>(nullptr);
  }

  UssParkingSlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UssParkingSlot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UssParkingSlot& from);
  void MergeFrom(const UssParkingSlot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UssParkingSlot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.UssParkingSlot";
  }
  protected:
  explicit UssParkingSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_uss_5foutput_2eproto);
    return ::descriptor_table_uss_5foutput_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UssParkingSlot_SlotType SlotType;
  static constexpr SlotType kUnknown =
    UssParkingSlot_SlotType_kUnknown;
  static constexpr SlotType kVertical =
    UssParkingSlot_SlotType_kVertical;
  static constexpr SlotType KParallel =
    UssParkingSlot_SlotType_KParallel;
  static constexpr SlotType KDiamond =
    UssParkingSlot_SlotType_KDiamond;
  static inline bool SlotType_IsValid(int value) {
    return UssParkingSlot_SlotType_IsValid(value);
  }
  static constexpr SlotType SlotType_MIN =
    UssParkingSlot_SlotType_SlotType_MIN;
  static constexpr SlotType SlotType_MAX =
    UssParkingSlot_SlotType_SlotType_MAX;
  static constexpr int SlotType_ARRAYSIZE =
    UssParkingSlot_SlotType_SlotType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SlotType_descriptor() {
    return UssParkingSlot_SlotType_descriptor();
  }
  template<typename T>
  static inline const std::string& SlotType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SlotType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SlotType_Name.");
    return UssParkingSlot_SlotType_Name(enum_t_value);
  }
  static inline bool SlotType_Parse(const std::string& name,
      SlotType* value) {
    return UssParkingSlot_SlotType_Parse(name, value);
  }

  typedef UssParkingSlot_ParkingStage ParkingStage;
  static constexpr ParkingStage kPsDefault =
    UssParkingSlot_ParkingStage_kPsDefault;
  static constexpr ParkingStage kPsDiscontent =
    UssParkingSlot_ParkingStage_kPsDiscontent;
  static constexpr ParkingStage kPsOutside =
    UssParkingSlot_ParkingStage_kPsOutside;
  static constexpr ParkingStage kPsInside =
    UssParkingSlot_ParkingStage_kPsInside;
  static constexpr ParkingStage KInsideContinuously =
    UssParkingSlot_ParkingStage_KInsideContinuously;
  static inline bool ParkingStage_IsValid(int value) {
    return UssParkingSlot_ParkingStage_IsValid(value);
  }
  static constexpr ParkingStage ParkingStage_MIN =
    UssParkingSlot_ParkingStage_ParkingStage_MIN;
  static constexpr ParkingStage ParkingStage_MAX =
    UssParkingSlot_ParkingStage_ParkingStage_MAX;
  static constexpr int ParkingStage_ARRAYSIZE =
    UssParkingSlot_ParkingStage_ParkingStage_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ParkingStage_descriptor() {
    return UssParkingSlot_ParkingStage_descriptor();
  }
  template<typename T>
  static inline const std::string& ParkingStage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ParkingStage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ParkingStage_Name.");
    return UssParkingSlot_ParkingStage_Name(enum_t_value);
  }
  static inline bool ParkingStage_Parse(const std::string& name,
      ParkingStage* value) {
    return UssParkingSlot_ParkingStage_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCornerPtsFieldNumber = 6,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kWidthFieldNumber = 3,
    kLengthFieldNumber = 4,
    kParkingStageFieldNumber = 5,
    kIsLeftPsFieldNumber = 7,
    kSingleTickFieldNumber = 8,
  };
  // repeated .minieye.CornerPt corner_pts = 6;
  int corner_pts_size() const;
  private:
  int _internal_corner_pts_size() const;
  public:
  void clear_corner_pts();
  ::minieye::CornerPt* mutable_corner_pts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::CornerPt >*
      mutable_corner_pts();
  private:
  const ::minieye::CornerPt& _internal_corner_pts(int index) const;
  ::minieye::CornerPt* _internal_add_corner_pts();
  public:
  const ::minieye::CornerPt& corner_pts(int index) const;
  ::minieye::CornerPt* add_corner_pts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::CornerPt >&
      corner_pts() const;

  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .minieye.UssParkingSlot.SlotType type = 2;
  void clear_type();
  ::minieye::UssParkingSlot_SlotType type() const;
  void set_type(::minieye::UssParkingSlot_SlotType value);
  private:
  ::minieye::UssParkingSlot_SlotType _internal_type() const;
  void _internal_set_type(::minieye::UssParkingSlot_SlotType value);
  public:

  // double width = 3;
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // double length = 4;
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // .minieye.UssParkingSlot.ParkingStage parking_stage = 5;
  void clear_parking_stage();
  ::minieye::UssParkingSlot_ParkingStage parking_stage() const;
  void set_parking_stage(::minieye::UssParkingSlot_ParkingStage value);
  private:
  ::minieye::UssParkingSlot_ParkingStage _internal_parking_stage() const;
  void _internal_set_parking_stage(::minieye::UssParkingSlot_ParkingStage value);
  public:

  // bool is_left_ps = 7;
  void clear_is_left_ps();
  bool is_left_ps() const;
  void set_is_left_ps(bool value);
  private:
  bool _internal_is_left_ps() const;
  void _internal_set_is_left_ps(bool value);
  public:

  // uint64 single_tick = 8;
  void clear_single_tick();
  ::PROTOBUF_NAMESPACE_ID::uint64 single_tick() const;
  void set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_single_tick() const;
  void _internal_set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.UssParkingSlot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::CornerPt > corner_pts_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  int type_;
  double width_;
  double length_;
  int parking_stage_;
  bool is_left_ps_;
  ::PROTOBUF_NAMESPACE_ID::uint64 single_tick_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uss_5foutput_2eproto;
};
// -------------------------------------------------------------------

class Obstacle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.Obstacle) */ {
 public:
  inline Obstacle() : Obstacle(nullptr) {};
  virtual ~Obstacle();

  Obstacle(const Obstacle& from);
  Obstacle(Obstacle&& from) noexcept
    : Obstacle() {
    *this = ::std::move(from);
  }

  inline Obstacle& operator=(const Obstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Obstacle& operator=(Obstacle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Obstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Obstacle* internal_default_instance() {
    return reinterpret_cast<const Obstacle*>(
               &_Obstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Obstacle& a, Obstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(Obstacle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Obstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Obstacle* New() const final {
    return CreateMaybeMessage<Obstacle>(nullptr);
  }

  Obstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Obstacle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Obstacle& from);
  void MergeFrom(const Obstacle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Obstacle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.Obstacle";
  }
  protected:
  explicit Obstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_uss_5foutput_2eproto);
    return ::descriptor_table_uss_5foutput_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehPt0FieldNumber = 4,
    kVehPt1FieldNumber = 5,
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kScoreFieldNumber = 3,
    kTriangleTypeFieldNumber = 6,
    kSingleTickFieldNumber = 7,
  };
  // .minieye.Point2D vehPt0 = 4;
  bool has_vehpt0() const;
  private:
  bool _internal_has_vehpt0() const;
  public:
  void clear_vehpt0();
  const ::minieye::Point2D& vehpt0() const;
  ::minieye::Point2D* release_vehpt0();
  ::minieye::Point2D* mutable_vehpt0();
  void set_allocated_vehpt0(::minieye::Point2D* vehpt0);
  private:
  const ::minieye::Point2D& _internal_vehpt0() const;
  ::minieye::Point2D* _internal_mutable_vehpt0();
  public:
  void unsafe_arena_set_allocated_vehpt0(
      ::minieye::Point2D* vehpt0);
  ::minieye::Point2D* unsafe_arena_release_vehpt0();

  // .minieye.Point2D vehPt1 = 5;
  bool has_vehpt1() const;
  private:
  bool _internal_has_vehpt1() const;
  public:
  void clear_vehpt1();
  const ::minieye::Point2D& vehpt1() const;
  ::minieye::Point2D* release_vehpt1();
  ::minieye::Point2D* mutable_vehpt1();
  void set_allocated_vehpt1(::minieye::Point2D* vehpt1);
  private:
  const ::minieye::Point2D& _internal_vehpt1() const;
  ::minieye::Point2D* _internal_mutable_vehpt1();
  public:
  void unsafe_arena_set_allocated_vehpt1(
      ::minieye::Point2D* vehpt1);
  ::minieye::Point2D* unsafe_arena_release_vehpt1();

  // .minieye.ObstacleType type = 1;
  void clear_type();
  ::minieye::ObstacleType type() const;
  void set_type(::minieye::ObstacleType value);
  private:
  ::minieye::ObstacleType _internal_type() const;
  void _internal_set_type(::minieye::ObstacleType value);
  public:

  // uint32 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float score = 3;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // .minieye.TriangleType triangle_type = 6;
  void clear_triangle_type();
  ::minieye::TriangleType triangle_type() const;
  void set_triangle_type(::minieye::TriangleType value);
  private:
  ::minieye::TriangleType _internal_triangle_type() const;
  void _internal_set_triangle_type(::minieye::TriangleType value);
  public:

  // uint64 single_tick = 7;
  void clear_single_tick();
  ::PROTOBUF_NAMESPACE_ID::uint64 single_tick() const;
  void set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_single_tick() const;
  void _internal_set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.Obstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minieye::Point2D* vehpt0_;
  ::minieye::Point2D* vehpt1_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  float score_;
  int triangle_type_;
  ::PROTOBUF_NAMESPACE_ID::uint64 single_tick_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uss_5foutput_2eproto;
};
// -------------------------------------------------------------------

class Emap PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.Emap) */ {
 public:
  inline Emap() : Emap(nullptr) {};
  virtual ~Emap();

  Emap(const Emap& from);
  Emap(Emap&& from) noexcept
    : Emap() {
    *this = ::std::move(from);
  }

  inline Emap& operator=(const Emap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Emap& operator=(Emap&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Emap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emap* internal_default_instance() {
    return reinterpret_cast<const Emap*>(
               &_Emap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Emap& a, Emap& b) {
    a.Swap(&b);
  }
  inline void Swap(Emap* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Emap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Emap* New() const final {
    return CreateMaybeMessage<Emap>(nullptr);
  }

  Emap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Emap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Emap& from);
  void MergeFrom(const Emap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.Emap";
  }
  protected:
  explicit Emap(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_uss_5foutput_2eproto);
    return ::descriptor_table_uss_5foutput_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Emap_EMapConfidence EMapConfidence;
  static constexpr EMapConfidence kEMCDegreeNull =
    Emap_EMapConfidence_kEMCDegreeNull;
  static constexpr EMapConfidence kEMCDegreeLow =
    Emap_EMapConfidence_kEMCDegreeLow;
  static constexpr EMapConfidence kEMCDegreeFuzzy =
    Emap_EMapConfidence_kEMCDegreeFuzzy;
  static constexpr EMapConfidence kEMCDegreeHigh =
    Emap_EMapConfidence_kEMCDegreeHigh;
  static inline bool EMapConfidence_IsValid(int value) {
    return Emap_EMapConfidence_IsValid(value);
  }
  static constexpr EMapConfidence EMapConfidence_MIN =
    Emap_EMapConfidence_EMapConfidence_MIN;
  static constexpr EMapConfidence EMapConfidence_MAX =
    Emap_EMapConfidence_EMapConfidence_MAX;
  static constexpr int EMapConfidence_ARRAYSIZE =
    Emap_EMapConfidence_EMapConfidence_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EMapConfidence_descriptor() {
    return Emap_EMapConfidence_descriptor();
  }
  template<typename T>
  static inline const std::string& EMapConfidence_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EMapConfidence>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EMapConfidence_Name.");
    return Emap_EMapConfidence_Name(enum_t_value);
  }
  static inline bool EMapConfidence_Parse(const std::string& name,
      EMapConfidence* value) {
    return Emap_EMapConfidence_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVehPtFieldNumber = 3,
    kIdFieldNumber = 1,
    kNFieldNumber = 2,
    kSingleTickFieldNumber = 5,
    kIsLeftPointFieldNumber = 4,
  };
  // .minieye.Point2D vehPt = 3;
  bool has_vehpt() const;
  private:
  bool _internal_has_vehpt() const;
  public:
  void clear_vehpt();
  const ::minieye::Point2D& vehpt() const;
  ::minieye::Point2D* release_vehpt();
  ::minieye::Point2D* mutable_vehpt();
  void set_allocated_vehpt(::minieye::Point2D* vehpt);
  private:
  const ::minieye::Point2D& _internal_vehpt() const;
  ::minieye::Point2D* _internal_mutable_vehpt();
  public:
  void unsafe_arena_set_allocated_vehpt(
      ::minieye::Point2D* vehpt);
  ::minieye::Point2D* unsafe_arena_release_vehpt();

  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .minieye.Emap.EMapConfidence n = 2;
  void clear_n();
  ::minieye::Emap_EMapConfidence n() const;
  void set_n(::minieye::Emap_EMapConfidence value);
  private:
  ::minieye::Emap_EMapConfidence _internal_n() const;
  void _internal_set_n(::minieye::Emap_EMapConfidence value);
  public:

  // uint64 single_tick = 5;
  void clear_single_tick();
  ::PROTOBUF_NAMESPACE_ID::uint64 single_tick() const;
  void set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_single_tick() const;
  void _internal_set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool is_left_point = 4;
  void clear_is_left_point();
  bool is_left_point() const;
  void set_is_left_point(bool value);
  private:
  bool _internal_is_left_point() const;
  void _internal_set_is_left_point(bool value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.Emap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::minieye::Point2D* vehpt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  int n_;
  ::PROTOBUF_NAMESPACE_ID::uint64 single_tick_;
  bool is_left_point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uss_5foutput_2eproto;
};
// -------------------------------------------------------------------

class UssOutput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.UssOutput) */ {
 public:
  inline UssOutput() : UssOutput(nullptr) {};
  virtual ~UssOutput();

  UssOutput(const UssOutput& from);
  UssOutput(UssOutput&& from) noexcept
    : UssOutput() {
    *this = ::std::move(from);
  }

  inline UssOutput& operator=(const UssOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline UssOutput& operator=(UssOutput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UssOutput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UssOutput* internal_default_instance() {
    return reinterpret_cast<const UssOutput*>(
               &_UssOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UssOutput& a, UssOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(UssOutput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UssOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UssOutput* New() const final {
    return CreateMaybeMessage<UssOutput>(nullptr);
  }

  UssOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UssOutput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UssOutput& from);
  void MergeFrom(const UssOutput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UssOutput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.UssOutput";
  }
  protected:
  explicit UssOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_uss_5foutput_2eproto);
    return ::descriptor_table_uss_5foutput_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParkslotsFieldNumber = 4,
    kObstacleRectsFieldNumber = 5,
    kEmapFieldNumber = 6,
    kTimestampFieldNumber = 1,
    kFrameIdFieldNumber = 2,
    kTickFieldNumber = 3,
  };
  // repeated .minieye.UssParkingSlot parkslots = 4;
  int parkslots_size() const;
  private:
  int _internal_parkslots_size() const;
  public:
  void clear_parkslots();
  ::minieye::UssParkingSlot* mutable_parkslots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::UssParkingSlot >*
      mutable_parkslots();
  private:
  const ::minieye::UssParkingSlot& _internal_parkslots(int index) const;
  ::minieye::UssParkingSlot* _internal_add_parkslots();
  public:
  const ::minieye::UssParkingSlot& parkslots(int index) const;
  ::minieye::UssParkingSlot* add_parkslots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::UssParkingSlot >&
      parkslots() const;

  // repeated .minieye.Obstacle obstacle_rects = 5;
  int obstacle_rects_size() const;
  private:
  int _internal_obstacle_rects_size() const;
  public:
  void clear_obstacle_rects();
  ::minieye::Obstacle* mutable_obstacle_rects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Obstacle >*
      mutable_obstacle_rects();
  private:
  const ::minieye::Obstacle& _internal_obstacle_rects(int index) const;
  ::minieye::Obstacle* _internal_add_obstacle_rects();
  public:
  const ::minieye::Obstacle& obstacle_rects(int index) const;
  ::minieye::Obstacle* add_obstacle_rects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Obstacle >&
      obstacle_rects() const;

  // repeated .minieye.Emap emap = 6;
  int emap_size() const;
  private:
  int _internal_emap_size() const;
  public:
  void clear_emap();
  ::minieye::Emap* mutable_emap(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Emap >*
      mutable_emap();
  private:
  const ::minieye::Emap& _internal_emap(int index) const;
  ::minieye::Emap* _internal_add_emap();
  public:
  const ::minieye::Emap& emap(int index) const;
  ::minieye::Emap* add_emap();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Emap >&
      emap() const;

  // uint64 timestamp = 1;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 frame_id = 2;
  void clear_frame_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id() const;
  void set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_frame_id() const;
  void _internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 tick = 3;
  void clear_tick();
  ::PROTOBUF_NAMESPACE_ID::uint64 tick() const;
  void set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tick() const;
  void _internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.UssOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::UssParkingSlot > parkslots_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Obstacle > obstacle_rects_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Emap > emap_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tick_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uss_5foutput_2eproto;
};
// -------------------------------------------------------------------

class UssOutputList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.UssOutputList) */ {
 public:
  inline UssOutputList() : UssOutputList(nullptr) {};
  virtual ~UssOutputList();

  UssOutputList(const UssOutputList& from);
  UssOutputList(UssOutputList&& from) noexcept
    : UssOutputList() {
    *this = ::std::move(from);
  }

  inline UssOutputList& operator=(const UssOutputList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UssOutputList& operator=(UssOutputList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UssOutputList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UssOutputList* internal_default_instance() {
    return reinterpret_cast<const UssOutputList*>(
               &_UssOutputList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UssOutputList& a, UssOutputList& b) {
    a.Swap(&b);
  }
  inline void Swap(UssOutputList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UssOutputList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UssOutputList* New() const final {
    return CreateMaybeMessage<UssOutputList>(nullptr);
  }

  UssOutputList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UssOutputList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UssOutputList& from);
  void MergeFrom(const UssOutputList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UssOutputList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.UssOutputList";
  }
  protected:
  explicit UssOutputList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_uss_5foutput_2eproto);
    return ::descriptor_table_uss_5foutput_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUssOutputsFieldNumber = 2,
    kTickFieldNumber = 1,
  };
  // repeated .minieye.UssOutput uss_outputs = 2;
  int uss_outputs_size() const;
  private:
  int _internal_uss_outputs_size() const;
  public:
  void clear_uss_outputs();
  ::minieye::UssOutput* mutable_uss_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::UssOutput >*
      mutable_uss_outputs();
  private:
  const ::minieye::UssOutput& _internal_uss_outputs(int index) const;
  ::minieye::UssOutput* _internal_add_uss_outputs();
  public:
  const ::minieye::UssOutput& uss_outputs(int index) const;
  ::minieye::UssOutput* add_uss_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::UssOutput >&
      uss_outputs() const;

  // uint64 tick = 1;
  void clear_tick();
  ::PROTOBUF_NAMESPACE_ID::uint64 tick() const;
  void set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tick() const;
  void _internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.UssOutputList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::UssOutput > uss_outputs_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tick_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_uss_5foutput_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point2D

// float x = 1;
inline void Point2D::clear_x() {
  x_ = 0;
}
inline float Point2D::_internal_x() const {
  return x_;
}
inline float Point2D::x() const {
  // @@protoc_insertion_point(field_get:minieye.Point2D.x)
  return _internal_x();
}
inline void Point2D::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Point2D::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:minieye.Point2D.x)
}

// float y = 2;
inline void Point2D::clear_y() {
  y_ = 0;
}
inline float Point2D::_internal_y() const {
  return y_;
}
inline float Point2D::y() const {
  // @@protoc_insertion_point(field_get:minieye.Point2D.y)
  return _internal_y();
}
inline void Point2D::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Point2D::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:minieye.Point2D.y)
}

// -------------------------------------------------------------------

// CornerPt

// uint32 id = 1;
inline void CornerPt::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CornerPt::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CornerPt::id() const {
  // @@protoc_insertion_point(field_get:minieye.CornerPt.id)
  return _internal_id();
}
inline void CornerPt::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void CornerPt::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:minieye.CornerPt.id)
}

// .minieye.Point2D vehicle_pt = 2;
inline bool CornerPt::_internal_has_vehicle_pt() const {
  return this != internal_default_instance() && vehicle_pt_ != nullptr;
}
inline bool CornerPt::has_vehicle_pt() const {
  return _internal_has_vehicle_pt();
}
inline void CornerPt::clear_vehicle_pt() {
  if (GetArena() == nullptr && vehicle_pt_ != nullptr) {
    delete vehicle_pt_;
  }
  vehicle_pt_ = nullptr;
}
inline const ::minieye::Point2D& CornerPt::_internal_vehicle_pt() const {
  const ::minieye::Point2D* p = vehicle_pt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::Point2D*>(
      &::minieye::_Point2D_default_instance_);
}
inline const ::minieye::Point2D& CornerPt::vehicle_pt() const {
  // @@protoc_insertion_point(field_get:minieye.CornerPt.vehicle_pt)
  return _internal_vehicle_pt();
}
inline void CornerPt::unsafe_arena_set_allocated_vehicle_pt(
    ::minieye::Point2D* vehicle_pt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehicle_pt_);
  }
  vehicle_pt_ = vehicle_pt;
  if (vehicle_pt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.CornerPt.vehicle_pt)
}
inline ::minieye::Point2D* CornerPt::release_vehicle_pt() {
  auto temp = unsafe_arena_release_vehicle_pt();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::Point2D* CornerPt::unsafe_arena_release_vehicle_pt() {
  // @@protoc_insertion_point(field_release:minieye.CornerPt.vehicle_pt)
  
  ::minieye::Point2D* temp = vehicle_pt_;
  vehicle_pt_ = nullptr;
  return temp;
}
inline ::minieye::Point2D* CornerPt::_internal_mutable_vehicle_pt() {
  
  if (vehicle_pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::Point2D>(GetArena());
    vehicle_pt_ = p;
  }
  return vehicle_pt_;
}
inline ::minieye::Point2D* CornerPt::mutable_vehicle_pt() {
  // @@protoc_insertion_point(field_mutable:minieye.CornerPt.vehicle_pt)
  return _internal_mutable_vehicle_pt();
}
inline void CornerPt::set_allocated_vehicle_pt(::minieye::Point2D* vehicle_pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vehicle_pt_;
  }
  if (vehicle_pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vehicle_pt);
    if (message_arena != submessage_arena) {
      vehicle_pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehicle_pt, submessage_arena);
    }
    
  } else {
    
  }
  vehicle_pt_ = vehicle_pt;
  // @@protoc_insertion_point(field_set_allocated:minieye.CornerPt.vehicle_pt)
}

// -------------------------------------------------------------------

// UssParkingSlot

// uint32 id = 1;
inline void UssParkingSlot::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UssParkingSlot::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UssParkingSlot::id() const {
  // @@protoc_insertion_point(field_get:minieye.UssParkingSlot.id)
  return _internal_id();
}
inline void UssParkingSlot::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void UssParkingSlot::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:minieye.UssParkingSlot.id)
}

// .minieye.UssParkingSlot.SlotType type = 2;
inline void UssParkingSlot::clear_type() {
  type_ = 0;
}
inline ::minieye::UssParkingSlot_SlotType UssParkingSlot::_internal_type() const {
  return static_cast< ::minieye::UssParkingSlot_SlotType >(type_);
}
inline ::minieye::UssParkingSlot_SlotType UssParkingSlot::type() const {
  // @@protoc_insertion_point(field_get:minieye.UssParkingSlot.type)
  return _internal_type();
}
inline void UssParkingSlot::_internal_set_type(::minieye::UssParkingSlot_SlotType value) {
  
  type_ = value;
}
inline void UssParkingSlot::set_type(::minieye::UssParkingSlot_SlotType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:minieye.UssParkingSlot.type)
}

// double width = 3;
inline void UssParkingSlot::clear_width() {
  width_ = 0;
}
inline double UssParkingSlot::_internal_width() const {
  return width_;
}
inline double UssParkingSlot::width() const {
  // @@protoc_insertion_point(field_get:minieye.UssParkingSlot.width)
  return _internal_width();
}
inline void UssParkingSlot::_internal_set_width(double value) {
  
  width_ = value;
}
inline void UssParkingSlot::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:minieye.UssParkingSlot.width)
}

// double length = 4;
inline void UssParkingSlot::clear_length() {
  length_ = 0;
}
inline double UssParkingSlot::_internal_length() const {
  return length_;
}
inline double UssParkingSlot::length() const {
  // @@protoc_insertion_point(field_get:minieye.UssParkingSlot.length)
  return _internal_length();
}
inline void UssParkingSlot::_internal_set_length(double value) {
  
  length_ = value;
}
inline void UssParkingSlot::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:minieye.UssParkingSlot.length)
}

// .minieye.UssParkingSlot.ParkingStage parking_stage = 5;
inline void UssParkingSlot::clear_parking_stage() {
  parking_stage_ = 0;
}
inline ::minieye::UssParkingSlot_ParkingStage UssParkingSlot::_internal_parking_stage() const {
  return static_cast< ::minieye::UssParkingSlot_ParkingStage >(parking_stage_);
}
inline ::minieye::UssParkingSlot_ParkingStage UssParkingSlot::parking_stage() const {
  // @@protoc_insertion_point(field_get:minieye.UssParkingSlot.parking_stage)
  return _internal_parking_stage();
}
inline void UssParkingSlot::_internal_set_parking_stage(::minieye::UssParkingSlot_ParkingStage value) {
  
  parking_stage_ = value;
}
inline void UssParkingSlot::set_parking_stage(::minieye::UssParkingSlot_ParkingStage value) {
  _internal_set_parking_stage(value);
  // @@protoc_insertion_point(field_set:minieye.UssParkingSlot.parking_stage)
}

// repeated .minieye.CornerPt corner_pts = 6;
inline int UssParkingSlot::_internal_corner_pts_size() const {
  return corner_pts_.size();
}
inline int UssParkingSlot::corner_pts_size() const {
  return _internal_corner_pts_size();
}
inline void UssParkingSlot::clear_corner_pts() {
  corner_pts_.Clear();
}
inline ::minieye::CornerPt* UssParkingSlot::mutable_corner_pts(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.UssParkingSlot.corner_pts)
  return corner_pts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::CornerPt >*
UssParkingSlot::mutable_corner_pts() {
  // @@protoc_insertion_point(field_mutable_list:minieye.UssParkingSlot.corner_pts)
  return &corner_pts_;
}
inline const ::minieye::CornerPt& UssParkingSlot::_internal_corner_pts(int index) const {
  return corner_pts_.Get(index);
}
inline const ::minieye::CornerPt& UssParkingSlot::corner_pts(int index) const {
  // @@protoc_insertion_point(field_get:minieye.UssParkingSlot.corner_pts)
  return _internal_corner_pts(index);
}
inline ::minieye::CornerPt* UssParkingSlot::_internal_add_corner_pts() {
  return corner_pts_.Add();
}
inline ::minieye::CornerPt* UssParkingSlot::add_corner_pts() {
  // @@protoc_insertion_point(field_add:minieye.UssParkingSlot.corner_pts)
  return _internal_add_corner_pts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::CornerPt >&
UssParkingSlot::corner_pts() const {
  // @@protoc_insertion_point(field_list:minieye.UssParkingSlot.corner_pts)
  return corner_pts_;
}

// bool is_left_ps = 7;
inline void UssParkingSlot::clear_is_left_ps() {
  is_left_ps_ = false;
}
inline bool UssParkingSlot::_internal_is_left_ps() const {
  return is_left_ps_;
}
inline bool UssParkingSlot::is_left_ps() const {
  // @@protoc_insertion_point(field_get:minieye.UssParkingSlot.is_left_ps)
  return _internal_is_left_ps();
}
inline void UssParkingSlot::_internal_set_is_left_ps(bool value) {
  
  is_left_ps_ = value;
}
inline void UssParkingSlot::set_is_left_ps(bool value) {
  _internal_set_is_left_ps(value);
  // @@protoc_insertion_point(field_set:minieye.UssParkingSlot.is_left_ps)
}

// uint64 single_tick = 8;
inline void UssParkingSlot::clear_single_tick() {
  single_tick_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UssParkingSlot::_internal_single_tick() const {
  return single_tick_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UssParkingSlot::single_tick() const {
  // @@protoc_insertion_point(field_get:minieye.UssParkingSlot.single_tick)
  return _internal_single_tick();
}
inline void UssParkingSlot::_internal_set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  single_tick_ = value;
}
inline void UssParkingSlot::set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_single_tick(value);
  // @@protoc_insertion_point(field_set:minieye.UssParkingSlot.single_tick)
}

// -------------------------------------------------------------------

// Obstacle

// .minieye.ObstacleType type = 1;
inline void Obstacle::clear_type() {
  type_ = 0;
}
inline ::minieye::ObstacleType Obstacle::_internal_type() const {
  return static_cast< ::minieye::ObstacleType >(type_);
}
inline ::minieye::ObstacleType Obstacle::type() const {
  // @@protoc_insertion_point(field_get:minieye.Obstacle.type)
  return _internal_type();
}
inline void Obstacle::_internal_set_type(::minieye::ObstacleType value) {
  
  type_ = value;
}
inline void Obstacle::set_type(::minieye::ObstacleType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:minieye.Obstacle.type)
}

// uint32 id = 2;
inline void Obstacle::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Obstacle::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Obstacle::id() const {
  // @@protoc_insertion_point(field_get:minieye.Obstacle.id)
  return _internal_id();
}
inline void Obstacle::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void Obstacle::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:minieye.Obstacle.id)
}

// float score = 3;
inline void Obstacle::clear_score() {
  score_ = 0;
}
inline float Obstacle::_internal_score() const {
  return score_;
}
inline float Obstacle::score() const {
  // @@protoc_insertion_point(field_get:minieye.Obstacle.score)
  return _internal_score();
}
inline void Obstacle::_internal_set_score(float value) {
  
  score_ = value;
}
inline void Obstacle::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:minieye.Obstacle.score)
}

// .minieye.Point2D vehPt0 = 4;
inline bool Obstacle::_internal_has_vehpt0() const {
  return this != internal_default_instance() && vehpt0_ != nullptr;
}
inline bool Obstacle::has_vehpt0() const {
  return _internal_has_vehpt0();
}
inline void Obstacle::clear_vehpt0() {
  if (GetArena() == nullptr && vehpt0_ != nullptr) {
    delete vehpt0_;
  }
  vehpt0_ = nullptr;
}
inline const ::minieye::Point2D& Obstacle::_internal_vehpt0() const {
  const ::minieye::Point2D* p = vehpt0_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::Point2D*>(
      &::minieye::_Point2D_default_instance_);
}
inline const ::minieye::Point2D& Obstacle::vehpt0() const {
  // @@protoc_insertion_point(field_get:minieye.Obstacle.vehPt0)
  return _internal_vehpt0();
}
inline void Obstacle::unsafe_arena_set_allocated_vehpt0(
    ::minieye::Point2D* vehpt0) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehpt0_);
  }
  vehpt0_ = vehpt0;
  if (vehpt0) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.Obstacle.vehPt0)
}
inline ::minieye::Point2D* Obstacle::release_vehpt0() {
  auto temp = unsafe_arena_release_vehpt0();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::Point2D* Obstacle::unsafe_arena_release_vehpt0() {
  // @@protoc_insertion_point(field_release:minieye.Obstacle.vehPt0)
  
  ::minieye::Point2D* temp = vehpt0_;
  vehpt0_ = nullptr;
  return temp;
}
inline ::minieye::Point2D* Obstacle::_internal_mutable_vehpt0() {
  
  if (vehpt0_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::Point2D>(GetArena());
    vehpt0_ = p;
  }
  return vehpt0_;
}
inline ::minieye::Point2D* Obstacle::mutable_vehpt0() {
  // @@protoc_insertion_point(field_mutable:minieye.Obstacle.vehPt0)
  return _internal_mutable_vehpt0();
}
inline void Obstacle::set_allocated_vehpt0(::minieye::Point2D* vehpt0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vehpt0_;
  }
  if (vehpt0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vehpt0);
    if (message_arena != submessage_arena) {
      vehpt0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehpt0, submessage_arena);
    }
    
  } else {
    
  }
  vehpt0_ = vehpt0;
  // @@protoc_insertion_point(field_set_allocated:minieye.Obstacle.vehPt0)
}

// .minieye.Point2D vehPt1 = 5;
inline bool Obstacle::_internal_has_vehpt1() const {
  return this != internal_default_instance() && vehpt1_ != nullptr;
}
inline bool Obstacle::has_vehpt1() const {
  return _internal_has_vehpt1();
}
inline void Obstacle::clear_vehpt1() {
  if (GetArena() == nullptr && vehpt1_ != nullptr) {
    delete vehpt1_;
  }
  vehpt1_ = nullptr;
}
inline const ::minieye::Point2D& Obstacle::_internal_vehpt1() const {
  const ::minieye::Point2D* p = vehpt1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::Point2D*>(
      &::minieye::_Point2D_default_instance_);
}
inline const ::minieye::Point2D& Obstacle::vehpt1() const {
  // @@protoc_insertion_point(field_get:minieye.Obstacle.vehPt1)
  return _internal_vehpt1();
}
inline void Obstacle::unsafe_arena_set_allocated_vehpt1(
    ::minieye::Point2D* vehpt1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehpt1_);
  }
  vehpt1_ = vehpt1;
  if (vehpt1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.Obstacle.vehPt1)
}
inline ::minieye::Point2D* Obstacle::release_vehpt1() {
  auto temp = unsafe_arena_release_vehpt1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::Point2D* Obstacle::unsafe_arena_release_vehpt1() {
  // @@protoc_insertion_point(field_release:minieye.Obstacle.vehPt1)
  
  ::minieye::Point2D* temp = vehpt1_;
  vehpt1_ = nullptr;
  return temp;
}
inline ::minieye::Point2D* Obstacle::_internal_mutable_vehpt1() {
  
  if (vehpt1_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::Point2D>(GetArena());
    vehpt1_ = p;
  }
  return vehpt1_;
}
inline ::minieye::Point2D* Obstacle::mutable_vehpt1() {
  // @@protoc_insertion_point(field_mutable:minieye.Obstacle.vehPt1)
  return _internal_mutable_vehpt1();
}
inline void Obstacle::set_allocated_vehpt1(::minieye::Point2D* vehpt1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vehpt1_;
  }
  if (vehpt1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vehpt1);
    if (message_arena != submessage_arena) {
      vehpt1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehpt1, submessage_arena);
    }
    
  } else {
    
  }
  vehpt1_ = vehpt1;
  // @@protoc_insertion_point(field_set_allocated:minieye.Obstacle.vehPt1)
}

// .minieye.TriangleType triangle_type = 6;
inline void Obstacle::clear_triangle_type() {
  triangle_type_ = 0;
}
inline ::minieye::TriangleType Obstacle::_internal_triangle_type() const {
  return static_cast< ::minieye::TriangleType >(triangle_type_);
}
inline ::minieye::TriangleType Obstacle::triangle_type() const {
  // @@protoc_insertion_point(field_get:minieye.Obstacle.triangle_type)
  return _internal_triangle_type();
}
inline void Obstacle::_internal_set_triangle_type(::minieye::TriangleType value) {
  
  triangle_type_ = value;
}
inline void Obstacle::set_triangle_type(::minieye::TriangleType value) {
  _internal_set_triangle_type(value);
  // @@protoc_insertion_point(field_set:minieye.Obstacle.triangle_type)
}

// uint64 single_tick = 7;
inline void Obstacle::clear_single_tick() {
  single_tick_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Obstacle::_internal_single_tick() const {
  return single_tick_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Obstacle::single_tick() const {
  // @@protoc_insertion_point(field_get:minieye.Obstacle.single_tick)
  return _internal_single_tick();
}
inline void Obstacle::_internal_set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  single_tick_ = value;
}
inline void Obstacle::set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_single_tick(value);
  // @@protoc_insertion_point(field_set:minieye.Obstacle.single_tick)
}

// -------------------------------------------------------------------

// Emap

// uint32 id = 1;
inline void Emap::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Emap::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Emap::id() const {
  // @@protoc_insertion_point(field_get:minieye.Emap.id)
  return _internal_id();
}
inline void Emap::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void Emap::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:minieye.Emap.id)
}

// .minieye.Emap.EMapConfidence n = 2;
inline void Emap::clear_n() {
  n_ = 0;
}
inline ::minieye::Emap_EMapConfidence Emap::_internal_n() const {
  return static_cast< ::minieye::Emap_EMapConfidence >(n_);
}
inline ::minieye::Emap_EMapConfidence Emap::n() const {
  // @@protoc_insertion_point(field_get:minieye.Emap.n)
  return _internal_n();
}
inline void Emap::_internal_set_n(::minieye::Emap_EMapConfidence value) {
  
  n_ = value;
}
inline void Emap::set_n(::minieye::Emap_EMapConfidence value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:minieye.Emap.n)
}

// .minieye.Point2D vehPt = 3;
inline bool Emap::_internal_has_vehpt() const {
  return this != internal_default_instance() && vehpt_ != nullptr;
}
inline bool Emap::has_vehpt() const {
  return _internal_has_vehpt();
}
inline void Emap::clear_vehpt() {
  if (GetArena() == nullptr && vehpt_ != nullptr) {
    delete vehpt_;
  }
  vehpt_ = nullptr;
}
inline const ::minieye::Point2D& Emap::_internal_vehpt() const {
  const ::minieye::Point2D* p = vehpt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::Point2D*>(
      &::minieye::_Point2D_default_instance_);
}
inline const ::minieye::Point2D& Emap::vehpt() const {
  // @@protoc_insertion_point(field_get:minieye.Emap.vehPt)
  return _internal_vehpt();
}
inline void Emap::unsafe_arena_set_allocated_vehpt(
    ::minieye::Point2D* vehpt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vehpt_);
  }
  vehpt_ = vehpt;
  if (vehpt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.Emap.vehPt)
}
inline ::minieye::Point2D* Emap::release_vehpt() {
  auto temp = unsafe_arena_release_vehpt();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::Point2D* Emap::unsafe_arena_release_vehpt() {
  // @@protoc_insertion_point(field_release:minieye.Emap.vehPt)
  
  ::minieye::Point2D* temp = vehpt_;
  vehpt_ = nullptr;
  return temp;
}
inline ::minieye::Point2D* Emap::_internal_mutable_vehpt() {
  
  if (vehpt_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::Point2D>(GetArena());
    vehpt_ = p;
  }
  return vehpt_;
}
inline ::minieye::Point2D* Emap::mutable_vehpt() {
  // @@protoc_insertion_point(field_mutable:minieye.Emap.vehPt)
  return _internal_mutable_vehpt();
}
inline void Emap::set_allocated_vehpt(::minieye::Point2D* vehpt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vehpt_;
  }
  if (vehpt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vehpt);
    if (message_arena != submessage_arena) {
      vehpt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vehpt, submessage_arena);
    }
    
  } else {
    
  }
  vehpt_ = vehpt;
  // @@protoc_insertion_point(field_set_allocated:minieye.Emap.vehPt)
}

// bool is_left_point = 4;
inline void Emap::clear_is_left_point() {
  is_left_point_ = false;
}
inline bool Emap::_internal_is_left_point() const {
  return is_left_point_;
}
inline bool Emap::is_left_point() const {
  // @@protoc_insertion_point(field_get:minieye.Emap.is_left_point)
  return _internal_is_left_point();
}
inline void Emap::_internal_set_is_left_point(bool value) {
  
  is_left_point_ = value;
}
inline void Emap::set_is_left_point(bool value) {
  _internal_set_is_left_point(value);
  // @@protoc_insertion_point(field_set:minieye.Emap.is_left_point)
}

// uint64 single_tick = 5;
inline void Emap::clear_single_tick() {
  single_tick_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Emap::_internal_single_tick() const {
  return single_tick_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Emap::single_tick() const {
  // @@protoc_insertion_point(field_get:minieye.Emap.single_tick)
  return _internal_single_tick();
}
inline void Emap::_internal_set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  single_tick_ = value;
}
inline void Emap::set_single_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_single_tick(value);
  // @@protoc_insertion_point(field_set:minieye.Emap.single_tick)
}

// -------------------------------------------------------------------

// UssOutput

// uint64 timestamp = 1;
inline void UssOutput::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UssOutput::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UssOutput::timestamp() const {
  // @@protoc_insertion_point(field_get:minieye.UssOutput.timestamp)
  return _internal_timestamp();
}
inline void UssOutput::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void UssOutput::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:minieye.UssOutput.timestamp)
}

// uint64 frame_id = 2;
inline void UssOutput::clear_frame_id() {
  frame_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UssOutput::_internal_frame_id() const {
  return frame_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UssOutput::frame_id() const {
  // @@protoc_insertion_point(field_get:minieye.UssOutput.frame_id)
  return _internal_frame_id();
}
inline void UssOutput::_internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  frame_id_ = value;
}
inline void UssOutput::set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:minieye.UssOutput.frame_id)
}

// uint64 tick = 3;
inline void UssOutput::clear_tick() {
  tick_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UssOutput::_internal_tick() const {
  return tick_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UssOutput::tick() const {
  // @@protoc_insertion_point(field_get:minieye.UssOutput.tick)
  return _internal_tick();
}
inline void UssOutput::_internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  tick_ = value;
}
inline void UssOutput::set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:minieye.UssOutput.tick)
}

// repeated .minieye.UssParkingSlot parkslots = 4;
inline int UssOutput::_internal_parkslots_size() const {
  return parkslots_.size();
}
inline int UssOutput::parkslots_size() const {
  return _internal_parkslots_size();
}
inline void UssOutput::clear_parkslots() {
  parkslots_.Clear();
}
inline ::minieye::UssParkingSlot* UssOutput::mutable_parkslots(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.UssOutput.parkslots)
  return parkslots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::UssParkingSlot >*
UssOutput::mutable_parkslots() {
  // @@protoc_insertion_point(field_mutable_list:minieye.UssOutput.parkslots)
  return &parkslots_;
}
inline const ::minieye::UssParkingSlot& UssOutput::_internal_parkslots(int index) const {
  return parkslots_.Get(index);
}
inline const ::minieye::UssParkingSlot& UssOutput::parkslots(int index) const {
  // @@protoc_insertion_point(field_get:minieye.UssOutput.parkslots)
  return _internal_parkslots(index);
}
inline ::minieye::UssParkingSlot* UssOutput::_internal_add_parkslots() {
  return parkslots_.Add();
}
inline ::minieye::UssParkingSlot* UssOutput::add_parkslots() {
  // @@protoc_insertion_point(field_add:minieye.UssOutput.parkslots)
  return _internal_add_parkslots();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::UssParkingSlot >&
UssOutput::parkslots() const {
  // @@protoc_insertion_point(field_list:minieye.UssOutput.parkslots)
  return parkslots_;
}

// repeated .minieye.Obstacle obstacle_rects = 5;
inline int UssOutput::_internal_obstacle_rects_size() const {
  return obstacle_rects_.size();
}
inline int UssOutput::obstacle_rects_size() const {
  return _internal_obstacle_rects_size();
}
inline void UssOutput::clear_obstacle_rects() {
  obstacle_rects_.Clear();
}
inline ::minieye::Obstacle* UssOutput::mutable_obstacle_rects(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.UssOutput.obstacle_rects)
  return obstacle_rects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Obstacle >*
UssOutput::mutable_obstacle_rects() {
  // @@protoc_insertion_point(field_mutable_list:minieye.UssOutput.obstacle_rects)
  return &obstacle_rects_;
}
inline const ::minieye::Obstacle& UssOutput::_internal_obstacle_rects(int index) const {
  return obstacle_rects_.Get(index);
}
inline const ::minieye::Obstacle& UssOutput::obstacle_rects(int index) const {
  // @@protoc_insertion_point(field_get:minieye.UssOutput.obstacle_rects)
  return _internal_obstacle_rects(index);
}
inline ::minieye::Obstacle* UssOutput::_internal_add_obstacle_rects() {
  return obstacle_rects_.Add();
}
inline ::minieye::Obstacle* UssOutput::add_obstacle_rects() {
  // @@protoc_insertion_point(field_add:minieye.UssOutput.obstacle_rects)
  return _internal_add_obstacle_rects();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Obstacle >&
UssOutput::obstacle_rects() const {
  // @@protoc_insertion_point(field_list:minieye.UssOutput.obstacle_rects)
  return obstacle_rects_;
}

// repeated .minieye.Emap emap = 6;
inline int UssOutput::_internal_emap_size() const {
  return emap_.size();
}
inline int UssOutput::emap_size() const {
  return _internal_emap_size();
}
inline void UssOutput::clear_emap() {
  emap_.Clear();
}
inline ::minieye::Emap* UssOutput::mutable_emap(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.UssOutput.emap)
  return emap_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Emap >*
UssOutput::mutable_emap() {
  // @@protoc_insertion_point(field_mutable_list:minieye.UssOutput.emap)
  return &emap_;
}
inline const ::minieye::Emap& UssOutput::_internal_emap(int index) const {
  return emap_.Get(index);
}
inline const ::minieye::Emap& UssOutput::emap(int index) const {
  // @@protoc_insertion_point(field_get:minieye.UssOutput.emap)
  return _internal_emap(index);
}
inline ::minieye::Emap* UssOutput::_internal_add_emap() {
  return emap_.Add();
}
inline ::minieye::Emap* UssOutput::add_emap() {
  // @@protoc_insertion_point(field_add:minieye.UssOutput.emap)
  return _internal_add_emap();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Emap >&
UssOutput::emap() const {
  // @@protoc_insertion_point(field_list:minieye.UssOutput.emap)
  return emap_;
}

// -------------------------------------------------------------------

// UssOutputList

// uint64 tick = 1;
inline void UssOutputList::clear_tick() {
  tick_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UssOutputList::_internal_tick() const {
  return tick_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UssOutputList::tick() const {
  // @@protoc_insertion_point(field_get:minieye.UssOutputList.tick)
  return _internal_tick();
}
inline void UssOutputList::_internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  tick_ = value;
}
inline void UssOutputList::set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:minieye.UssOutputList.tick)
}

// repeated .minieye.UssOutput uss_outputs = 2;
inline int UssOutputList::_internal_uss_outputs_size() const {
  return uss_outputs_.size();
}
inline int UssOutputList::uss_outputs_size() const {
  return _internal_uss_outputs_size();
}
inline void UssOutputList::clear_uss_outputs() {
  uss_outputs_.Clear();
}
inline ::minieye::UssOutput* UssOutputList::mutable_uss_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.UssOutputList.uss_outputs)
  return uss_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::UssOutput >*
UssOutputList::mutable_uss_outputs() {
  // @@protoc_insertion_point(field_mutable_list:minieye.UssOutputList.uss_outputs)
  return &uss_outputs_;
}
inline const ::minieye::UssOutput& UssOutputList::_internal_uss_outputs(int index) const {
  return uss_outputs_.Get(index);
}
inline const ::minieye::UssOutput& UssOutputList::uss_outputs(int index) const {
  // @@protoc_insertion_point(field_get:minieye.UssOutputList.uss_outputs)
  return _internal_uss_outputs(index);
}
inline ::minieye::UssOutput* UssOutputList::_internal_add_uss_outputs() {
  return uss_outputs_.Add();
}
inline ::minieye::UssOutput* UssOutputList::add_uss_outputs() {
  // @@protoc_insertion_point(field_add:minieye.UssOutputList.uss_outputs)
  return _internal_add_uss_outputs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::UssOutput >&
UssOutputList::uss_outputs() const {
  // @@protoc_insertion_point(field_list:minieye.UssOutputList.uss_outputs)
  return uss_outputs_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace minieye

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::minieye::UssParkingSlot_SlotType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::UssParkingSlot_SlotType>() {
  return ::minieye::UssParkingSlot_SlotType_descriptor();
}
template <> struct is_proto_enum< ::minieye::UssParkingSlot_ParkingStage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::UssParkingSlot_ParkingStage>() {
  return ::minieye::UssParkingSlot_ParkingStage_descriptor();
}
template <> struct is_proto_enum< ::minieye::Emap_EMapConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::Emap_EMapConfidence>() {
  return ::minieye::Emap_EMapConfidence_descriptor();
}
template <> struct is_proto_enum< ::minieye::ObstacleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::ObstacleType>() {
  return ::minieye::ObstacleType_descriptor();
}
template <> struct is_proto_enum< ::minieye::TriangleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::TriangleType>() {
  return ::minieye::TriangleType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_uss_5foutput_2eproto
