// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tag.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tag_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tag_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tag_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tag_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tag_2eproto;
namespace minieye {
class DataTag;
class DataTagDefaultTypeInternal;
extern DataTagDefaultTypeInternal _DataTag_default_instance_;
class Range;
class RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
class Tags;
class TagsDefaultTypeInternal;
extern TagsDefaultTypeInternal _Tags_default_instance_;
}  // namespace minieye
PROTOBUF_NAMESPACE_OPEN
template<> ::minieye::DataTag* Arena::CreateMaybeMessage<::minieye::DataTag>(Arena*);
template<> ::minieye::Range* Arena::CreateMaybeMessage<::minieye::Range>(Arena*);
template<> ::minieye::Tags* Arena::CreateMaybeMessage<::minieye::Tags>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace minieye {

enum DataTag_TagLabel : int {
  DataTag_TagLabel_RoadConditionTag = 0,
  DataTag_TagLabel_ColorTag = 1,
  DataTag_TagLabel_LanelineTypeTag = 2,
  DataTag_TagLabel_SlopeTag = 3,
  DataTag_TagLabel_WeatherCondTag = 4,
  DataTag_TagLabel_IlluminationTag = 5,
  DataTag_TagLabel_ObjTypeTag = 6,
  DataTag_TagLabel_AreaTag = 7,
  DataTag_TagLabel_WorkConditionTag = 8,
  DataTag_TagLabel_ObjDistTag = 9,
  DataTag_TagLabel_DensityTag = 10,
  DataTag_TagLabel_PositionTag = 11,
  DataTag_TagLabel_StandardTag = 12,
  DataTag_TagLabel_DataTag_TagLabel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataTag_TagLabel_DataTag_TagLabel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataTag_TagLabel_IsValid(int value);
constexpr DataTag_TagLabel DataTag_TagLabel_TagLabel_MIN = DataTag_TagLabel_RoadConditionTag;
constexpr DataTag_TagLabel DataTag_TagLabel_TagLabel_MAX = DataTag_TagLabel_StandardTag;
constexpr int DataTag_TagLabel_TagLabel_ARRAYSIZE = DataTag_TagLabel_TagLabel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataTag_TagLabel_descriptor();
template<typename T>
inline const std::string& DataTag_TagLabel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataTag_TagLabel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataTag_TagLabel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataTag_TagLabel_descriptor(), enum_t_value);
}
inline bool DataTag_TagLabel_Parse(
    const std::string& name, DataTag_TagLabel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataTag_TagLabel>(
    DataTag_TagLabel_descriptor(), name, value);
}
enum RoadConditionTag : int {
  StraightRoad = 0,
  SmallCurveRoad = 1,
  MiddleCurveRoad = 2,
  BigCurveRoad = 3,
  SCurveRoad = 4,
  Junction = 5,
  QuarterTurn = 6,
  Abrasion = 7,
  AbandonedLaneline = 8,
  SuspectedLaneline = 9,
  Characters = 10,
  ManHoleCover = 11,
  SpeedBump = 12,
  RoadConditionTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoadConditionTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoadConditionTag_IsValid(int value);
constexpr RoadConditionTag RoadConditionTag_MIN = StraightRoad;
constexpr RoadConditionTag RoadConditionTag_MAX = SpeedBump;
constexpr int RoadConditionTag_ARRAYSIZE = RoadConditionTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoadConditionTag_descriptor();
template<typename T>
inline const std::string& RoadConditionTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoadConditionTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoadConditionTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoadConditionTag_descriptor(), enum_t_value);
}
inline bool RoadConditionTag_Parse(
    const std::string& name, RoadConditionTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoadConditionTag>(
    RoadConditionTag_descriptor(), name, value);
}
enum ColorTag : int {
  White = 0,
  Yellow = 1,
  Blue = 2,
  Red = 3,
  Green = 4,
  ColorTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ColorTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ColorTag_IsValid(int value);
constexpr ColorTag ColorTag_MIN = White;
constexpr ColorTag ColorTag_MAX = Green;
constexpr int ColorTag_ARRAYSIZE = ColorTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ColorTag_descriptor();
template<typename T>
inline const std::string& ColorTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ColorTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ColorTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ColorTag_descriptor(), enum_t_value);
}
inline bool ColorTag_Parse(
    const std::string& name, ColorTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ColorTag>(
    ColorTag_descriptor(), name, value);
}
enum LanelineTypeTag : int {
  Dashed = 0,
  Solid = 1,
  DashedSolid = 2,
  DoubleSolid = 3,
  DoubleDashed = 4,
  DoubleDecLine = 5,
  SingleDecLine = 6,
  Bold = 7,
  SolidDashed = 8,
  LanelineTypeTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LanelineTypeTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LanelineTypeTag_IsValid(int value);
constexpr LanelineTypeTag LanelineTypeTag_MIN = Dashed;
constexpr LanelineTypeTag LanelineTypeTag_MAX = SolidDashed;
constexpr int LanelineTypeTag_ARRAYSIZE = LanelineTypeTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LanelineTypeTag_descriptor();
template<typename T>
inline const std::string& LanelineTypeTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LanelineTypeTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LanelineTypeTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LanelineTypeTag_descriptor(), enum_t_value);
}
inline bool LanelineTypeTag_Parse(
    const std::string& name, LanelineTypeTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LanelineTypeTag>(
    LanelineTypeTag_descriptor(), name, value);
}
enum SlopeTag : int {
  Flat = 0,
  Bump = 1,
  UpSlope = 2,
  DownSlope = 3,
  SlopeTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SlopeTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SlopeTag_IsValid(int value);
constexpr SlopeTag SlopeTag_MIN = Flat;
constexpr SlopeTag SlopeTag_MAX = DownSlope;
constexpr int SlopeTag_ARRAYSIZE = SlopeTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SlopeTag_descriptor();
template<typename T>
inline const std::string& SlopeTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SlopeTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SlopeTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SlopeTag_descriptor(), enum_t_value);
}
inline bool SlopeTag_Parse(
    const std::string& name, SlopeTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SlopeTag>(
    SlopeTag_descriptor(), name, value);
}
enum WeatherCondTag : int {
  Shine = 0,
  Cloudy = 1,
  HeavyRain = 2,
  LightRain = 3,
  SnowCover = 4,
  WaterCover = 5,
  HeavyFog = 6,
  LightFog = 7,
  WeatherCondTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WeatherCondTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WeatherCondTag_IsValid(int value);
constexpr WeatherCondTag WeatherCondTag_MIN = Shine;
constexpr WeatherCondTag WeatherCondTag_MAX = LightFog;
constexpr int WeatherCondTag_ARRAYSIZE = WeatherCondTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeatherCondTag_descriptor();
template<typename T>
inline const std::string& WeatherCondTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeatherCondTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeatherCondTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeatherCondTag_descriptor(), enum_t_value);
}
inline bool WeatherCondTag_Parse(
    const std::string& name, WeatherCondTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeatherCondTag>(
    WeatherCondTag_descriptor(), name, value);
}
enum IlluminationTag : int {
  Day = 0,
  Night = 1,
  LowSun = 2,
  Shadow = 3,
  Tunnel = 4,
  IlluminationTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  IlluminationTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool IlluminationTag_IsValid(int value);
constexpr IlluminationTag IlluminationTag_MIN = Day;
constexpr IlluminationTag IlluminationTag_MAX = Tunnel;
constexpr int IlluminationTag_ARRAYSIZE = IlluminationTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IlluminationTag_descriptor();
template<typename T>
inline const std::string& IlluminationTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IlluminationTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IlluminationTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IlluminationTag_descriptor(), enum_t_value);
}
inline bool IlluminationTag_Parse(
    const std::string& name, IlluminationTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IlluminationTag>(
    IlluminationTag_descriptor(), name, value);
}
enum ObjTypeTag : int {
  Car = 0,
  SUV = 1,
  Bus = 2,
  MiniBus = 3,
  MPV = 4,
  TipTruck = 5,
  PickUp = 6,
  BoxTruck = 7,
  Tricycle = 8,
  OilTank = 9,
  CementTanker = 10,
  SlagCar = 11,
  Iveco = 12,
  StrangeVeh = 13,
  MunicipalVeh = 14,
  MotorBike = 15,
  Bicycle = 16,
  ElectroCar = 17,
  Adult = 18,
  Child = 19,
  PoliceCar = 20,
  Ambulance = 21,
  FireTruck = 22,
  kSpecial = 23,
  ObjTypeTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ObjTypeTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ObjTypeTag_IsValid(int value);
constexpr ObjTypeTag ObjTypeTag_MIN = Car;
constexpr ObjTypeTag ObjTypeTag_MAX = kSpecial;
constexpr int ObjTypeTag_ARRAYSIZE = ObjTypeTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjTypeTag_descriptor();
template<typename T>
inline const std::string& ObjTypeTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObjTypeTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObjTypeTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObjTypeTag_descriptor(), enum_t_value);
}
inline bool ObjTypeTag_Parse(
    const std::string& name, ObjTypeTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObjTypeTag>(
    ObjTypeTag_descriptor(), name, value);
}
enum AreaTag : int {
  City = 0,
  Highway = 1,
  Village = 2,
  Town = 3,
  InDoor = 4,
  AreaTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AreaTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AreaTag_IsValid(int value);
constexpr AreaTag AreaTag_MIN = City;
constexpr AreaTag AreaTag_MAX = InDoor;
constexpr int AreaTag_ARRAYSIZE = AreaTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AreaTag_descriptor();
template<typename T>
inline const std::string& AreaTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AreaTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AreaTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AreaTag_descriptor(), enum_t_value);
}
inline bool AreaTag_Parse(
    const std::string& name, AreaTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AreaTag>(
    AreaTag_descriptor(), name, value);
}
enum WorkConditionTag : int {
  Far2Near = 0,
  Near2Far = 1,
  CruisingByFollowing = 2,
  CruisingInCurve = 3,
  Jam = 4,
  InOutJunction = 5,
  TunnelEscape = 6,
  IntoTunnel = 7,
  TurnRound = 8,
  WorkConditionTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkConditionTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkConditionTag_IsValid(int value);
constexpr WorkConditionTag WorkConditionTag_MIN = Far2Near;
constexpr WorkConditionTag WorkConditionTag_MAX = TurnRound;
constexpr int WorkConditionTag_ARRAYSIZE = WorkConditionTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkConditionTag_descriptor();
template<typename T>
inline const std::string& WorkConditionTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkConditionTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkConditionTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkConditionTag_descriptor(), enum_t_value);
}
inline bool WorkConditionTag_Parse(
    const std::string& name, WorkConditionTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkConditionTag>(
    WorkConditionTag_descriptor(), name, value);
}
enum ObjDistTag : int {
  Near = 0,
  Middle = 1,
  Far = 2,
  ObjDistTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ObjDistTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ObjDistTag_IsValid(int value);
constexpr ObjDistTag ObjDistTag_MIN = Near;
constexpr ObjDistTag ObjDistTag_MAX = Far;
constexpr int ObjDistTag_ARRAYSIZE = ObjDistTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjDistTag_descriptor();
template<typename T>
inline const std::string& ObjDistTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObjDistTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObjDistTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObjDistTag_descriptor(), enum_t_value);
}
inline bool ObjDistTag_Parse(
    const std::string& name, ObjDistTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObjDistTag>(
    ObjDistTag_descriptor(), name, value);
}
enum DensityTag : int {
  Dense = 0,
  Sparse = 1,
  DensityTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DensityTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DensityTag_IsValid(int value);
constexpr DensityTag DensityTag_MIN = Dense;
constexpr DensityTag DensityTag_MAX = Sparse;
constexpr int DensityTag_ARRAYSIZE = DensityTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DensityTag_descriptor();
template<typename T>
inline const std::string& DensityTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DensityTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DensityTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DensityTag_descriptor(), enum_t_value);
}
inline bool DensityTag_Parse(
    const std::string& name, DensityTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DensityTag>(
    DensityTag_descriptor(), name, value);
}
enum PositionTag : int {
  Front = 0,
  Side = 1,
  PositionTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PositionTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PositionTag_IsValid(int value);
constexpr PositionTag PositionTag_MIN = Front;
constexpr PositionTag PositionTag_MAX = Side;
constexpr int PositionTag_ARRAYSIZE = PositionTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PositionTag_descriptor();
template<typename T>
inline const std::string& PositionTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PositionTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PositionTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PositionTag_descriptor(), enum_t_value);
}
inline bool PositionTag_Parse(
    const std::string& name, PositionTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PositionTag>(
    PositionTag_descriptor(), name, value);
}
enum StandardTag : int {
  S_33577 = 0,
  S_883 = 1,
  S_Cncap = 2,
  S_Eucap = 3,
  StandardTag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StandardTag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StandardTag_IsValid(int value);
constexpr StandardTag StandardTag_MIN = S_33577;
constexpr StandardTag StandardTag_MAX = S_Eucap;
constexpr int StandardTag_ARRAYSIZE = StandardTag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StandardTag_descriptor();
template<typename T>
inline const std::string& StandardTag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StandardTag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StandardTag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StandardTag_descriptor(), enum_t_value);
}
inline bool StandardTag_Parse(
    const std::string& name, StandardTag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StandardTag>(
    StandardTag_descriptor(), name, value);
}
// ===================================================================

class DataTag PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.DataTag) */ {
 public:
  inline DataTag() : DataTag(nullptr) {};
  virtual ~DataTag();

  DataTag(const DataTag& from);
  DataTag(DataTag&& from) noexcept
    : DataTag() {
    *this = ::std::move(from);
  }

  inline DataTag& operator=(const DataTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataTag& operator=(DataTag&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataTag* internal_default_instance() {
    return reinterpret_cast<const DataTag*>(
               &_DataTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DataTag& a, DataTag& b) {
    a.Swap(&b);
  }
  inline void Swap(DataTag* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataTag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataTag* New() const final {
    return CreateMaybeMessage<DataTag>(nullptr);
  }

  DataTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataTag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataTag& from);
  void MergeFrom(const DataTag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataTag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.DataTag";
  }
  protected:
  explicit DataTag(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tag_2eproto);
    return ::descriptor_table_tag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DataTag_TagLabel TagLabel;
  static constexpr TagLabel RoadConditionTag =
    DataTag_TagLabel_RoadConditionTag;
  static constexpr TagLabel ColorTag =
    DataTag_TagLabel_ColorTag;
  static constexpr TagLabel LanelineTypeTag =
    DataTag_TagLabel_LanelineTypeTag;
  static constexpr TagLabel SlopeTag =
    DataTag_TagLabel_SlopeTag;
  static constexpr TagLabel WeatherCondTag =
    DataTag_TagLabel_WeatherCondTag;
  static constexpr TagLabel IlluminationTag =
    DataTag_TagLabel_IlluminationTag;
  static constexpr TagLabel ObjTypeTag =
    DataTag_TagLabel_ObjTypeTag;
  static constexpr TagLabel AreaTag =
    DataTag_TagLabel_AreaTag;
  static constexpr TagLabel WorkConditionTag =
    DataTag_TagLabel_WorkConditionTag;
  static constexpr TagLabel ObjDistTag =
    DataTag_TagLabel_ObjDistTag;
  static constexpr TagLabel DensityTag =
    DataTag_TagLabel_DensityTag;
  static constexpr TagLabel PositionTag =
    DataTag_TagLabel_PositionTag;
  static constexpr TagLabel StandardTag =
    DataTag_TagLabel_StandardTag;
  static inline bool TagLabel_IsValid(int value) {
    return DataTag_TagLabel_IsValid(value);
  }
  static constexpr TagLabel TagLabel_MIN =
    DataTag_TagLabel_TagLabel_MIN;
  static constexpr TagLabel TagLabel_MAX =
    DataTag_TagLabel_TagLabel_MAX;
  static constexpr int TagLabel_ARRAYSIZE =
    DataTag_TagLabel_TagLabel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TagLabel_descriptor() {
    return DataTag_TagLabel_descriptor();
  }
  template<typename T>
  static inline const std::string& TagLabel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TagLabel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TagLabel_Name.");
    return DataTag_TagLabel_Name(enum_t_value);
  }
  static inline bool TagLabel_Parse(const std::string& name,
      TagLabel* value) {
    return DataTag_TagLabel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
    kValFieldNumber = 2,
  };
  // .minieye.DataTag.TagLabel label = 1;
  void clear_label();
  ::minieye::DataTag_TagLabel label() const;
  void set_label(::minieye::DataTag_TagLabel value);
  private:
  ::minieye::DataTag_TagLabel _internal_label() const;
  void _internal_set_label(::minieye::DataTag_TagLabel value);
  public:

  // int32 val = 2;
  void clear_val();
  ::PROTOBUF_NAMESPACE_ID::int32 val() const;
  void set_val(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_val() const;
  void _internal_set_val(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.DataTag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int label_;
  ::PROTOBUF_NAMESPACE_ID::int32 val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tag_2eproto;
};
// -------------------------------------------------------------------

class Range PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.Range) */ {
 public:
  inline Range() : Range(nullptr) {};
  virtual ~Range();

  Range(const Range& from);
  Range(Range&& from) noexcept
    : Range() {
    *this = ::std::move(from);
  }

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline Range& operator=(Range&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Range& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Range* internal_default_instance() {
    return reinterpret_cast<const Range*>(
               &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Range& a, Range& b) {
    a.Swap(&b);
  }
  inline void Swap(Range* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Range* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Range* New() const final {
    return CreateMaybeMessage<Range>(nullptr);
  }

  Range* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Range>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Range& from);
  void MergeFrom(const Range& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Range* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.Range";
  }
  protected:
  explicit Range(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tag_2eproto);
    return ::descriptor_table_tag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 5,
    kNoteFieldNumber = 6,
    kCameraNameFieldNumber = 7,
    kStartTimeMsFieldNumber = 1,
    kDurationMsFieldNumber = 2,
    kStartFrameIdFieldNumber = 3,
    kEndFrameIdFieldNumber = 4,
  };
  // repeated .minieye.DataTag tags = 5;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::minieye::DataTag* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::DataTag >*
      mutable_tags();
  private:
  const ::minieye::DataTag& _internal_tags(int index) const;
  ::minieye::DataTag* _internal_add_tags();
  public:
  const ::minieye::DataTag& tags(int index) const;
  ::minieye::DataTag* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::DataTag >&
      tags() const;

  // string note = 6;
  void clear_note();
  const std::string& note() const;
  void set_note(const std::string& value);
  void set_note(std::string&& value);
  void set_note(const char* value);
  void set_note(const char* value, size_t size);
  std::string* mutable_note();
  std::string* release_note();
  void set_allocated_note(std::string* note);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_note();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_note(
      std::string* note);
  private:
  const std::string& _internal_note() const;
  void _internal_set_note(const std::string& value);
  std::string* _internal_mutable_note();
  public:

  // string camera_name = 7;
  void clear_camera_name();
  const std::string& camera_name() const;
  void set_camera_name(const std::string& value);
  void set_camera_name(std::string&& value);
  void set_camera_name(const char* value);
  void set_camera_name(const char* value, size_t size);
  std::string* mutable_camera_name();
  std::string* release_camera_name();
  void set_allocated_camera_name(std::string* camera_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_camera_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_camera_name(
      std::string* camera_name);
  private:
  const std::string& _internal_camera_name() const;
  void _internal_set_camera_name(const std::string& value);
  std::string* _internal_mutable_camera_name();
  public:

  // uint64 start_time_ms = 1;
  void clear_start_time_ms();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_time_ms() const;
  void set_start_time_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_start_time_ms() const;
  void _internal_set_start_time_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 duration_ms = 2;
  void clear_duration_ms();
  ::PROTOBUF_NAMESPACE_ID::uint64 duration_ms() const;
  void set_duration_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_duration_ms() const;
  void _internal_set_duration_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 start_frame_id = 3;
  void clear_start_frame_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_frame_id() const;
  void set_start_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_start_frame_id() const;
  void _internal_set_start_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 end_frame_id = 4;
  void clear_end_frame_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 end_frame_id() const;
  void set_end_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_end_frame_id() const;
  void _internal_set_end_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:minieye.Range)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::DataTag > tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_time_ms_;
  ::PROTOBUF_NAMESPACE_ID::uint64 duration_ms_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_frame_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 end_frame_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tag_2eproto;
};
// -------------------------------------------------------------------

class Tags PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:minieye.Tags) */ {
 public:
  inline Tags() : Tags(nullptr) {};
  virtual ~Tags();

  Tags(const Tags& from);
  Tags(Tags&& from) noexcept
    : Tags() {
    *this = ::std::move(from);
  }

  inline Tags& operator=(const Tags& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tags& operator=(Tags&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tags& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tags* internal_default_instance() {
    return reinterpret_cast<const Tags*>(
               &_Tags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Tags& a, Tags& b) {
    a.Swap(&b);
  }
  inline void Swap(Tags* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tags* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tags* New() const final {
    return CreateMaybeMessage<Tags>(nullptr);
  }

  Tags* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tags>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tags& from);
  void MergeFrom(const Tags& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tags* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "minieye.Tags";
  }
  protected:
  explicit Tags(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_tag_2eproto);
    return ::descriptor_table_tag_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 1,
    kRangesFieldNumber = 2,
  };
  // repeated .minieye.DataTag tags = 1;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::minieye::DataTag* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::DataTag >*
      mutable_tags();
  private:
  const ::minieye::DataTag& _internal_tags(int index) const;
  ::minieye::DataTag* _internal_add_tags();
  public:
  const ::minieye::DataTag& tags(int index) const;
  ::minieye::DataTag* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::DataTag >&
      tags() const;

  // repeated .minieye.Range ranges = 2;
  int ranges_size() const;
  private:
  int _internal_ranges_size() const;
  public:
  void clear_ranges();
  ::minieye::Range* mutable_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Range >*
      mutable_ranges();
  private:
  const ::minieye::Range& _internal_ranges(int index) const;
  ::minieye::Range* _internal_add_ranges();
  public:
  const ::minieye::Range& ranges(int index) const;
  ::minieye::Range* add_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Range >&
      ranges() const;

  // @@protoc_insertion_point(class_scope:minieye.Tags)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::DataTag > tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Range > ranges_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tag_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DataTag

// .minieye.DataTag.TagLabel label = 1;
inline void DataTag::clear_label() {
  label_ = 0;
}
inline ::minieye::DataTag_TagLabel DataTag::_internal_label() const {
  return static_cast< ::minieye::DataTag_TagLabel >(label_);
}
inline ::minieye::DataTag_TagLabel DataTag::label() const {
  // @@protoc_insertion_point(field_get:minieye.DataTag.label)
  return _internal_label();
}
inline void DataTag::_internal_set_label(::minieye::DataTag_TagLabel value) {
  
  label_ = value;
}
inline void DataTag::set_label(::minieye::DataTag_TagLabel value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:minieye.DataTag.label)
}

// int32 val = 2;
inline void DataTag::clear_val() {
  val_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataTag::_internal_val() const {
  return val_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DataTag::val() const {
  // @@protoc_insertion_point(field_get:minieye.DataTag.val)
  return _internal_val();
}
inline void DataTag::_internal_set_val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  val_ = value;
}
inline void DataTag::set_val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:minieye.DataTag.val)
}

// -------------------------------------------------------------------

// Range

// uint64 start_time_ms = 1;
inline void Range::clear_start_time_ms() {
  start_time_ms_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Range::_internal_start_time_ms() const {
  return start_time_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Range::start_time_ms() const {
  // @@protoc_insertion_point(field_get:minieye.Range.start_time_ms)
  return _internal_start_time_ms();
}
inline void Range::_internal_set_start_time_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  start_time_ms_ = value;
}
inline void Range::set_start_time_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_start_time_ms(value);
  // @@protoc_insertion_point(field_set:minieye.Range.start_time_ms)
}

// uint64 duration_ms = 2;
inline void Range::clear_duration_ms() {
  duration_ms_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Range::_internal_duration_ms() const {
  return duration_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Range::duration_ms() const {
  // @@protoc_insertion_point(field_get:minieye.Range.duration_ms)
  return _internal_duration_ms();
}
inline void Range::_internal_set_duration_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  duration_ms_ = value;
}
inline void Range::set_duration_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:minieye.Range.duration_ms)
}

// uint64 start_frame_id = 3;
inline void Range::clear_start_frame_id() {
  start_frame_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Range::_internal_start_frame_id() const {
  return start_frame_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Range::start_frame_id() const {
  // @@protoc_insertion_point(field_get:minieye.Range.start_frame_id)
  return _internal_start_frame_id();
}
inline void Range::_internal_set_start_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  start_frame_id_ = value;
}
inline void Range::set_start_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_start_frame_id(value);
  // @@protoc_insertion_point(field_set:minieye.Range.start_frame_id)
}

// uint64 end_frame_id = 4;
inline void Range::clear_end_frame_id() {
  end_frame_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Range::_internal_end_frame_id() const {
  return end_frame_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Range::end_frame_id() const {
  // @@protoc_insertion_point(field_get:minieye.Range.end_frame_id)
  return _internal_end_frame_id();
}
inline void Range::_internal_set_end_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  end_frame_id_ = value;
}
inline void Range::set_end_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_end_frame_id(value);
  // @@protoc_insertion_point(field_set:minieye.Range.end_frame_id)
}

// repeated .minieye.DataTag tags = 5;
inline int Range::_internal_tags_size() const {
  return tags_.size();
}
inline int Range::tags_size() const {
  return _internal_tags_size();
}
inline void Range::clear_tags() {
  tags_.Clear();
}
inline ::minieye::DataTag* Range::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.Range.tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::DataTag >*
Range::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:minieye.Range.tags)
  return &tags_;
}
inline const ::minieye::DataTag& Range::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::minieye::DataTag& Range::tags(int index) const {
  // @@protoc_insertion_point(field_get:minieye.Range.tags)
  return _internal_tags(index);
}
inline ::minieye::DataTag* Range::_internal_add_tags() {
  return tags_.Add();
}
inline ::minieye::DataTag* Range::add_tags() {
  // @@protoc_insertion_point(field_add:minieye.Range.tags)
  return _internal_add_tags();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::DataTag >&
Range::tags() const {
  // @@protoc_insertion_point(field_list:minieye.Range.tags)
  return tags_;
}

// string note = 6;
inline void Range::clear_note() {
  note_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Range::note() const {
  // @@protoc_insertion_point(field_get:minieye.Range.note)
  return _internal_note();
}
inline void Range::set_note(const std::string& value) {
  _internal_set_note(value);
  // @@protoc_insertion_point(field_set:minieye.Range.note)
}
inline std::string* Range::mutable_note() {
  // @@protoc_insertion_point(field_mutable:minieye.Range.note)
  return _internal_mutable_note();
}
inline const std::string& Range::_internal_note() const {
  return note_.Get();
}
inline void Range::_internal_set_note(const std::string& value) {
  
  note_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Range::set_note(std::string&& value) {
  
  note_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:minieye.Range.note)
}
inline void Range::set_note(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  note_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:minieye.Range.note)
}
inline void Range::set_note(const char* value,
    size_t size) {
  
  note_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:minieye.Range.note)
}
inline std::string* Range::_internal_mutable_note() {
  
  return note_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Range::release_note() {
  // @@protoc_insertion_point(field_release:minieye.Range.note)
  return note_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Range::set_allocated_note(std::string* note) {
  if (note != nullptr) {
    
  } else {
    
  }
  note_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), note,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:minieye.Range.note)
}
inline std::string* Range::unsafe_arena_release_note() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minieye.Range.note)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return note_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Range::unsafe_arena_set_allocated_note(
    std::string* note) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (note != nullptr) {
    
  } else {
    
  }
  note_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      note, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.Range.note)
}

// string camera_name = 7;
inline void Range::clear_camera_name() {
  camera_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Range::camera_name() const {
  // @@protoc_insertion_point(field_get:minieye.Range.camera_name)
  return _internal_camera_name();
}
inline void Range::set_camera_name(const std::string& value) {
  _internal_set_camera_name(value);
  // @@protoc_insertion_point(field_set:minieye.Range.camera_name)
}
inline std::string* Range::mutable_camera_name() {
  // @@protoc_insertion_point(field_mutable:minieye.Range.camera_name)
  return _internal_mutable_camera_name();
}
inline const std::string& Range::_internal_camera_name() const {
  return camera_name_.Get();
}
inline void Range::_internal_set_camera_name(const std::string& value) {
  
  camera_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Range::set_camera_name(std::string&& value) {
  
  camera_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:minieye.Range.camera_name)
}
inline void Range::set_camera_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  camera_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:minieye.Range.camera_name)
}
inline void Range::set_camera_name(const char* value,
    size_t size) {
  
  camera_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:minieye.Range.camera_name)
}
inline std::string* Range::_internal_mutable_camera_name() {
  
  return camera_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Range::release_camera_name() {
  // @@protoc_insertion_point(field_release:minieye.Range.camera_name)
  return camera_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Range::set_allocated_camera_name(std::string* camera_name) {
  if (camera_name != nullptr) {
    
  } else {
    
  }
  camera_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), camera_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:minieye.Range.camera_name)
}
inline std::string* Range::unsafe_arena_release_camera_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:minieye.Range.camera_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return camera_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Range::unsafe_arena_set_allocated_camera_name(
    std::string* camera_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (camera_name != nullptr) {
    
  } else {
    
  }
  camera_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      camera_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:minieye.Range.camera_name)
}

// -------------------------------------------------------------------

// Tags

// repeated .minieye.DataTag tags = 1;
inline int Tags::_internal_tags_size() const {
  return tags_.size();
}
inline int Tags::tags_size() const {
  return _internal_tags_size();
}
inline void Tags::clear_tags() {
  tags_.Clear();
}
inline ::minieye::DataTag* Tags::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.Tags.tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::DataTag >*
Tags::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:minieye.Tags.tags)
  return &tags_;
}
inline const ::minieye::DataTag& Tags::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::minieye::DataTag& Tags::tags(int index) const {
  // @@protoc_insertion_point(field_get:minieye.Tags.tags)
  return _internal_tags(index);
}
inline ::minieye::DataTag* Tags::_internal_add_tags() {
  return tags_.Add();
}
inline ::minieye::DataTag* Tags::add_tags() {
  // @@protoc_insertion_point(field_add:minieye.Tags.tags)
  return _internal_add_tags();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::DataTag >&
Tags::tags() const {
  // @@protoc_insertion_point(field_list:minieye.Tags.tags)
  return tags_;
}

// repeated .minieye.Range ranges = 2;
inline int Tags::_internal_ranges_size() const {
  return ranges_.size();
}
inline int Tags::ranges_size() const {
  return _internal_ranges_size();
}
inline void Tags::clear_ranges() {
  ranges_.Clear();
}
inline ::minieye::Range* Tags::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:minieye.Tags.ranges)
  return ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Range >*
Tags::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:minieye.Tags.ranges)
  return &ranges_;
}
inline const ::minieye::Range& Tags::_internal_ranges(int index) const {
  return ranges_.Get(index);
}
inline const ::minieye::Range& Tags::ranges(int index) const {
  // @@protoc_insertion_point(field_get:minieye.Tags.ranges)
  return _internal_ranges(index);
}
inline ::minieye::Range* Tags::_internal_add_ranges() {
  return ranges_.Add();
}
inline ::minieye::Range* Tags::add_ranges() {
  // @@protoc_insertion_point(field_add:minieye.Tags.ranges)
  return _internal_add_ranges();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::minieye::Range >&
Tags::ranges() const {
  // @@protoc_insertion_point(field_list:minieye.Tags.ranges)
  return ranges_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace minieye

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::minieye::DataTag_TagLabel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::DataTag_TagLabel>() {
  return ::minieye::DataTag_TagLabel_descriptor();
}
template <> struct is_proto_enum< ::minieye::RoadConditionTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::RoadConditionTag>() {
  return ::minieye::RoadConditionTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::ColorTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::ColorTag>() {
  return ::minieye::ColorTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::LanelineTypeTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::LanelineTypeTag>() {
  return ::minieye::LanelineTypeTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::SlopeTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::SlopeTag>() {
  return ::minieye::SlopeTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::WeatherCondTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::WeatherCondTag>() {
  return ::minieye::WeatherCondTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::IlluminationTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::IlluminationTag>() {
  return ::minieye::IlluminationTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::ObjTypeTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::ObjTypeTag>() {
  return ::minieye::ObjTypeTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::AreaTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::AreaTag>() {
  return ::minieye::AreaTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::WorkConditionTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::WorkConditionTag>() {
  return ::minieye::WorkConditionTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::ObjDistTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::ObjDistTag>() {
  return ::minieye::ObjDistTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::DensityTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::DensityTag>() {
  return ::minieye::DensityTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::PositionTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::PositionTag>() {
  return ::minieye::PositionTag_descriptor();
}
template <> struct is_proto_enum< ::minieye::StandardTag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::minieye::StandardTag>() {
  return ::minieye::StandardTag_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tag_2eproto
