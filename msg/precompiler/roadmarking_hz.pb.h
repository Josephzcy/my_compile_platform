// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: roadmarking_hz.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_roadmarking_5fhz_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_roadmarking_5fhz_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "geometry.pb.h"
#include "data_source.pb.h"
#include "odometry.pb.h"
#include "camera.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_roadmarking_5fhz_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_roadmarking_5fhz_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_roadmarking_5fhz_2eproto;
namespace perception {
namespace hz {
class RoadSysProfiling;
class RoadSysProfilingDefaultTypeInternal;
extern RoadSysProfilingDefaultTypeInternal _RoadSysProfiling_default_instance_;
class RoadSysProfiling_Item;
class RoadSysProfiling_ItemDefaultTypeInternal;
extern RoadSysProfiling_ItemDefaultTypeInternal _RoadSysProfiling_Item_default_instance_;
class Roadmarking;
class RoadmarkingDefaultTypeInternal;
extern RoadmarkingDefaultTypeInternal _Roadmarking_default_instance_;
class Roadmarking_CurveCoeff;
class Roadmarking_CurveCoeffDefaultTypeInternal;
extern Roadmarking_CurveCoeffDefaultTypeInternal _Roadmarking_CurveCoeff_default_instance_;
class Roadmarking_FreeSpaces;
class Roadmarking_FreeSpacesDefaultTypeInternal;
extern Roadmarking_FreeSpacesDefaultTypeInternal _Roadmarking_FreeSpaces_default_instance_;
class Roadmarking_FreeSpaces_FreeZone;
class Roadmarking_FreeSpaces_FreeZoneDefaultTypeInternal;
extern Roadmarking_FreeSpaces_FreeZoneDefaultTypeInternal _Roadmarking_FreeSpaces_FreeZone_default_instance_;
class Roadmarking_HppInfo;
class Roadmarking_HppInfoDefaultTypeInternal;
extern Roadmarking_HppInfoDefaultTypeInternal _Roadmarking_HppInfo_default_instance_;
class Roadmarking_Junction;
class Roadmarking_JunctionDefaultTypeInternal;
extern Roadmarking_JunctionDefaultTypeInternal _Roadmarking_Junction_default_instance_;
class Roadmarking_JunctionList;
class Roadmarking_JunctionListDefaultTypeInternal;
extern Roadmarking_JunctionListDefaultTypeInternal _Roadmarking_JunctionList_default_instance_;
class Roadmarking_LDWInfo;
class Roadmarking_LDWInfoDefaultTypeInternal;
extern Roadmarking_LDWInfoDefaultTypeInternal _Roadmarking_LDWInfo_default_instance_;
class Roadmarking_Laneline;
class Roadmarking_LanelineDefaultTypeInternal;
extern Roadmarking_LanelineDefaultTypeInternal _Roadmarking_Laneline_default_instance_;
class Roadmarking_LanelineList;
class Roadmarking_LanelineListDefaultTypeInternal;
extern Roadmarking_LanelineListDefaultTypeInternal _Roadmarking_LanelineList_default_instance_;
class Roadmarking_MotionEst;
class Roadmarking_MotionEstDefaultTypeInternal;
extern Roadmarking_MotionEstDefaultTypeInternal _Roadmarking_MotionEst_default_instance_;
class Roadmarking_PoseEst;
class Roadmarking_PoseEstDefaultTypeInternal;
extern Roadmarking_PoseEstDefaultTypeInternal _Roadmarking_PoseEst_default_instance_;
class Roadmarking_RoadEdge;
class Roadmarking_RoadEdgeDefaultTypeInternal;
extern Roadmarking_RoadEdgeDefaultTypeInternal _Roadmarking_RoadEdge_default_instance_;
class Roadmarking_RoadEdgeList;
class Roadmarking_RoadEdgeListDefaultTypeInternal;
extern Roadmarking_RoadEdgeListDefaultTypeInternal _Roadmarking_RoadEdgeList_default_instance_;
class Roadmarking_Roadmarks;
class Roadmarking_RoadmarksDefaultTypeInternal;
extern Roadmarking_RoadmarksDefaultTypeInternal _Roadmarking_Roadmarks_default_instance_;
class Roadmarking_Roadmarks_Roadmark;
class Roadmarking_Roadmarks_RoadmarkDefaultTypeInternal;
extern Roadmarking_Roadmarks_RoadmarkDefaultTypeInternal _Roadmarking_Roadmarks_Roadmark_default_instance_;
}  // namespace hz
}  // namespace perception
PROTOBUF_NAMESPACE_OPEN
template<> ::perception::hz::RoadSysProfiling* Arena::CreateMaybeMessage<::perception::hz::RoadSysProfiling>(Arena*);
template<> ::perception::hz::RoadSysProfiling_Item* Arena::CreateMaybeMessage<::perception::hz::RoadSysProfiling_Item>(Arena*);
template<> ::perception::hz::Roadmarking* Arena::CreateMaybeMessage<::perception::hz::Roadmarking>(Arena*);
template<> ::perception::hz::Roadmarking_CurveCoeff* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_CurveCoeff>(Arena*);
template<> ::perception::hz::Roadmarking_FreeSpaces* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_FreeSpaces>(Arena*);
template<> ::perception::hz::Roadmarking_FreeSpaces_FreeZone* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_FreeSpaces_FreeZone>(Arena*);
template<> ::perception::hz::Roadmarking_HppInfo* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_HppInfo>(Arena*);
template<> ::perception::hz::Roadmarking_Junction* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_Junction>(Arena*);
template<> ::perception::hz::Roadmarking_JunctionList* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_JunctionList>(Arena*);
template<> ::perception::hz::Roadmarking_LDWInfo* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_LDWInfo>(Arena*);
template<> ::perception::hz::Roadmarking_Laneline* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_Laneline>(Arena*);
template<> ::perception::hz::Roadmarking_LanelineList* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_LanelineList>(Arena*);
template<> ::perception::hz::Roadmarking_MotionEst* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_MotionEst>(Arena*);
template<> ::perception::hz::Roadmarking_PoseEst* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_PoseEst>(Arena*);
template<> ::perception::hz::Roadmarking_RoadEdge* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_RoadEdge>(Arena*);
template<> ::perception::hz::Roadmarking_RoadEdgeList* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_RoadEdgeList>(Arena*);
template<> ::perception::hz::Roadmarking_Roadmarks* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_Roadmarks>(Arena*);
template<> ::perception::hz::Roadmarking_Roadmarks_Roadmark* Arena::CreateMaybeMessage<::perception::hz::Roadmarking_Roadmarks_Roadmark>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace perception {
namespace hz {

enum Roadmarking_FreeSpaces_MotionProp : int {
  Roadmarking_FreeSpaces_MotionProp_kMovable = 0,
  Roadmarking_FreeSpaces_MotionProp_kUnmovable = 1,
  Roadmarking_FreeSpaces_MotionProp_kStill = 2,
  Roadmarking_FreeSpaces_MotionProp_Roadmarking_FreeSpaces_MotionProp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_FreeSpaces_MotionProp_Roadmarking_FreeSpaces_MotionProp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_FreeSpaces_MotionProp_IsValid(int value);
constexpr Roadmarking_FreeSpaces_MotionProp Roadmarking_FreeSpaces_MotionProp_MotionProp_MIN = Roadmarking_FreeSpaces_MotionProp_kMovable;
constexpr Roadmarking_FreeSpaces_MotionProp Roadmarking_FreeSpaces_MotionProp_MotionProp_MAX = Roadmarking_FreeSpaces_MotionProp_kStill;
constexpr int Roadmarking_FreeSpaces_MotionProp_MotionProp_ARRAYSIZE = Roadmarking_FreeSpaces_MotionProp_MotionProp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_FreeSpaces_MotionProp_descriptor();
template<typename T>
inline const std::string& Roadmarking_FreeSpaces_MotionProp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_FreeSpaces_MotionProp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_FreeSpaces_MotionProp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_FreeSpaces_MotionProp_descriptor(), enum_t_value);
}
inline bool Roadmarking_FreeSpaces_MotionProp_Parse(
    const std::string& name, Roadmarking_FreeSpaces_MotionProp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_FreeSpaces_MotionProp>(
    Roadmarking_FreeSpaces_MotionProp_descriptor(), name, value);
}
enum Roadmarking_Roadmarks_Type : int {
  Roadmarking_Roadmarks_Type_kBackGround = 0,
  Roadmarking_Roadmarks_Type_kStraightArrow = 1,
  Roadmarking_Roadmarks_Type_kLeftArrow = 2,
  Roadmarking_Roadmarks_Type_kRightArrow = 3,
  Roadmarking_Roadmarks_Type_kUturnArrow = 4,
  Roadmarking_Roadmarks_Type_kDiamond = 5,
  Roadmarking_Roadmarks_Type_kInvertedTriangle = 6,
  Roadmarking_Roadmarks_Type_kOppositemarks = 7,
  Roadmarking_Roadmarks_Type_kStopLane = 8,
  Roadmarking_Roadmarks_Type_kZebraCrossing = 9,
  Roadmarking_Roadmarks_Type_kNoParkingArea = 10,
  Roadmarking_Roadmarks_Type_kGoreArea = 11,
  Roadmarking_Roadmarks_Type_kGroundWords = 12,
  Roadmarking_Roadmarks_Type_kOthers = 13,
  Roadmarking_Roadmarks_Type_kDecelerationLine = 14,
  Roadmarking_Roadmarks_Type_kTypeNums = 15,
  Roadmarking_Roadmarks_Type_kSpeedBump = 16,
  Roadmarking_Roadmarks_Type_kManholeCover = 17,
  Roadmarking_Roadmarks_Type_Roadmarking_Roadmarks_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_Roadmarks_Type_Roadmarking_Roadmarks_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_Roadmarks_Type_IsValid(int value);
constexpr Roadmarking_Roadmarks_Type Roadmarking_Roadmarks_Type_Type_MIN = Roadmarking_Roadmarks_Type_kBackGround;
constexpr Roadmarking_Roadmarks_Type Roadmarking_Roadmarks_Type_Type_MAX = Roadmarking_Roadmarks_Type_kManholeCover;
constexpr int Roadmarking_Roadmarks_Type_Type_ARRAYSIZE = Roadmarking_Roadmarks_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_Roadmarks_Type_descriptor();
template<typename T>
inline const std::string& Roadmarking_Roadmarks_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_Roadmarks_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_Roadmarks_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_Roadmarks_Type_descriptor(), enum_t_value);
}
inline bool Roadmarking_Roadmarks_Type_Parse(
    const std::string& name, Roadmarking_Roadmarks_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_Roadmarks_Type>(
    Roadmarking_Roadmarks_Type_descriptor(), name, value);
}
enum Roadmarking_Roadmarks_Form : int {
  Roadmarking_Roadmarks_Form_kRoadmarkUnknown = 0,
  Roadmarking_Roadmarks_Form_kRoadmarkPoint = 1,
  Roadmarking_Roadmarks_Form_kRoadmarkLine = 2,
  Roadmarking_Roadmarks_Form_kRoadmarkPolygon = 3,
  Roadmarking_Roadmarks_Form_Roadmarking_Roadmarks_Form_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_Roadmarks_Form_Roadmarking_Roadmarks_Form_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_Roadmarks_Form_IsValid(int value);
constexpr Roadmarking_Roadmarks_Form Roadmarking_Roadmarks_Form_Form_MIN = Roadmarking_Roadmarks_Form_kRoadmarkUnknown;
constexpr Roadmarking_Roadmarks_Form Roadmarking_Roadmarks_Form_Form_MAX = Roadmarking_Roadmarks_Form_kRoadmarkPolygon;
constexpr int Roadmarking_Roadmarks_Form_Form_ARRAYSIZE = Roadmarking_Roadmarks_Form_Form_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_Roadmarks_Form_descriptor();
template<typename T>
inline const std::string& Roadmarking_Roadmarks_Form_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_Roadmarks_Form>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_Roadmarks_Form_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_Roadmarks_Form_descriptor(), enum_t_value);
}
inline bool Roadmarking_Roadmarks_Form_Parse(
    const std::string& name, Roadmarking_Roadmarks_Form* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_Roadmarks_Form>(
    Roadmarking_Roadmarks_Form_descriptor(), name, value);
}
enum Roadmarking_Roadmarks_State : int {
  Roadmarking_Roadmarks_State_kStateUnknown = 0,
  Roadmarking_Roadmarks_State_kObserved = 1,
  Roadmarking_Roadmarks_State_kPredicted = 2,
  Roadmarking_Roadmarks_State_kUpdated = 3,
  Roadmarking_Roadmarks_State_Roadmarking_Roadmarks_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_Roadmarks_State_Roadmarking_Roadmarks_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_Roadmarks_State_IsValid(int value);
constexpr Roadmarking_Roadmarks_State Roadmarking_Roadmarks_State_State_MIN = Roadmarking_Roadmarks_State_kStateUnknown;
constexpr Roadmarking_Roadmarks_State Roadmarking_Roadmarks_State_State_MAX = Roadmarking_Roadmarks_State_kUpdated;
constexpr int Roadmarking_Roadmarks_State_State_ARRAYSIZE = Roadmarking_Roadmarks_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_Roadmarks_State_descriptor();
template<typename T>
inline const std::string& Roadmarking_Roadmarks_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_Roadmarks_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_Roadmarks_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_Roadmarks_State_descriptor(), enum_t_value);
}
inline bool Roadmarking_Roadmarks_State_Parse(
    const std::string& name, Roadmarking_Roadmarks_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_Roadmarks_State>(
    Roadmarking_Roadmarks_State_descriptor(), name, value);
}
enum Roadmarking_LDWInfo_LdwState : int {
  Roadmarking_LDWInfo_LdwState_kLdwNone = 0,
  Roadmarking_LDWInfo_LdwState_kLdwLeft = 1,
  Roadmarking_LDWInfo_LdwState_kLdwRight = 2,
  Roadmarking_LDWInfo_LdwState_Roadmarking_LDWInfo_LdwState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_LDWInfo_LdwState_Roadmarking_LDWInfo_LdwState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_LDWInfo_LdwState_IsValid(int value);
constexpr Roadmarking_LDWInfo_LdwState Roadmarking_LDWInfo_LdwState_LdwState_MIN = Roadmarking_LDWInfo_LdwState_kLdwNone;
constexpr Roadmarking_LDWInfo_LdwState Roadmarking_LDWInfo_LdwState_LdwState_MAX = Roadmarking_LDWInfo_LdwState_kLdwRight;
constexpr int Roadmarking_LDWInfo_LdwState_LdwState_ARRAYSIZE = Roadmarking_LDWInfo_LdwState_LdwState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_LDWInfo_LdwState_descriptor();
template<typename T>
inline const std::string& Roadmarking_LDWInfo_LdwState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_LDWInfo_LdwState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_LDWInfo_LdwState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_LDWInfo_LdwState_descriptor(), enum_t_value);
}
inline bool Roadmarking_LDWInfo_LdwState_Parse(
    const std::string& name, Roadmarking_LDWInfo_LdwState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_LDWInfo_LdwState>(
    Roadmarking_LDWInfo_LdwState_descriptor(), name, value);
}
enum Roadmarking_LDWInfo_LdwWorkState : int {
  Roadmarking_LDWInfo_LdwWorkState_kUnavailable = 0,
  Roadmarking_LDWInfo_LdwWorkState_kOff = 1,
  Roadmarking_LDWInfo_LdwWorkState_kStandby = 2,
  Roadmarking_LDWInfo_LdwWorkState_kActive = 3,
  Roadmarking_LDWInfo_LdwWorkState_kNotAvailable = 4,
  Roadmarking_LDWInfo_LdwWorkState_kUnknown = 5,
  Roadmarking_LDWInfo_LdwWorkState_Roadmarking_LDWInfo_LdwWorkState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_LDWInfo_LdwWorkState_Roadmarking_LDWInfo_LdwWorkState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_LDWInfo_LdwWorkState_IsValid(int value);
constexpr Roadmarking_LDWInfo_LdwWorkState Roadmarking_LDWInfo_LdwWorkState_LdwWorkState_MIN = Roadmarking_LDWInfo_LdwWorkState_kUnavailable;
constexpr Roadmarking_LDWInfo_LdwWorkState Roadmarking_LDWInfo_LdwWorkState_LdwWorkState_MAX = Roadmarking_LDWInfo_LdwWorkState_kUnknown;
constexpr int Roadmarking_LDWInfo_LdwWorkState_LdwWorkState_ARRAYSIZE = Roadmarking_LDWInfo_LdwWorkState_LdwWorkState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_LDWInfo_LdwWorkState_descriptor();
template<typename T>
inline const std::string& Roadmarking_LDWInfo_LdwWorkState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_LDWInfo_LdwWorkState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_LDWInfo_LdwWorkState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_LDWInfo_LdwWorkState_descriptor(), enum_t_value);
}
inline bool Roadmarking_LDWInfo_LdwWorkState_Parse(
    const std::string& name, Roadmarking_LDWInfo_LdwWorkState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_LDWInfo_LdwWorkState>(
    Roadmarking_LDWInfo_LdwWorkState_descriptor(), name, value);
}
enum Roadmarking_HppInfo_PlanningSource : int {
  Roadmarking_HppInfo_PlanningSource_kInvalid = 0,
  Roadmarking_HppInfo_PlanningSource_kDoubleLaneline = 1,
  Roadmarking_HppInfo_PlanningSource_kLeftLaneline = 2,
  Roadmarking_HppInfo_PlanningSource_kRightLaneline = 3,
  Roadmarking_HppInfo_PlanningSource_kLeftRoadEdge = 4,
  Roadmarking_HppInfo_PlanningSource_kRightRoadEdge = 5,
  Roadmarking_HppInfo_PlanningSource_kHeadingVehTrace = 6,
  Roadmarking_HppInfo_PlanningSource_kFreespace = 7,
  Roadmarking_HppInfo_PlanningSource_kSelfVehTrace = 8,
  Roadmarking_HppInfo_PlanningSource_Roadmarking_HppInfo_PlanningSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_HppInfo_PlanningSource_Roadmarking_HppInfo_PlanningSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_HppInfo_PlanningSource_IsValid(int value);
constexpr Roadmarking_HppInfo_PlanningSource Roadmarking_HppInfo_PlanningSource_PlanningSource_MIN = Roadmarking_HppInfo_PlanningSource_kInvalid;
constexpr Roadmarking_HppInfo_PlanningSource Roadmarking_HppInfo_PlanningSource_PlanningSource_MAX = Roadmarking_HppInfo_PlanningSource_kSelfVehTrace;
constexpr int Roadmarking_HppInfo_PlanningSource_PlanningSource_ARRAYSIZE = Roadmarking_HppInfo_PlanningSource_PlanningSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_HppInfo_PlanningSource_descriptor();
template<typename T>
inline const std::string& Roadmarking_HppInfo_PlanningSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_HppInfo_PlanningSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_HppInfo_PlanningSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_HppInfo_PlanningSource_descriptor(), enum_t_value);
}
inline bool Roadmarking_HppInfo_PlanningSource_Parse(
    const std::string& name, Roadmarking_HppInfo_PlanningSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_HppInfo_PlanningSource>(
    Roadmarking_HppInfo_PlanningSource_descriptor(), name, value);
}
enum Roadmarking_Junction_Type : int {
  Roadmarking_Junction_Type_kMergingPoints = 0,
  Roadmarking_Junction_Type_kDivergingPoints = 1,
  Roadmarking_Junction_Type_Roadmarking_Junction_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_Junction_Type_Roadmarking_Junction_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_Junction_Type_IsValid(int value);
constexpr Roadmarking_Junction_Type Roadmarking_Junction_Type_Type_MIN = Roadmarking_Junction_Type_kMergingPoints;
constexpr Roadmarking_Junction_Type Roadmarking_Junction_Type_Type_MAX = Roadmarking_Junction_Type_kDivergingPoints;
constexpr int Roadmarking_Junction_Type_Type_ARRAYSIZE = Roadmarking_Junction_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_Junction_Type_descriptor();
template<typename T>
inline const std::string& Roadmarking_Junction_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_Junction_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_Junction_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_Junction_Type_descriptor(), enum_t_value);
}
inline bool Roadmarking_Junction_Type_Parse(
    const std::string& name, Roadmarking_Junction_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_Junction_Type>(
    Roadmarking_Junction_Type_descriptor(), name, value);
}
enum Roadmarking_LanelinePositionType : int {
  Roadmarking_LanelinePositionType_kAdjacentLeft = 0,
  Roadmarking_LanelinePositionType_kEgoLeft = 1,
  Roadmarking_LanelinePositionType_kEgoRight = 2,
  Roadmarking_LanelinePositionType_kAdjacentRight = 3,
  Roadmarking_LanelinePositionType_kThirdLeft = 4,
  Roadmarking_LanelinePositionType_kThirdRight = 5,
  Roadmarking_LanelinePositionType_kFourthLeft = 6,
  Roadmarking_LanelinePositionType_kFourthRight = 7,
  Roadmarking_LanelinePositionType_kOther = 8,
  Roadmarking_LanelinePositionType_Roadmarking_LanelinePositionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_LanelinePositionType_Roadmarking_LanelinePositionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_LanelinePositionType_IsValid(int value);
constexpr Roadmarking_LanelinePositionType Roadmarking_LanelinePositionType_LanelinePositionType_MIN = Roadmarking_LanelinePositionType_kAdjacentLeft;
constexpr Roadmarking_LanelinePositionType Roadmarking_LanelinePositionType_LanelinePositionType_MAX = Roadmarking_LanelinePositionType_kOther;
constexpr int Roadmarking_LanelinePositionType_LanelinePositionType_ARRAYSIZE = Roadmarking_LanelinePositionType_LanelinePositionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_LanelinePositionType_descriptor();
template<typename T>
inline const std::string& Roadmarking_LanelinePositionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_LanelinePositionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_LanelinePositionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_LanelinePositionType_descriptor(), enum_t_value);
}
inline bool Roadmarking_LanelinePositionType_Parse(
    const std::string& name, Roadmarking_LanelinePositionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_LanelinePositionType>(
    Roadmarking_LanelinePositionType_descriptor(), name, value);
}
enum Roadmarking_LineType : int {
  Roadmarking_LineType_kLineSingleSolid = 0,
  Roadmarking_LineType_kLineSingleDashed = 1,
  Roadmarking_LineType_kLineBold = 2,
  Roadmarking_LineType_kLineDoubleSolid = 3,
  Roadmarking_LineType_kLineDoubleDashed = 4,
  Roadmarking_LineType_kLineSolidDashed = 5,
  Roadmarking_LineType_kLineDashedSolid = 6,
  Roadmarking_LineType_kFence = 7,
  Roadmarking_LineType_kCurb = 8,
  Roadmarking_LineType_kLineDeceleration = 9,
  Roadmarking_LineType_kLineUnknown = 10,
  Roadmarking_LineType_Roadmarking_LineType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_LineType_Roadmarking_LineType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_LineType_IsValid(int value);
constexpr Roadmarking_LineType Roadmarking_LineType_LineType_MIN = Roadmarking_LineType_kLineSingleSolid;
constexpr Roadmarking_LineType Roadmarking_LineType_LineType_MAX = Roadmarking_LineType_kLineUnknown;
constexpr int Roadmarking_LineType_LineType_ARRAYSIZE = Roadmarking_LineType_LineType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_LineType_descriptor();
template<typename T>
inline const std::string& Roadmarking_LineType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_LineType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_LineType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_LineType_descriptor(), enum_t_value);
}
inline bool Roadmarking_LineType_Parse(
    const std::string& name, Roadmarking_LineType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_LineType>(
    Roadmarking_LineType_descriptor(), name, value);
}
enum Roadmarking_ColorType : int {
  Roadmarking_ColorType_kColorWhite = 0,
  Roadmarking_ColorType_kColorYellow = 1,
  Roadmarking_ColorType_kColorOrange = 2,
  Roadmarking_ColorType_kColorBlue = 3,
  Roadmarking_ColorType_kColorGreen = 4,
  Roadmarking_ColorType_kColorGray = 5,
  Roadmarking_ColorType_kColorWhiteYellow = 6,
  Roadmarking_ColorType_kColorYellowWhite = 7,
  Roadmarking_ColorType_kColorYellowGrayFusion = 8,
  Roadmarking_ColorType_kColorUnknown = 9,
  Roadmarking_ColorType_Roadmarking_ColorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_ColorType_Roadmarking_ColorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_ColorType_IsValid(int value);
constexpr Roadmarking_ColorType Roadmarking_ColorType_ColorType_MIN = Roadmarking_ColorType_kColorWhite;
constexpr Roadmarking_ColorType Roadmarking_ColorType_ColorType_MAX = Roadmarking_ColorType_kColorUnknown;
constexpr int Roadmarking_ColorType_ColorType_ARRAYSIZE = Roadmarking_ColorType_ColorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_ColorType_descriptor();
template<typename T>
inline const std::string& Roadmarking_ColorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_ColorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_ColorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_ColorType_descriptor(), enum_t_value);
}
inline bool Roadmarking_ColorType_Parse(
    const std::string& name, Roadmarking_ColorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_ColorType>(
    Roadmarking_ColorType_descriptor(), name, value);
}
enum Roadmarking_LineState : int {
  Roadmarking_LineState_kDetected = 0,
  Roadmarking_LineState_kPredicted = 1,
  Roadmarking_LineState_kStableTrack = 2,
  Roadmarking_LineState_Roadmarking_LineState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_LineState_Roadmarking_LineState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_LineState_IsValid(int value);
constexpr Roadmarking_LineState Roadmarking_LineState_LineState_MIN = Roadmarking_LineState_kDetected;
constexpr Roadmarking_LineState Roadmarking_LineState_LineState_MAX = Roadmarking_LineState_kStableTrack;
constexpr int Roadmarking_LineState_LineState_ARRAYSIZE = Roadmarking_LineState_LineState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_LineState_descriptor();
template<typename T>
inline const std::string& Roadmarking_LineState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_LineState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_LineState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_LineState_descriptor(), enum_t_value);
}
inline bool Roadmarking_LineState_Parse(
    const std::string& name, Roadmarking_LineState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_LineState>(
    Roadmarking_LineState_descriptor(), name, value);
}
enum Roadmarking_LaneIdx : int {
  Roadmarking_LaneIdx_kLaneIdxUnknown = 0,
  Roadmarking_LaneIdx_kEgoLane = 1,
  Roadmarking_LaneIdx_kAdjacentLeftLane = 2,
  Roadmarking_LaneIdx_kAdjacentRightLane = 3,
  Roadmarking_LaneIdx_kSecondaryLeftLane = 4,
  Roadmarking_LaneIdx_kSecondaryRightLane = 5,
  Roadmarking_LaneIdx_kThirdLeftLane = 6,
  Roadmarking_LaneIdx_kThirdRightLane = 7,
  Roadmarking_LaneIdx_Roadmarking_LaneIdx_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_LaneIdx_Roadmarking_LaneIdx_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_LaneIdx_IsValid(int value);
constexpr Roadmarking_LaneIdx Roadmarking_LaneIdx_LaneIdx_MIN = Roadmarking_LaneIdx_kLaneIdxUnknown;
constexpr Roadmarking_LaneIdx Roadmarking_LaneIdx_LaneIdx_MAX = Roadmarking_LaneIdx_kThirdRightLane;
constexpr int Roadmarking_LaneIdx_LaneIdx_ARRAYSIZE = Roadmarking_LaneIdx_LaneIdx_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_LaneIdx_descriptor();
template<typename T>
inline const std::string& Roadmarking_LaneIdx_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_LaneIdx>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_LaneIdx_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_LaneIdx_descriptor(), enum_t_value);
}
inline bool Roadmarking_LaneIdx_Parse(
    const std::string& name, Roadmarking_LaneIdx* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_LaneIdx>(
    Roadmarking_LaneIdx_descriptor(), name, value);
}
enum Roadmarking_SpaceType : int {
  Roadmarking_SpaceType_kBackground = 0,
  Roadmarking_SpaceType_kFreeSpace = 1,
  Roadmarking_SpaceType_kRoadBoundary = 2,
  Roadmarking_SpaceType_kVehicle = 3,
  Roadmarking_SpaceType_kRoadSign = 4,
  Roadmarking_SpaceType_kPole = 5,
  Roadmarking_SpaceType_kGuardrail = 6,
  Roadmarking_SpaceType_kSpaceTypeNums = 7,
  Roadmarking_SpaceType_Roadmarking_SpaceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_SpaceType_Roadmarking_SpaceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_SpaceType_IsValid(int value);
constexpr Roadmarking_SpaceType Roadmarking_SpaceType_SpaceType_MIN = Roadmarking_SpaceType_kBackground;
constexpr Roadmarking_SpaceType Roadmarking_SpaceType_SpaceType_MAX = Roadmarking_SpaceType_kSpaceTypeNums;
constexpr int Roadmarking_SpaceType_SpaceType_ARRAYSIZE = Roadmarking_SpaceType_SpaceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_SpaceType_descriptor();
template<typename T>
inline const std::string& Roadmarking_SpaceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_SpaceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_SpaceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_SpaceType_descriptor(), enum_t_value);
}
inline bool Roadmarking_SpaceType_Parse(
    const std::string& name, Roadmarking_SpaceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_SpaceType>(
    Roadmarking_SpaceType_descriptor(), name, value);
}
enum Roadmarking_DirectPosition : int {
  Roadmarking_DirectPosition_kDirectSame = 0,
  Roadmarking_DirectPosition_kDirectOpposite = 1,
  Roadmarking_DirectPosition_Roadmarking_DirectPosition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Roadmarking_DirectPosition_Roadmarking_DirectPosition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Roadmarking_DirectPosition_IsValid(int value);
constexpr Roadmarking_DirectPosition Roadmarking_DirectPosition_DirectPosition_MIN = Roadmarking_DirectPosition_kDirectSame;
constexpr Roadmarking_DirectPosition Roadmarking_DirectPosition_DirectPosition_MAX = Roadmarking_DirectPosition_kDirectOpposite;
constexpr int Roadmarking_DirectPosition_DirectPosition_ARRAYSIZE = Roadmarking_DirectPosition_DirectPosition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Roadmarking_DirectPosition_descriptor();
template<typename T>
inline const std::string& Roadmarking_DirectPosition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Roadmarking_DirectPosition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Roadmarking_DirectPosition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Roadmarking_DirectPosition_descriptor(), enum_t_value);
}
inline bool Roadmarking_DirectPosition_Parse(
    const std::string& name, Roadmarking_DirectPosition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Roadmarking_DirectPosition>(
    Roadmarking_DirectPosition_descriptor(), name, value);
}
// ===================================================================

class RoadSysProfiling_Item PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.RoadSysProfiling.Item) */ {
 public:
  inline RoadSysProfiling_Item() : RoadSysProfiling_Item(nullptr) {};
  virtual ~RoadSysProfiling_Item();

  RoadSysProfiling_Item(const RoadSysProfiling_Item& from);
  RoadSysProfiling_Item(RoadSysProfiling_Item&& from) noexcept
    : RoadSysProfiling_Item() {
    *this = ::std::move(from);
  }

  inline RoadSysProfiling_Item& operator=(const RoadSysProfiling_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadSysProfiling_Item& operator=(RoadSysProfiling_Item&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoadSysProfiling_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadSysProfiling_Item* internal_default_instance() {
    return reinterpret_cast<const RoadSysProfiling_Item*>(
               &_RoadSysProfiling_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RoadSysProfiling_Item& a, RoadSysProfiling_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadSysProfiling_Item* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadSysProfiling_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoadSysProfiling_Item* New() const final {
    return CreateMaybeMessage<RoadSysProfiling_Item>(nullptr);
  }

  RoadSysProfiling_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoadSysProfiling_Item>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoadSysProfiling_Item& from);
  void MergeFrom(const RoadSysProfiling_Item& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadSysProfiling_Item* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.RoadSysProfiling.Item";
  }
  protected:
  explicit RoadSysProfiling_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // float val = 2;
  void clear_val();
  float val() const;
  void set_val(float value);
  private:
  float _internal_val() const;
  void _internal_set_val(float value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.RoadSysProfiling.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  float val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class RoadSysProfiling PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.RoadSysProfiling) */ {
 public:
  inline RoadSysProfiling() : RoadSysProfiling(nullptr) {};
  virtual ~RoadSysProfiling();

  RoadSysProfiling(const RoadSysProfiling& from);
  RoadSysProfiling(RoadSysProfiling&& from) noexcept
    : RoadSysProfiling() {
    *this = ::std::move(from);
  }

  inline RoadSysProfiling& operator=(const RoadSysProfiling& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadSysProfiling& operator=(RoadSysProfiling&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoadSysProfiling& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadSysProfiling* internal_default_instance() {
    return reinterpret_cast<const RoadSysProfiling*>(
               &_RoadSysProfiling_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RoadSysProfiling& a, RoadSysProfiling& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadSysProfiling* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadSysProfiling* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoadSysProfiling* New() const final {
    return CreateMaybeMessage<RoadSysProfiling>(nullptr);
  }

  RoadSysProfiling* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoadSysProfiling>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoadSysProfiling& from);
  void MergeFrom(const RoadSysProfiling& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadSysProfiling* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.RoadSysProfiling";
  }
  protected:
  explicit RoadSysProfiling(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RoadSysProfiling_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 3,
  };
  // repeated .perception.hz.RoadSysProfiling.Item items = 3;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::perception::hz::RoadSysProfiling_Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::RoadSysProfiling_Item >*
      mutable_items();
  private:
  const ::perception::hz::RoadSysProfiling_Item& _internal_items(int index) const;
  ::perception::hz::RoadSysProfiling_Item* _internal_add_items();
  public:
  const ::perception::hz::RoadSysProfiling_Item& items(int index) const;
  ::perception::hz::RoadSysProfiling_Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::RoadSysProfiling_Item >&
      items() const;

  // @@protoc_insertion_point(class_scope:perception.hz.RoadSysProfiling)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::RoadSysProfiling_Item > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_CurveCoeff PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.CurveCoeff) */ {
 public:
  inline Roadmarking_CurveCoeff() : Roadmarking_CurveCoeff(nullptr) {};
  virtual ~Roadmarking_CurveCoeff();

  Roadmarking_CurveCoeff(const Roadmarking_CurveCoeff& from);
  Roadmarking_CurveCoeff(Roadmarking_CurveCoeff&& from) noexcept
    : Roadmarking_CurveCoeff() {
    *this = ::std::move(from);
  }

  inline Roadmarking_CurveCoeff& operator=(const Roadmarking_CurveCoeff& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_CurveCoeff& operator=(Roadmarking_CurveCoeff&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_CurveCoeff& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_CurveCoeff* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_CurveCoeff*>(
               &_Roadmarking_CurveCoeff_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Roadmarking_CurveCoeff& a, Roadmarking_CurveCoeff& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_CurveCoeff* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_CurveCoeff* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_CurveCoeff* New() const final {
    return CreateMaybeMessage<Roadmarking_CurveCoeff>(nullptr);
  }

  Roadmarking_CurveCoeff* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_CurveCoeff>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_CurveCoeff& from);
  void MergeFrom(const Roadmarking_CurveCoeff& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_CurveCoeff* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.CurveCoeff";
  }
  protected:
  explicit Roadmarking_CurveCoeff(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeMinFieldNumber = 1,
    kLongitudeMaxFieldNumber = 2,
    kC0FieldNumber = 3,
    kC1FieldNumber = 4,
    kC2FieldNumber = 5,
    kC3FieldNumber = 6,
    kDevC0FieldNumber = 7,
    kDevC1FieldNumber = 8,
    kDevC2FieldNumber = 9,
    kDevC3FieldNumber = 10,
  };
  // float longitude_min = 1;
  void clear_longitude_min();
  float longitude_min() const;
  void set_longitude_min(float value);
  private:
  float _internal_longitude_min() const;
  void _internal_set_longitude_min(float value);
  public:

  // float longitude_max = 2;
  void clear_longitude_max();
  float longitude_max() const;
  void set_longitude_max(float value);
  private:
  float _internal_longitude_max() const;
  void _internal_set_longitude_max(float value);
  public:

  // double c0 = 3;
  void clear_c0();
  double c0() const;
  void set_c0(double value);
  private:
  double _internal_c0() const;
  void _internal_set_c0(double value);
  public:

  // double c1 = 4;
  void clear_c1();
  double c1() const;
  void set_c1(double value);
  private:
  double _internal_c1() const;
  void _internal_set_c1(double value);
  public:

  // double c2 = 5;
  void clear_c2();
  double c2() const;
  void set_c2(double value);
  private:
  double _internal_c2() const;
  void _internal_set_c2(double value);
  public:

  // double c3 = 6;
  void clear_c3();
  double c3() const;
  void set_c3(double value);
  private:
  double _internal_c3() const;
  void _internal_set_c3(double value);
  public:

  // double dev_c0 = 7;
  void clear_dev_c0();
  double dev_c0() const;
  void set_dev_c0(double value);
  private:
  double _internal_dev_c0() const;
  void _internal_set_dev_c0(double value);
  public:

  // double dev_c1 = 8;
  void clear_dev_c1();
  double dev_c1() const;
  void set_dev_c1(double value);
  private:
  double _internal_dev_c1() const;
  void _internal_set_dev_c1(double value);
  public:

  // double dev_c2 = 9;
  void clear_dev_c2();
  double dev_c2() const;
  void set_dev_c2(double value);
  private:
  double _internal_dev_c2() const;
  void _internal_set_dev_c2(double value);
  public:

  // double dev_c3 = 10;
  void clear_dev_c3();
  double dev_c3() const;
  void set_dev_c3(double value);
  private:
  double _internal_dev_c3() const;
  void _internal_set_dev_c3(double value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.CurveCoeff)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float longitude_min_;
  float longitude_max_;
  double c0_;
  double c1_;
  double c2_;
  double c3_;
  double dev_c0_;
  double dev_c1_;
  double dev_c2_;
  double dev_c3_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_Laneline PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.Laneline) */ {
 public:
  inline Roadmarking_Laneline() : Roadmarking_Laneline(nullptr) {};
  virtual ~Roadmarking_Laneline();

  Roadmarking_Laneline(const Roadmarking_Laneline& from);
  Roadmarking_Laneline(Roadmarking_Laneline&& from) noexcept
    : Roadmarking_Laneline() {
    *this = ::std::move(from);
  }

  inline Roadmarking_Laneline& operator=(const Roadmarking_Laneline& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_Laneline& operator=(Roadmarking_Laneline&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_Laneline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_Laneline* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_Laneline*>(
               &_Roadmarking_Laneline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Roadmarking_Laneline& a, Roadmarking_Laneline& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_Laneline* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_Laneline* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_Laneline* New() const final {
    return CreateMaybeMessage<Roadmarking_Laneline>(nullptr);
  }

  Roadmarking_Laneline* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_Laneline>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_Laneline& from);
  void MergeFrom(const Roadmarking_Laneline& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_Laneline* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.Laneline";
  }
  protected:
  explicit Roadmarking_Laneline(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointCamIdFieldNumber = 15,
    kCurveVehicleCoordFieldNumber = 4,
    kCurveImageCoordFieldNumber = 5,
    kPointsImageCoordFieldNumber = 6,
    kPointsVehicleCoordFieldNumber = 7,
    kFitPointsImageCoordFieldNumber = 8,
    kFitPointsVehicleCoordFieldNumber = 9,
    kCentroidPtFieldNumber = 16,
    kTypeFieldNumber = 1,
    kPosTypeFieldNumber = 2,
    kColorTypeFieldNumber = 3,
    kLineStateFieldNumber = 11,
    kIdFieldNumber = 10,
    kConfidenceFieldNumber = 12,
    kWidthFieldNumber = 13,
    kAgeFieldNumber = 14,
    kLaneIdFieldNumber = 17,
  };
  // repeated uint32 point_cam_id = 15;
  int point_cam_id_size() const;
  private:
  int _internal_point_cam_id_size() const;
  public:
  void clear_point_cam_id();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_point_cam_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_point_cam_id() const;
  void _internal_add_point_cam_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_point_cam_id();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 point_cam_id(int index) const;
  void set_point_cam_id(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_point_cam_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      point_cam_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_point_cam_id();

  // .perception.hz.Roadmarking.CurveCoeff curve_vehicle_coord = 4;
  bool has_curve_vehicle_coord() const;
  private:
  bool _internal_has_curve_vehicle_coord() const;
  public:
  void clear_curve_vehicle_coord();
  const ::perception::hz::Roadmarking_CurveCoeff& curve_vehicle_coord() const;
  ::perception::hz::Roadmarking_CurveCoeff* release_curve_vehicle_coord();
  ::perception::hz::Roadmarking_CurveCoeff* mutable_curve_vehicle_coord();
  void set_allocated_curve_vehicle_coord(::perception::hz::Roadmarking_CurveCoeff* curve_vehicle_coord);
  private:
  const ::perception::hz::Roadmarking_CurveCoeff& _internal_curve_vehicle_coord() const;
  ::perception::hz::Roadmarking_CurveCoeff* _internal_mutable_curve_vehicle_coord();
  public:
  void unsafe_arena_set_allocated_curve_vehicle_coord(
      ::perception::hz::Roadmarking_CurveCoeff* curve_vehicle_coord);
  ::perception::hz::Roadmarking_CurveCoeff* unsafe_arena_release_curve_vehicle_coord();

  // .perception.hz.Roadmarking.CurveCoeff curve_image_coord = 5;
  bool has_curve_image_coord() const;
  private:
  bool _internal_has_curve_image_coord() const;
  public:
  void clear_curve_image_coord();
  const ::perception::hz::Roadmarking_CurveCoeff& curve_image_coord() const;
  ::perception::hz::Roadmarking_CurveCoeff* release_curve_image_coord();
  ::perception::hz::Roadmarking_CurveCoeff* mutable_curve_image_coord();
  void set_allocated_curve_image_coord(::perception::hz::Roadmarking_CurveCoeff* curve_image_coord);
  private:
  const ::perception::hz::Roadmarking_CurveCoeff& _internal_curve_image_coord() const;
  ::perception::hz::Roadmarking_CurveCoeff* _internal_mutable_curve_image_coord();
  public:
  void unsafe_arena_set_allocated_curve_image_coord(
      ::perception::hz::Roadmarking_CurveCoeff* curve_image_coord);
  ::perception::hz::Roadmarking_CurveCoeff* unsafe_arena_release_curve_image_coord();

  // .perception.common.Point2fList points_image_coord = 6;
  bool has_points_image_coord() const;
  private:
  bool _internal_has_points_image_coord() const;
  public:
  void clear_points_image_coord();
  const ::perception::common::Point2fList& points_image_coord() const;
  ::perception::common::Point2fList* release_points_image_coord();
  ::perception::common::Point2fList* mutable_points_image_coord();
  void set_allocated_points_image_coord(::perception::common::Point2fList* points_image_coord);
  private:
  const ::perception::common::Point2fList& _internal_points_image_coord() const;
  ::perception::common::Point2fList* _internal_mutable_points_image_coord();
  public:
  void unsafe_arena_set_allocated_points_image_coord(
      ::perception::common::Point2fList* points_image_coord);
  ::perception::common::Point2fList* unsafe_arena_release_points_image_coord();

  // .perception.common.Point3fList points_vehicle_coord = 7;
  bool has_points_vehicle_coord() const;
  private:
  bool _internal_has_points_vehicle_coord() const;
  public:
  void clear_points_vehicle_coord();
  const ::perception::common::Point3fList& points_vehicle_coord() const;
  ::perception::common::Point3fList* release_points_vehicle_coord();
  ::perception::common::Point3fList* mutable_points_vehicle_coord();
  void set_allocated_points_vehicle_coord(::perception::common::Point3fList* points_vehicle_coord);
  private:
  const ::perception::common::Point3fList& _internal_points_vehicle_coord() const;
  ::perception::common::Point3fList* _internal_mutable_points_vehicle_coord();
  public:
  void unsafe_arena_set_allocated_points_vehicle_coord(
      ::perception::common::Point3fList* points_vehicle_coord);
  ::perception::common::Point3fList* unsafe_arena_release_points_vehicle_coord();

  // .perception.common.Point2fList fit_points_image_coord = 8;
  bool has_fit_points_image_coord() const;
  private:
  bool _internal_has_fit_points_image_coord() const;
  public:
  void clear_fit_points_image_coord();
  const ::perception::common::Point2fList& fit_points_image_coord() const;
  ::perception::common::Point2fList* release_fit_points_image_coord();
  ::perception::common::Point2fList* mutable_fit_points_image_coord();
  void set_allocated_fit_points_image_coord(::perception::common::Point2fList* fit_points_image_coord);
  private:
  const ::perception::common::Point2fList& _internal_fit_points_image_coord() const;
  ::perception::common::Point2fList* _internal_mutable_fit_points_image_coord();
  public:
  void unsafe_arena_set_allocated_fit_points_image_coord(
      ::perception::common::Point2fList* fit_points_image_coord);
  ::perception::common::Point2fList* unsafe_arena_release_fit_points_image_coord();

  // .perception.common.Point3fList fit_points_vehicle_coord = 9;
  bool has_fit_points_vehicle_coord() const;
  private:
  bool _internal_has_fit_points_vehicle_coord() const;
  public:
  void clear_fit_points_vehicle_coord();
  const ::perception::common::Point3fList& fit_points_vehicle_coord() const;
  ::perception::common::Point3fList* release_fit_points_vehicle_coord();
  ::perception::common::Point3fList* mutable_fit_points_vehicle_coord();
  void set_allocated_fit_points_vehicle_coord(::perception::common::Point3fList* fit_points_vehicle_coord);
  private:
  const ::perception::common::Point3fList& _internal_fit_points_vehicle_coord() const;
  ::perception::common::Point3fList* _internal_mutable_fit_points_vehicle_coord();
  public:
  void unsafe_arena_set_allocated_fit_points_vehicle_coord(
      ::perception::common::Point3fList* fit_points_vehicle_coord);
  ::perception::common::Point3fList* unsafe_arena_release_fit_points_vehicle_coord();

  // .perception.common.Point2f centroid_pt = 16;
  bool has_centroid_pt() const;
  private:
  bool _internal_has_centroid_pt() const;
  public:
  void clear_centroid_pt();
  const ::perception::common::Point2f& centroid_pt() const;
  ::perception::common::Point2f* release_centroid_pt();
  ::perception::common::Point2f* mutable_centroid_pt();
  void set_allocated_centroid_pt(::perception::common::Point2f* centroid_pt);
  private:
  const ::perception::common::Point2f& _internal_centroid_pt() const;
  ::perception::common::Point2f* _internal_mutable_centroid_pt();
  public:
  void unsafe_arena_set_allocated_centroid_pt(
      ::perception::common::Point2f* centroid_pt);
  ::perception::common::Point2f* unsafe_arena_release_centroid_pt();

  // .perception.hz.Roadmarking.LineType type = 1;
  void clear_type();
  ::perception::hz::Roadmarking_LineType type() const;
  void set_type(::perception::hz::Roadmarking_LineType value);
  private:
  ::perception::hz::Roadmarking_LineType _internal_type() const;
  void _internal_set_type(::perception::hz::Roadmarking_LineType value);
  public:

  // .perception.hz.Roadmarking.LanelinePositionType pos_type = 2;
  void clear_pos_type();
  ::perception::hz::Roadmarking_LanelinePositionType pos_type() const;
  void set_pos_type(::perception::hz::Roadmarking_LanelinePositionType value);
  private:
  ::perception::hz::Roadmarking_LanelinePositionType _internal_pos_type() const;
  void _internal_set_pos_type(::perception::hz::Roadmarking_LanelinePositionType value);
  public:

  // .perception.hz.Roadmarking.ColorType color_type = 3;
  void clear_color_type();
  ::perception::hz::Roadmarking_ColorType color_type() const;
  void set_color_type(::perception::hz::Roadmarking_ColorType value);
  private:
  ::perception::hz::Roadmarking_ColorType _internal_color_type() const;
  void _internal_set_color_type(::perception::hz::Roadmarking_ColorType value);
  public:

  // .perception.hz.Roadmarking.LineState line_state = 11;
  void clear_line_state();
  ::perception::hz::Roadmarking_LineState line_state() const;
  void set_line_state(::perception::hz::Roadmarking_LineState value);
  private:
  ::perception::hz::Roadmarking_LineState _internal_line_state() const;
  void _internal_set_line_state(::perception::hz::Roadmarking_LineState value);
  public:

  // uint64 id = 10;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // float confidence = 12;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // float width = 13;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // uint32 age = 14;
  void clear_age();
  ::PROTOBUF_NAMESPACE_ID::uint32 age() const;
  void set_age(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_age() const;
  void _internal_set_age(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 lane_id = 17;
  void clear_lane_id();
  ::PROTOBUF_NAMESPACE_ID::int32 lane_id() const;
  void set_lane_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lane_id() const;
  void _internal_set_lane_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.Laneline)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > point_cam_id_;
  mutable std::atomic<int> _point_cam_id_cached_byte_size_;
  ::perception::hz::Roadmarking_CurveCoeff* curve_vehicle_coord_;
  ::perception::hz::Roadmarking_CurveCoeff* curve_image_coord_;
  ::perception::common::Point2fList* points_image_coord_;
  ::perception::common::Point3fList* points_vehicle_coord_;
  ::perception::common::Point2fList* fit_points_image_coord_;
  ::perception::common::Point3fList* fit_points_vehicle_coord_;
  ::perception::common::Point2f* centroid_pt_;
  int type_;
  int pos_type_;
  int color_type_;
  int line_state_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  float confidence_;
  float width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 age_;
  ::PROTOBUF_NAMESPACE_ID::int32 lane_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_LanelineList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.LanelineList) */ {
 public:
  inline Roadmarking_LanelineList() : Roadmarking_LanelineList(nullptr) {};
  virtual ~Roadmarking_LanelineList();

  Roadmarking_LanelineList(const Roadmarking_LanelineList& from);
  Roadmarking_LanelineList(Roadmarking_LanelineList&& from) noexcept
    : Roadmarking_LanelineList() {
    *this = ::std::move(from);
  }

  inline Roadmarking_LanelineList& operator=(const Roadmarking_LanelineList& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_LanelineList& operator=(Roadmarking_LanelineList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_LanelineList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_LanelineList* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_LanelineList*>(
               &_Roadmarking_LanelineList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Roadmarking_LanelineList& a, Roadmarking_LanelineList& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_LanelineList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_LanelineList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_LanelineList* New() const final {
    return CreateMaybeMessage<Roadmarking_LanelineList>(nullptr);
  }

  Roadmarking_LanelineList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_LanelineList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_LanelineList& from);
  void MergeFrom(const Roadmarking_LanelineList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_LanelineList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.LanelineList";
  }
  protected:
  explicit Roadmarking_LanelineList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineFieldNumber = 1,
  };
  // repeated .perception.hz.Roadmarking.Laneline line = 1;
  int line_size() const;
  private:
  int _internal_line_size() const;
  public:
  void clear_line();
  ::perception::hz::Roadmarking_Laneline* mutable_line(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Laneline >*
      mutable_line();
  private:
  const ::perception::hz::Roadmarking_Laneline& _internal_line(int index) const;
  ::perception::hz::Roadmarking_Laneline* _internal_add_line();
  public:
  const ::perception::hz::Roadmarking_Laneline& line(int index) const;
  ::perception::hz::Roadmarking_Laneline* add_line();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Laneline >&
      line() const;

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.LanelineList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Laneline > line_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_FreeSpaces_FreeZone PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.FreeSpaces.FreeZone) */ {
 public:
  inline Roadmarking_FreeSpaces_FreeZone() : Roadmarking_FreeSpaces_FreeZone(nullptr) {};
  virtual ~Roadmarking_FreeSpaces_FreeZone();

  Roadmarking_FreeSpaces_FreeZone(const Roadmarking_FreeSpaces_FreeZone& from);
  Roadmarking_FreeSpaces_FreeZone(Roadmarking_FreeSpaces_FreeZone&& from) noexcept
    : Roadmarking_FreeSpaces_FreeZone() {
    *this = ::std::move(from);
  }

  inline Roadmarking_FreeSpaces_FreeZone& operator=(const Roadmarking_FreeSpaces_FreeZone& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_FreeSpaces_FreeZone& operator=(Roadmarking_FreeSpaces_FreeZone&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_FreeSpaces_FreeZone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_FreeSpaces_FreeZone* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_FreeSpaces_FreeZone*>(
               &_Roadmarking_FreeSpaces_FreeZone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Roadmarking_FreeSpaces_FreeZone& a, Roadmarking_FreeSpaces_FreeZone& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_FreeSpaces_FreeZone* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_FreeSpaces_FreeZone* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_FreeSpaces_FreeZone* New() const final {
    return CreateMaybeMessage<Roadmarking_FreeSpaces_FreeZone>(nullptr);
  }

  Roadmarking_FreeSpaces_FreeZone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_FreeSpaces_FreeZone>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_FreeSpaces_FreeZone& from);
  void MergeFrom(const Roadmarking_FreeSpaces_FreeZone& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_FreeSpaces_FreeZone* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.FreeSpaces.FreeZone";
  }
  protected:
  explicit Roadmarking_FreeSpaces_FreeZone(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointImageCoordFieldNumber = 1,
    kPointVehicleCoordFieldNumber = 2,
    kDistFieldNumber = 3,
    kAngleFieldNumber = 4,
    kLaneIndexFieldNumber = 5,
    kConfidenceFieldNumber = 6,
    kTypeFieldNumber = 7,
    kMotionPropFieldNumber = 8,
    kCameraIdFieldNumber = 9,
    kSensorTypeFieldNumber = 10,
  };
  // .perception.common.Point2f point_image_coord = 1;
  bool has_point_image_coord() const;
  private:
  bool _internal_has_point_image_coord() const;
  public:
  void clear_point_image_coord();
  const ::perception::common::Point2f& point_image_coord() const;
  ::perception::common::Point2f* release_point_image_coord();
  ::perception::common::Point2f* mutable_point_image_coord();
  void set_allocated_point_image_coord(::perception::common::Point2f* point_image_coord);
  private:
  const ::perception::common::Point2f& _internal_point_image_coord() const;
  ::perception::common::Point2f* _internal_mutable_point_image_coord();
  public:
  void unsafe_arena_set_allocated_point_image_coord(
      ::perception::common::Point2f* point_image_coord);
  ::perception::common::Point2f* unsafe_arena_release_point_image_coord();

  // .perception.common.Point3f point_vehicle_coord = 2;
  bool has_point_vehicle_coord() const;
  private:
  bool _internal_has_point_vehicle_coord() const;
  public:
  void clear_point_vehicle_coord();
  const ::perception::common::Point3f& point_vehicle_coord() const;
  ::perception::common::Point3f* release_point_vehicle_coord();
  ::perception::common::Point3f* mutable_point_vehicle_coord();
  void set_allocated_point_vehicle_coord(::perception::common::Point3f* point_vehicle_coord);
  private:
  const ::perception::common::Point3f& _internal_point_vehicle_coord() const;
  ::perception::common::Point3f* _internal_mutable_point_vehicle_coord();
  public:
  void unsafe_arena_set_allocated_point_vehicle_coord(
      ::perception::common::Point3f* point_vehicle_coord);
  ::perception::common::Point3f* unsafe_arena_release_point_vehicle_coord();

  // float dist = 3;
  void clear_dist();
  float dist() const;
  void set_dist(float value);
  private:
  float _internal_dist() const;
  void _internal_set_dist(float value);
  public:

  // float angle = 4;
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // .perception.hz.Roadmarking.LaneIdx lane_index = 5;
  void clear_lane_index();
  ::perception::hz::Roadmarking_LaneIdx lane_index() const;
  void set_lane_index(::perception::hz::Roadmarking_LaneIdx value);
  private:
  ::perception::hz::Roadmarking_LaneIdx _internal_lane_index() const;
  void _internal_set_lane_index(::perception::hz::Roadmarking_LaneIdx value);
  public:

  // float confidence = 6;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // .perception.hz.Roadmarking.SpaceType type = 7;
  void clear_type();
  ::perception::hz::Roadmarking_SpaceType type() const;
  void set_type(::perception::hz::Roadmarking_SpaceType value);
  private:
  ::perception::hz::Roadmarking_SpaceType _internal_type() const;
  void _internal_set_type(::perception::hz::Roadmarking_SpaceType value);
  public:

  // .perception.hz.Roadmarking.FreeSpaces.MotionProp motion_prop = 8;
  void clear_motion_prop();
  ::perception::hz::Roadmarking_FreeSpaces_MotionProp motion_prop() const;
  void set_motion_prop(::perception::hz::Roadmarking_FreeSpaces_MotionProp value);
  private:
  ::perception::hz::Roadmarking_FreeSpaces_MotionProp _internal_motion_prop() const;
  void _internal_set_motion_prop(::perception::hz::Roadmarking_FreeSpaces_MotionProp value);
  public:

  // uint32 camera_id = 9;
  void clear_camera_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 camera_id() const;
  void set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_camera_id() const;
  void _internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 sensor_type = 10;
  void clear_sensor_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_type() const;
  void set_sensor_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sensor_type() const;
  void _internal_set_sensor_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.FreeSpaces.FreeZone)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::perception::common::Point2f* point_image_coord_;
  ::perception::common::Point3f* point_vehicle_coord_;
  float dist_;
  float angle_;
  int lane_index_;
  float confidence_;
  int type_;
  int motion_prop_;
  ::PROTOBUF_NAMESPACE_ID::uint32 camera_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensor_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_FreeSpaces PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.FreeSpaces) */ {
 public:
  inline Roadmarking_FreeSpaces() : Roadmarking_FreeSpaces(nullptr) {};
  virtual ~Roadmarking_FreeSpaces();

  Roadmarking_FreeSpaces(const Roadmarking_FreeSpaces& from);
  Roadmarking_FreeSpaces(Roadmarking_FreeSpaces&& from) noexcept
    : Roadmarking_FreeSpaces() {
    *this = ::std::move(from);
  }

  inline Roadmarking_FreeSpaces& operator=(const Roadmarking_FreeSpaces& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_FreeSpaces& operator=(Roadmarking_FreeSpaces&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_FreeSpaces& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_FreeSpaces* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_FreeSpaces*>(
               &_Roadmarking_FreeSpaces_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Roadmarking_FreeSpaces& a, Roadmarking_FreeSpaces& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_FreeSpaces* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_FreeSpaces* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_FreeSpaces* New() const final {
    return CreateMaybeMessage<Roadmarking_FreeSpaces>(nullptr);
  }

  Roadmarking_FreeSpaces* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_FreeSpaces>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_FreeSpaces& from);
  void MergeFrom(const Roadmarking_FreeSpaces& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_FreeSpaces* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.FreeSpaces";
  }
  protected:
  explicit Roadmarking_FreeSpaces(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Roadmarking_FreeSpaces_FreeZone FreeZone;

  typedef Roadmarking_FreeSpaces_MotionProp MotionProp;
  static constexpr MotionProp kMovable =
    Roadmarking_FreeSpaces_MotionProp_kMovable;
  static constexpr MotionProp kUnmovable =
    Roadmarking_FreeSpaces_MotionProp_kUnmovable;
  static constexpr MotionProp kStill =
    Roadmarking_FreeSpaces_MotionProp_kStill;
  static inline bool MotionProp_IsValid(int value) {
    return Roadmarking_FreeSpaces_MotionProp_IsValid(value);
  }
  static constexpr MotionProp MotionProp_MIN =
    Roadmarking_FreeSpaces_MotionProp_MotionProp_MIN;
  static constexpr MotionProp MotionProp_MAX =
    Roadmarking_FreeSpaces_MotionProp_MotionProp_MAX;
  static constexpr int MotionProp_ARRAYSIZE =
    Roadmarking_FreeSpaces_MotionProp_MotionProp_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MotionProp_descriptor() {
    return Roadmarking_FreeSpaces_MotionProp_descriptor();
  }
  template<typename T>
  static inline const std::string& MotionProp_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MotionProp>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MotionProp_Name.");
    return Roadmarking_FreeSpaces_MotionProp_Name(enum_t_value);
  }
  static inline bool MotionProp_Parse(const std::string& name,
      MotionProp* value) {
    return Roadmarking_FreeSpaces_MotionProp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFreezoneFieldNumber = 1,
    kDistStdFieldNumber = 2,
    kAngleStdFieldNumber = 3,
    kHeightStdFieldNumber = 4,
  };
  // repeated .perception.hz.Roadmarking.FreeSpaces.FreeZone freezone = 1;
  int freezone_size() const;
  private:
  int _internal_freezone_size() const;
  public:
  void clear_freezone();
  ::perception::hz::Roadmarking_FreeSpaces_FreeZone* mutable_freezone(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_FreeSpaces_FreeZone >*
      mutable_freezone();
  private:
  const ::perception::hz::Roadmarking_FreeSpaces_FreeZone& _internal_freezone(int index) const;
  ::perception::hz::Roadmarking_FreeSpaces_FreeZone* _internal_add_freezone();
  public:
  const ::perception::hz::Roadmarking_FreeSpaces_FreeZone& freezone(int index) const;
  ::perception::hz::Roadmarking_FreeSpaces_FreeZone* add_freezone();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_FreeSpaces_FreeZone >&
      freezone() const;

  // float dist_std = 2;
  void clear_dist_std();
  float dist_std() const;
  void set_dist_std(float value);
  private:
  float _internal_dist_std() const;
  void _internal_set_dist_std(float value);
  public:

  // float angle_std = 3;
  void clear_angle_std();
  float angle_std() const;
  void set_angle_std(float value);
  private:
  float _internal_angle_std() const;
  void _internal_set_angle_std(float value);
  public:

  // float height_std = 4;
  void clear_height_std();
  float height_std() const;
  void set_height_std(float value);
  private:
  float _internal_height_std() const;
  void _internal_set_height_std(float value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.FreeSpaces)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_FreeSpaces_FreeZone > freezone_;
  float dist_std_;
  float angle_std_;
  float height_std_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_RoadEdge PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.RoadEdge) */ {
 public:
  inline Roadmarking_RoadEdge() : Roadmarking_RoadEdge(nullptr) {};
  virtual ~Roadmarking_RoadEdge();

  Roadmarking_RoadEdge(const Roadmarking_RoadEdge& from);
  Roadmarking_RoadEdge(Roadmarking_RoadEdge&& from) noexcept
    : Roadmarking_RoadEdge() {
    *this = ::std::move(from);
  }

  inline Roadmarking_RoadEdge& operator=(const Roadmarking_RoadEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_RoadEdge& operator=(Roadmarking_RoadEdge&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_RoadEdge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_RoadEdge* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_RoadEdge*>(
               &_Roadmarking_RoadEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Roadmarking_RoadEdge& a, Roadmarking_RoadEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_RoadEdge* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_RoadEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_RoadEdge* New() const final {
    return CreateMaybeMessage<Roadmarking_RoadEdge>(nullptr);
  }

  Roadmarking_RoadEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_RoadEdge>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_RoadEdge& from);
  void MergeFrom(const Roadmarking_RoadEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_RoadEdge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.RoadEdge";
  }
  protected:
  explicit Roadmarking_RoadEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraIdFieldNumber = 12,
    kCurveVehicleCoordFieldNumber = 3,
    kCurveImageCoordFieldNumber = 4,
    kPointsVehicleCoordFieldNumber = 5,
    kPointsImageCoordFieldNumber = 6,
    kFitPointsImageCoordFieldNumber = 7,
    kFitPointsVehicleCoordFieldNumber = 8,
    kIdFieldNumber = 1,
    kAgeFieldNumber = 2,
    kStateFieldNumber = 9,
    kSideFieldNumber = 10,
    kConfidenceFieldNumber = 11,
  };
  // repeated uint32 camera_id = 12;
  int camera_id_size() const;
  private:
  int _internal_camera_id_size() const;
  public:
  void clear_camera_id();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_camera_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_camera_id() const;
  void _internal_add_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_camera_id();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 camera_id(int index) const;
  void set_camera_id(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      camera_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_camera_id();

  // .perception.hz.Roadmarking.CurveCoeff curve_vehicle_coord = 3;
  bool has_curve_vehicle_coord() const;
  private:
  bool _internal_has_curve_vehicle_coord() const;
  public:
  void clear_curve_vehicle_coord();
  const ::perception::hz::Roadmarking_CurveCoeff& curve_vehicle_coord() const;
  ::perception::hz::Roadmarking_CurveCoeff* release_curve_vehicle_coord();
  ::perception::hz::Roadmarking_CurveCoeff* mutable_curve_vehicle_coord();
  void set_allocated_curve_vehicle_coord(::perception::hz::Roadmarking_CurveCoeff* curve_vehicle_coord);
  private:
  const ::perception::hz::Roadmarking_CurveCoeff& _internal_curve_vehicle_coord() const;
  ::perception::hz::Roadmarking_CurveCoeff* _internal_mutable_curve_vehicle_coord();
  public:
  void unsafe_arena_set_allocated_curve_vehicle_coord(
      ::perception::hz::Roadmarking_CurveCoeff* curve_vehicle_coord);
  ::perception::hz::Roadmarking_CurveCoeff* unsafe_arena_release_curve_vehicle_coord();

  // .perception.hz.Roadmarking.CurveCoeff curve_image_coord = 4;
  bool has_curve_image_coord() const;
  private:
  bool _internal_has_curve_image_coord() const;
  public:
  void clear_curve_image_coord();
  const ::perception::hz::Roadmarking_CurveCoeff& curve_image_coord() const;
  ::perception::hz::Roadmarking_CurveCoeff* release_curve_image_coord();
  ::perception::hz::Roadmarking_CurveCoeff* mutable_curve_image_coord();
  void set_allocated_curve_image_coord(::perception::hz::Roadmarking_CurveCoeff* curve_image_coord);
  private:
  const ::perception::hz::Roadmarking_CurveCoeff& _internal_curve_image_coord() const;
  ::perception::hz::Roadmarking_CurveCoeff* _internal_mutable_curve_image_coord();
  public:
  void unsafe_arena_set_allocated_curve_image_coord(
      ::perception::hz::Roadmarking_CurveCoeff* curve_image_coord);
  ::perception::hz::Roadmarking_CurveCoeff* unsafe_arena_release_curve_image_coord();

  // .perception.common.Point3fList points_vehicle_coord = 5;
  bool has_points_vehicle_coord() const;
  private:
  bool _internal_has_points_vehicle_coord() const;
  public:
  void clear_points_vehicle_coord();
  const ::perception::common::Point3fList& points_vehicle_coord() const;
  ::perception::common::Point3fList* release_points_vehicle_coord();
  ::perception::common::Point3fList* mutable_points_vehicle_coord();
  void set_allocated_points_vehicle_coord(::perception::common::Point3fList* points_vehicle_coord);
  private:
  const ::perception::common::Point3fList& _internal_points_vehicle_coord() const;
  ::perception::common::Point3fList* _internal_mutable_points_vehicle_coord();
  public:
  void unsafe_arena_set_allocated_points_vehicle_coord(
      ::perception::common::Point3fList* points_vehicle_coord);
  ::perception::common::Point3fList* unsafe_arena_release_points_vehicle_coord();

  // .perception.common.Point2fList points_image_coord = 6;
  bool has_points_image_coord() const;
  private:
  bool _internal_has_points_image_coord() const;
  public:
  void clear_points_image_coord();
  const ::perception::common::Point2fList& points_image_coord() const;
  ::perception::common::Point2fList* release_points_image_coord();
  ::perception::common::Point2fList* mutable_points_image_coord();
  void set_allocated_points_image_coord(::perception::common::Point2fList* points_image_coord);
  private:
  const ::perception::common::Point2fList& _internal_points_image_coord() const;
  ::perception::common::Point2fList* _internal_mutable_points_image_coord();
  public:
  void unsafe_arena_set_allocated_points_image_coord(
      ::perception::common::Point2fList* points_image_coord);
  ::perception::common::Point2fList* unsafe_arena_release_points_image_coord();

  // .perception.common.Point2fList fit_points_image_coord = 7;
  bool has_fit_points_image_coord() const;
  private:
  bool _internal_has_fit_points_image_coord() const;
  public:
  void clear_fit_points_image_coord();
  const ::perception::common::Point2fList& fit_points_image_coord() const;
  ::perception::common::Point2fList* release_fit_points_image_coord();
  ::perception::common::Point2fList* mutable_fit_points_image_coord();
  void set_allocated_fit_points_image_coord(::perception::common::Point2fList* fit_points_image_coord);
  private:
  const ::perception::common::Point2fList& _internal_fit_points_image_coord() const;
  ::perception::common::Point2fList* _internal_mutable_fit_points_image_coord();
  public:
  void unsafe_arena_set_allocated_fit_points_image_coord(
      ::perception::common::Point2fList* fit_points_image_coord);
  ::perception::common::Point2fList* unsafe_arena_release_fit_points_image_coord();

  // .perception.common.Point3fList fit_points_vehicle_coord = 8;
  bool has_fit_points_vehicle_coord() const;
  private:
  bool _internal_has_fit_points_vehicle_coord() const;
  public:
  void clear_fit_points_vehicle_coord();
  const ::perception::common::Point3fList& fit_points_vehicle_coord() const;
  ::perception::common::Point3fList* release_fit_points_vehicle_coord();
  ::perception::common::Point3fList* mutable_fit_points_vehicle_coord();
  void set_allocated_fit_points_vehicle_coord(::perception::common::Point3fList* fit_points_vehicle_coord);
  private:
  const ::perception::common::Point3fList& _internal_fit_points_vehicle_coord() const;
  ::perception::common::Point3fList* _internal_mutable_fit_points_vehicle_coord();
  public:
  void unsafe_arena_set_allocated_fit_points_vehicle_coord(
      ::perception::common::Point3fList* fit_points_vehicle_coord);
  ::perception::common::Point3fList* unsafe_arena_release_fit_points_vehicle_coord();

  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 age = 2;
  void clear_age();
  ::PROTOBUF_NAMESPACE_ID::uint32 age() const;
  void set_age(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_age() const;
  void _internal_set_age(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .perception.hz.Roadmarking.LineState state = 9;
  void clear_state();
  ::perception::hz::Roadmarking_LineState state() const;
  void set_state(::perception::hz::Roadmarking_LineState value);
  private:
  ::perception::hz::Roadmarking_LineState _internal_state() const;
  void _internal_set_state(::perception::hz::Roadmarking_LineState value);
  public:

  // int32 side = 10;
  void clear_side();
  ::PROTOBUF_NAMESPACE_ID::int32 side() const;
  void set_side(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_side() const;
  void _internal_set_side(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float confidence = 11;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.RoadEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > camera_id_;
  mutable std::atomic<int> _camera_id_cached_byte_size_;
  ::perception::hz::Roadmarking_CurveCoeff* curve_vehicle_coord_;
  ::perception::hz::Roadmarking_CurveCoeff* curve_image_coord_;
  ::perception::common::Point3fList* points_vehicle_coord_;
  ::perception::common::Point2fList* points_image_coord_;
  ::perception::common::Point2fList* fit_points_image_coord_;
  ::perception::common::Point3fList* fit_points_vehicle_coord_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 age_;
  int state_;
  ::PROTOBUF_NAMESPACE_ID::int32 side_;
  float confidence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_RoadEdgeList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.RoadEdgeList) */ {
 public:
  inline Roadmarking_RoadEdgeList() : Roadmarking_RoadEdgeList(nullptr) {};
  virtual ~Roadmarking_RoadEdgeList();

  Roadmarking_RoadEdgeList(const Roadmarking_RoadEdgeList& from);
  Roadmarking_RoadEdgeList(Roadmarking_RoadEdgeList&& from) noexcept
    : Roadmarking_RoadEdgeList() {
    *this = ::std::move(from);
  }

  inline Roadmarking_RoadEdgeList& operator=(const Roadmarking_RoadEdgeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_RoadEdgeList& operator=(Roadmarking_RoadEdgeList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_RoadEdgeList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_RoadEdgeList* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_RoadEdgeList*>(
               &_Roadmarking_RoadEdgeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Roadmarking_RoadEdgeList& a, Roadmarking_RoadEdgeList& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_RoadEdgeList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_RoadEdgeList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_RoadEdgeList* New() const final {
    return CreateMaybeMessage<Roadmarking_RoadEdgeList>(nullptr);
  }

  Roadmarking_RoadEdgeList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_RoadEdgeList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_RoadEdgeList& from);
  void MergeFrom(const Roadmarking_RoadEdgeList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_RoadEdgeList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.RoadEdgeList";
  }
  protected:
  explicit Roadmarking_RoadEdgeList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoadEdgesFieldNumber = 1,
  };
  // repeated .perception.hz.Roadmarking.RoadEdge road_edges = 1;
  int road_edges_size() const;
  private:
  int _internal_road_edges_size() const;
  public:
  void clear_road_edges();
  ::perception::hz::Roadmarking_RoadEdge* mutable_road_edges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_RoadEdge >*
      mutable_road_edges();
  private:
  const ::perception::hz::Roadmarking_RoadEdge& _internal_road_edges(int index) const;
  ::perception::hz::Roadmarking_RoadEdge* _internal_add_road_edges();
  public:
  const ::perception::hz::Roadmarking_RoadEdge& road_edges(int index) const;
  ::perception::hz::Roadmarking_RoadEdge* add_road_edges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_RoadEdge >&
      road_edges() const;

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.RoadEdgeList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_RoadEdge > road_edges_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_Roadmarks_Roadmark PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.Roadmarks.Roadmark) */ {
 public:
  inline Roadmarking_Roadmarks_Roadmark() : Roadmarking_Roadmarks_Roadmark(nullptr) {};
  virtual ~Roadmarking_Roadmarks_Roadmark();

  Roadmarking_Roadmarks_Roadmark(const Roadmarking_Roadmarks_Roadmark& from);
  Roadmarking_Roadmarks_Roadmark(Roadmarking_Roadmarks_Roadmark&& from) noexcept
    : Roadmarking_Roadmarks_Roadmark() {
    *this = ::std::move(from);
  }

  inline Roadmarking_Roadmarks_Roadmark& operator=(const Roadmarking_Roadmarks_Roadmark& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_Roadmarks_Roadmark& operator=(Roadmarking_Roadmarks_Roadmark&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_Roadmarks_Roadmark& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_Roadmarks_Roadmark* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_Roadmarks_Roadmark*>(
               &_Roadmarking_Roadmarks_Roadmark_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Roadmarking_Roadmarks_Roadmark& a, Roadmarking_Roadmarks_Roadmark& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_Roadmarks_Roadmark* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_Roadmarks_Roadmark* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_Roadmarks_Roadmark* New() const final {
    return CreateMaybeMessage<Roadmarking_Roadmarks_Roadmark>(nullptr);
  }

  Roadmarking_Roadmarks_Roadmark* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_Roadmarks_Roadmark>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_Roadmarks_Roadmark& from);
  void MergeFrom(const Roadmarking_Roadmarks_Roadmark& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_Roadmarks_Roadmark* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.Roadmarks.Roadmark";
  }
  protected:
  explicit Roadmarking_Roadmarks_Roadmark(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCornerPtImageCoordFieldNumber = 3,
    kCornerPtVehicleCoordFieldNumber = 4,
    kCentroidVehicleCoordFieldNumber = 5,
    kCentroidImageCoordFieldNumber = 10,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kConfidenceFieldNumber = 6,
    kLaneIdxFieldNumber = 7,
    kFormFieldNumber = 8,
    kStateFieldNumber = 9,
    kWidthFieldNumber = 11,
    kCameraIdFieldNumber = 12,
  };
  // .perception.common.Point2fList corner_pt_image_coord = 3;
  bool has_corner_pt_image_coord() const;
  private:
  bool _internal_has_corner_pt_image_coord() const;
  public:
  void clear_corner_pt_image_coord();
  const ::perception::common::Point2fList& corner_pt_image_coord() const;
  ::perception::common::Point2fList* release_corner_pt_image_coord();
  ::perception::common::Point2fList* mutable_corner_pt_image_coord();
  void set_allocated_corner_pt_image_coord(::perception::common::Point2fList* corner_pt_image_coord);
  private:
  const ::perception::common::Point2fList& _internal_corner_pt_image_coord() const;
  ::perception::common::Point2fList* _internal_mutable_corner_pt_image_coord();
  public:
  void unsafe_arena_set_allocated_corner_pt_image_coord(
      ::perception::common::Point2fList* corner_pt_image_coord);
  ::perception::common::Point2fList* unsafe_arena_release_corner_pt_image_coord();

  // .perception.common.Point3fList corner_pt_vehicle_coord = 4;
  bool has_corner_pt_vehicle_coord() const;
  private:
  bool _internal_has_corner_pt_vehicle_coord() const;
  public:
  void clear_corner_pt_vehicle_coord();
  const ::perception::common::Point3fList& corner_pt_vehicle_coord() const;
  ::perception::common::Point3fList* release_corner_pt_vehicle_coord();
  ::perception::common::Point3fList* mutable_corner_pt_vehicle_coord();
  void set_allocated_corner_pt_vehicle_coord(::perception::common::Point3fList* corner_pt_vehicle_coord);
  private:
  const ::perception::common::Point3fList& _internal_corner_pt_vehicle_coord() const;
  ::perception::common::Point3fList* _internal_mutable_corner_pt_vehicle_coord();
  public:
  void unsafe_arena_set_allocated_corner_pt_vehicle_coord(
      ::perception::common::Point3fList* corner_pt_vehicle_coord);
  ::perception::common::Point3fList* unsafe_arena_release_corner_pt_vehicle_coord();

  // .perception.common.Point3f centroid_vehicle_coord = 5;
  bool has_centroid_vehicle_coord() const;
  private:
  bool _internal_has_centroid_vehicle_coord() const;
  public:
  void clear_centroid_vehicle_coord();
  const ::perception::common::Point3f& centroid_vehicle_coord() const;
  ::perception::common::Point3f* release_centroid_vehicle_coord();
  ::perception::common::Point3f* mutable_centroid_vehicle_coord();
  void set_allocated_centroid_vehicle_coord(::perception::common::Point3f* centroid_vehicle_coord);
  private:
  const ::perception::common::Point3f& _internal_centroid_vehicle_coord() const;
  ::perception::common::Point3f* _internal_mutable_centroid_vehicle_coord();
  public:
  void unsafe_arena_set_allocated_centroid_vehicle_coord(
      ::perception::common::Point3f* centroid_vehicle_coord);
  ::perception::common::Point3f* unsafe_arena_release_centroid_vehicle_coord();

  // .perception.common.Point2f centroid_image_coord = 10;
  bool has_centroid_image_coord() const;
  private:
  bool _internal_has_centroid_image_coord() const;
  public:
  void clear_centroid_image_coord();
  const ::perception::common::Point2f& centroid_image_coord() const;
  ::perception::common::Point2f* release_centroid_image_coord();
  ::perception::common::Point2f* mutable_centroid_image_coord();
  void set_allocated_centroid_image_coord(::perception::common::Point2f* centroid_image_coord);
  private:
  const ::perception::common::Point2f& _internal_centroid_image_coord() const;
  ::perception::common::Point2f* _internal_mutable_centroid_image_coord();
  public:
  void unsafe_arena_set_allocated_centroid_image_coord(
      ::perception::common::Point2f* centroid_image_coord);
  ::perception::common::Point2f* unsafe_arena_release_centroid_image_coord();

  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .perception.hz.Roadmarking.Roadmarks.Type type = 2;
  void clear_type();
  ::perception::hz::Roadmarking_Roadmarks_Type type() const;
  void set_type(::perception::hz::Roadmarking_Roadmarks_Type value);
  private:
  ::perception::hz::Roadmarking_Roadmarks_Type _internal_type() const;
  void _internal_set_type(::perception::hz::Roadmarking_Roadmarks_Type value);
  public:

  // float confidence = 6;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // uint32 lane_idx = 7;
  void clear_lane_idx();
  ::PROTOBUF_NAMESPACE_ID::uint32 lane_idx() const;
  void set_lane_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lane_idx() const;
  void _internal_set_lane_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .perception.hz.Roadmarking.Roadmarks.Form form = 8;
  void clear_form();
  ::perception::hz::Roadmarking_Roadmarks_Form form() const;
  void set_form(::perception::hz::Roadmarking_Roadmarks_Form value);
  private:
  ::perception::hz::Roadmarking_Roadmarks_Form _internal_form() const;
  void _internal_set_form(::perception::hz::Roadmarking_Roadmarks_Form value);
  public:

  // .perception.hz.Roadmarking.Roadmarks.State state = 9;
  void clear_state();
  ::perception::hz::Roadmarking_Roadmarks_State state() const;
  void set_state(::perception::hz::Roadmarking_Roadmarks_State value);
  private:
  ::perception::hz::Roadmarking_Roadmarks_State _internal_state() const;
  void _internal_set_state(::perception::hz::Roadmarking_Roadmarks_State value);
  public:

  // float width = 11;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // uint32 camera_id = 12;
  void clear_camera_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 camera_id() const;
  void set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_camera_id() const;
  void _internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.Roadmarks.Roadmark)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::perception::common::Point2fList* corner_pt_image_coord_;
  ::perception::common::Point3fList* corner_pt_vehicle_coord_;
  ::perception::common::Point3f* centroid_vehicle_coord_;
  ::perception::common::Point2f* centroid_image_coord_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  int type_;
  float confidence_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lane_idx_;
  int form_;
  int state_;
  float width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 camera_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_Roadmarks PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.Roadmarks) */ {
 public:
  inline Roadmarking_Roadmarks() : Roadmarking_Roadmarks(nullptr) {};
  virtual ~Roadmarking_Roadmarks();

  Roadmarking_Roadmarks(const Roadmarking_Roadmarks& from);
  Roadmarking_Roadmarks(Roadmarking_Roadmarks&& from) noexcept
    : Roadmarking_Roadmarks() {
    *this = ::std::move(from);
  }

  inline Roadmarking_Roadmarks& operator=(const Roadmarking_Roadmarks& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_Roadmarks& operator=(Roadmarking_Roadmarks&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_Roadmarks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_Roadmarks* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_Roadmarks*>(
               &_Roadmarking_Roadmarks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Roadmarking_Roadmarks& a, Roadmarking_Roadmarks& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_Roadmarks* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_Roadmarks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_Roadmarks* New() const final {
    return CreateMaybeMessage<Roadmarking_Roadmarks>(nullptr);
  }

  Roadmarking_Roadmarks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_Roadmarks>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_Roadmarks& from);
  void MergeFrom(const Roadmarking_Roadmarks& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_Roadmarks* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.Roadmarks";
  }
  protected:
  explicit Roadmarking_Roadmarks(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Roadmarking_Roadmarks_Roadmark Roadmark;

  typedef Roadmarking_Roadmarks_Type Type;
  static constexpr Type kBackGround =
    Roadmarking_Roadmarks_Type_kBackGround;
  static constexpr Type kStraightArrow =
    Roadmarking_Roadmarks_Type_kStraightArrow;
  static constexpr Type kLeftArrow =
    Roadmarking_Roadmarks_Type_kLeftArrow;
  static constexpr Type kRightArrow =
    Roadmarking_Roadmarks_Type_kRightArrow;
  static constexpr Type kUturnArrow =
    Roadmarking_Roadmarks_Type_kUturnArrow;
  static constexpr Type kDiamond =
    Roadmarking_Roadmarks_Type_kDiamond;
  static constexpr Type kInvertedTriangle =
    Roadmarking_Roadmarks_Type_kInvertedTriangle;
  static constexpr Type kOppositemarks =
    Roadmarking_Roadmarks_Type_kOppositemarks;
  static constexpr Type kStopLane =
    Roadmarking_Roadmarks_Type_kStopLane;
  static constexpr Type kZebraCrossing =
    Roadmarking_Roadmarks_Type_kZebraCrossing;
  static constexpr Type kNoParkingArea =
    Roadmarking_Roadmarks_Type_kNoParkingArea;
  static constexpr Type kGoreArea =
    Roadmarking_Roadmarks_Type_kGoreArea;
  static constexpr Type kGroundWords =
    Roadmarking_Roadmarks_Type_kGroundWords;
  static constexpr Type kOthers =
    Roadmarking_Roadmarks_Type_kOthers;
  static constexpr Type kDecelerationLine =
    Roadmarking_Roadmarks_Type_kDecelerationLine;
  static constexpr Type kTypeNums =
    Roadmarking_Roadmarks_Type_kTypeNums;
  static constexpr Type kSpeedBump =
    Roadmarking_Roadmarks_Type_kSpeedBump;
  static constexpr Type kManholeCover =
    Roadmarking_Roadmarks_Type_kManholeCover;
  static inline bool Type_IsValid(int value) {
    return Roadmarking_Roadmarks_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Roadmarking_Roadmarks_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Roadmarking_Roadmarks_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Roadmarking_Roadmarks_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Roadmarking_Roadmarks_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Roadmarking_Roadmarks_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return Roadmarking_Roadmarks_Type_Parse(name, value);
  }

  typedef Roadmarking_Roadmarks_Form Form;
  static constexpr Form kRoadmarkUnknown =
    Roadmarking_Roadmarks_Form_kRoadmarkUnknown;
  static constexpr Form kRoadmarkPoint =
    Roadmarking_Roadmarks_Form_kRoadmarkPoint;
  static constexpr Form kRoadmarkLine =
    Roadmarking_Roadmarks_Form_kRoadmarkLine;
  static constexpr Form kRoadmarkPolygon =
    Roadmarking_Roadmarks_Form_kRoadmarkPolygon;
  static inline bool Form_IsValid(int value) {
    return Roadmarking_Roadmarks_Form_IsValid(value);
  }
  static constexpr Form Form_MIN =
    Roadmarking_Roadmarks_Form_Form_MIN;
  static constexpr Form Form_MAX =
    Roadmarking_Roadmarks_Form_Form_MAX;
  static constexpr int Form_ARRAYSIZE =
    Roadmarking_Roadmarks_Form_Form_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Form_descriptor() {
    return Roadmarking_Roadmarks_Form_descriptor();
  }
  template<typename T>
  static inline const std::string& Form_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Form>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Form_Name.");
    return Roadmarking_Roadmarks_Form_Name(enum_t_value);
  }
  static inline bool Form_Parse(const std::string& name,
      Form* value) {
    return Roadmarking_Roadmarks_Form_Parse(name, value);
  }

  typedef Roadmarking_Roadmarks_State State;
  static constexpr State kStateUnknown =
    Roadmarking_Roadmarks_State_kStateUnknown;
  static constexpr State kObserved =
    Roadmarking_Roadmarks_State_kObserved;
  static constexpr State kPredicted =
    Roadmarking_Roadmarks_State_kPredicted;
  static constexpr State kUpdated =
    Roadmarking_Roadmarks_State_kUpdated;
  static inline bool State_IsValid(int value) {
    return Roadmarking_Roadmarks_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Roadmarking_Roadmarks_State_State_MIN;
  static constexpr State State_MAX =
    Roadmarking_Roadmarks_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Roadmarking_Roadmarks_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Roadmarking_Roadmarks_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Roadmarking_Roadmarks_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return Roadmarking_Roadmarks_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRoadmarksFieldNumber = 1,
  };
  // repeated .perception.hz.Roadmarking.Roadmarks.Roadmark roadmarks = 1;
  int roadmarks_size() const;
  private:
  int _internal_roadmarks_size() const;
  public:
  void clear_roadmarks();
  ::perception::hz::Roadmarking_Roadmarks_Roadmark* mutable_roadmarks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Roadmarks_Roadmark >*
      mutable_roadmarks();
  private:
  const ::perception::hz::Roadmarking_Roadmarks_Roadmark& _internal_roadmarks(int index) const;
  ::perception::hz::Roadmarking_Roadmarks_Roadmark* _internal_add_roadmarks();
  public:
  const ::perception::hz::Roadmarking_Roadmarks_Roadmark& roadmarks(int index) const;
  ::perception::hz::Roadmarking_Roadmarks_Roadmark* add_roadmarks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Roadmarks_Roadmark >&
      roadmarks() const;

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.Roadmarks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Roadmarks_Roadmark > roadmarks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_LDWInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.LDWInfo) */ {
 public:
  inline Roadmarking_LDWInfo() : Roadmarking_LDWInfo(nullptr) {};
  virtual ~Roadmarking_LDWInfo();

  Roadmarking_LDWInfo(const Roadmarking_LDWInfo& from);
  Roadmarking_LDWInfo(Roadmarking_LDWInfo&& from) noexcept
    : Roadmarking_LDWInfo() {
    *this = ::std::move(from);
  }

  inline Roadmarking_LDWInfo& operator=(const Roadmarking_LDWInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_LDWInfo& operator=(Roadmarking_LDWInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_LDWInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_LDWInfo* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_LDWInfo*>(
               &_Roadmarking_LDWInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Roadmarking_LDWInfo& a, Roadmarking_LDWInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_LDWInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_LDWInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_LDWInfo* New() const final {
    return CreateMaybeMessage<Roadmarking_LDWInfo>(nullptr);
  }

  Roadmarking_LDWInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_LDWInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_LDWInfo& from);
  void MergeFrom(const Roadmarking_LDWInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_LDWInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.LDWInfo";
  }
  protected:
  explicit Roadmarking_LDWInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Roadmarking_LDWInfo_LdwState LdwState;
  static constexpr LdwState kLdwNone =
    Roadmarking_LDWInfo_LdwState_kLdwNone;
  static constexpr LdwState kLdwLeft =
    Roadmarking_LDWInfo_LdwState_kLdwLeft;
  static constexpr LdwState kLdwRight =
    Roadmarking_LDWInfo_LdwState_kLdwRight;
  static inline bool LdwState_IsValid(int value) {
    return Roadmarking_LDWInfo_LdwState_IsValid(value);
  }
  static constexpr LdwState LdwState_MIN =
    Roadmarking_LDWInfo_LdwState_LdwState_MIN;
  static constexpr LdwState LdwState_MAX =
    Roadmarking_LDWInfo_LdwState_LdwState_MAX;
  static constexpr int LdwState_ARRAYSIZE =
    Roadmarking_LDWInfo_LdwState_LdwState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LdwState_descriptor() {
    return Roadmarking_LDWInfo_LdwState_descriptor();
  }
  template<typename T>
  static inline const std::string& LdwState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LdwState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LdwState_Name.");
    return Roadmarking_LDWInfo_LdwState_Name(enum_t_value);
  }
  static inline bool LdwState_Parse(const std::string& name,
      LdwState* value) {
    return Roadmarking_LDWInfo_LdwState_Parse(name, value);
  }

  typedef Roadmarking_LDWInfo_LdwWorkState LdwWorkState;
  static constexpr LdwWorkState kUnavailable =
    Roadmarking_LDWInfo_LdwWorkState_kUnavailable;
  static constexpr LdwWorkState kOff =
    Roadmarking_LDWInfo_LdwWorkState_kOff;
  static constexpr LdwWorkState kStandby =
    Roadmarking_LDWInfo_LdwWorkState_kStandby;
  static constexpr LdwWorkState kActive =
    Roadmarking_LDWInfo_LdwWorkState_kActive;
  static constexpr LdwWorkState kNotAvailable =
    Roadmarking_LDWInfo_LdwWorkState_kNotAvailable;
  static constexpr LdwWorkState kUnknown =
    Roadmarking_LDWInfo_LdwWorkState_kUnknown;
  static inline bool LdwWorkState_IsValid(int value) {
    return Roadmarking_LDWInfo_LdwWorkState_IsValid(value);
  }
  static constexpr LdwWorkState LdwWorkState_MIN =
    Roadmarking_LDWInfo_LdwWorkState_LdwWorkState_MIN;
  static constexpr LdwWorkState LdwWorkState_MAX =
    Roadmarking_LDWInfo_LdwWorkState_LdwWorkState_MAX;
  static constexpr int LdwWorkState_ARRAYSIZE =
    Roadmarking_LDWInfo_LdwWorkState_LdwWorkState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LdwWorkState_descriptor() {
    return Roadmarking_LDWInfo_LdwWorkState_descriptor();
  }
  template<typename T>
  static inline const std::string& LdwWorkState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LdwWorkState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LdwWorkState_Name.");
    return Roadmarking_LDWInfo_LdwWorkState_Name(enum_t_value);
  }
  static inline bool LdwWorkState_Parse(const std::string& name,
      LdwWorkState* value) {
    return Roadmarking_LDWInfo_LdwWorkState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLdwStateFieldNumber = 1,
    kLeftWheelDistFieldNumber = 2,
    kRightWheelDistFieldNumber = 3,
    kWarningDistFieldNumber = 4,
    kEarliestDistFieldNumber = 5,
    kLatestDistFieldNumber = 6,
    kLdwStateChangedFieldNumber = 7,
    kLdwWorkStateFieldNumber = 8,
    kNearestLineIdFieldNumber = 10,
    kTurnRadiusFieldNumber = 9,
    kLdwLevelFieldNumber = 11,
  };
  // .perception.hz.Roadmarking.LDWInfo.LdwState ldw_state = 1;
  void clear_ldw_state();
  ::perception::hz::Roadmarking_LDWInfo_LdwState ldw_state() const;
  void set_ldw_state(::perception::hz::Roadmarking_LDWInfo_LdwState value);
  private:
  ::perception::hz::Roadmarking_LDWInfo_LdwState _internal_ldw_state() const;
  void _internal_set_ldw_state(::perception::hz::Roadmarking_LDWInfo_LdwState value);
  public:

  // float left_wheel_dist = 2;
  void clear_left_wheel_dist();
  float left_wheel_dist() const;
  void set_left_wheel_dist(float value);
  private:
  float _internal_left_wheel_dist() const;
  void _internal_set_left_wheel_dist(float value);
  public:

  // float right_wheel_dist = 3;
  void clear_right_wheel_dist();
  float right_wheel_dist() const;
  void set_right_wheel_dist(float value);
  private:
  float _internal_right_wheel_dist() const;
  void _internal_set_right_wheel_dist(float value);
  public:

  // float warning_dist = 4;
  void clear_warning_dist();
  float warning_dist() const;
  void set_warning_dist(float value);
  private:
  float _internal_warning_dist() const;
  void _internal_set_warning_dist(float value);
  public:

  // float earliest_dist = 5;
  void clear_earliest_dist();
  float earliest_dist() const;
  void set_earliest_dist(float value);
  private:
  float _internal_earliest_dist() const;
  void _internal_set_earliest_dist(float value);
  public:

  // float latest_dist = 6;
  void clear_latest_dist();
  float latest_dist() const;
  void set_latest_dist(float value);
  private:
  float _internal_latest_dist() const;
  void _internal_set_latest_dist(float value);
  public:

  // bool ldw_state_changed = 7;
  void clear_ldw_state_changed();
  bool ldw_state_changed() const;
  void set_ldw_state_changed(bool value);
  private:
  bool _internal_ldw_state_changed() const;
  void _internal_set_ldw_state_changed(bool value);
  public:

  // .perception.hz.Roadmarking.LDWInfo.LdwWorkState ldw_work_state = 8;
  void clear_ldw_work_state();
  ::perception::hz::Roadmarking_LDWInfo_LdwWorkState ldw_work_state() const;
  void set_ldw_work_state(::perception::hz::Roadmarking_LDWInfo_LdwWorkState value);
  private:
  ::perception::hz::Roadmarking_LDWInfo_LdwWorkState _internal_ldw_work_state() const;
  void _internal_set_ldw_work_state(::perception::hz::Roadmarking_LDWInfo_LdwWorkState value);
  public:

  // uint64 nearest_line_id = 10;
  void clear_nearest_line_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 nearest_line_id() const;
  void set_nearest_line_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nearest_line_id() const;
  void _internal_set_nearest_line_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // float turn_radius = 9;
  void clear_turn_radius();
  float turn_radius() const;
  void set_turn_radius(float value);
  private:
  float _internal_turn_radius() const;
  void _internal_set_turn_radius(float value);
  public:

  // uint32 ldw_level = 11;
  void clear_ldw_level();
  ::PROTOBUF_NAMESPACE_ID::uint32 ldw_level() const;
  void set_ldw_level(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ldw_level() const;
  void _internal_set_ldw_level(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.LDWInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int ldw_state_;
  float left_wheel_dist_;
  float right_wheel_dist_;
  float warning_dist_;
  float earliest_dist_;
  float latest_dist_;
  bool ldw_state_changed_;
  int ldw_work_state_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nearest_line_id_;
  float turn_radius_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ldw_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_MotionEst PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.MotionEst) */ {
 public:
  inline Roadmarking_MotionEst() : Roadmarking_MotionEst(nullptr) {};
  virtual ~Roadmarking_MotionEst();

  Roadmarking_MotionEst(const Roadmarking_MotionEst& from);
  Roadmarking_MotionEst(Roadmarking_MotionEst&& from) noexcept
    : Roadmarking_MotionEst() {
    *this = ::std::move(from);
  }

  inline Roadmarking_MotionEst& operator=(const Roadmarking_MotionEst& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_MotionEst& operator=(Roadmarking_MotionEst&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_MotionEst& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_MotionEst* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_MotionEst*>(
               &_Roadmarking_MotionEst_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Roadmarking_MotionEst& a, Roadmarking_MotionEst& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_MotionEst* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_MotionEst* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_MotionEst* New() const final {
    return CreateMaybeMessage<Roadmarking_MotionEst>(nullptr);
  }

  Roadmarking_MotionEst* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_MotionEst>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_MotionEst& from);
  void MergeFrom(const Roadmarking_MotionEst& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_MotionEst* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.MotionEst";
  }
  protected:
  explicit Roadmarking_MotionEst(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLateralSpeedFieldNumber = 1,
    kLateralAccFieldNumber = 2,
    kConfidenceFieldNumber = 3,
  };
  // float lateral_speed = 1;
  void clear_lateral_speed();
  float lateral_speed() const;
  void set_lateral_speed(float value);
  private:
  float _internal_lateral_speed() const;
  void _internal_set_lateral_speed(float value);
  public:

  // float lateral_acc = 2;
  void clear_lateral_acc();
  float lateral_acc() const;
  void set_lateral_acc(float value);
  private:
  float _internal_lateral_acc() const;
  void _internal_set_lateral_acc(float value);
  public:

  // float confidence = 3;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.MotionEst)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float lateral_speed_;
  float lateral_acc_;
  float confidence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_PoseEst PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.PoseEst) */ {
 public:
  inline Roadmarking_PoseEst() : Roadmarking_PoseEst(nullptr) {};
  virtual ~Roadmarking_PoseEst();

  Roadmarking_PoseEst(const Roadmarking_PoseEst& from);
  Roadmarking_PoseEst(Roadmarking_PoseEst&& from) noexcept
    : Roadmarking_PoseEst() {
    *this = ::std::move(from);
  }

  inline Roadmarking_PoseEst& operator=(const Roadmarking_PoseEst& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_PoseEst& operator=(Roadmarking_PoseEst&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_PoseEst& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_PoseEst* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_PoseEst*>(
               &_Roadmarking_PoseEst_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Roadmarking_PoseEst& a, Roadmarking_PoseEst& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_PoseEst* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_PoseEst* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_PoseEst* New() const final {
    return CreateMaybeMessage<Roadmarking_PoseEst>(nullptr);
  }

  Roadmarking_PoseEst* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_PoseEst>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_PoseEst& from);
  void MergeFrom(const Roadmarking_PoseEst& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_PoseEst* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.PoseEst";
  }
  protected:
  explicit Roadmarking_PoseEst(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVanishPtFieldNumber = 2,
    kVanishCovFieldNumber = 3,
    kPitchEstFieldNumber = 1,
    kIsValidFieldNumber = 4,
    kCameraIdFieldNumber = 5,
    kDpitchFieldNumber = 6,
    kConfidenceFieldNumber = 7,
  };
  // .perception.common.Point2f vanish_pt = 2;
  bool has_vanish_pt() const;
  private:
  bool _internal_has_vanish_pt() const;
  public:
  void clear_vanish_pt();
  const ::perception::common::Point2f& vanish_pt() const;
  ::perception::common::Point2f* release_vanish_pt();
  ::perception::common::Point2f* mutable_vanish_pt();
  void set_allocated_vanish_pt(::perception::common::Point2f* vanish_pt);
  private:
  const ::perception::common::Point2f& _internal_vanish_pt() const;
  ::perception::common::Point2f* _internal_mutable_vanish_pt();
  public:
  void unsafe_arena_set_allocated_vanish_pt(
      ::perception::common::Point2f* vanish_pt);
  ::perception::common::Point2f* unsafe_arena_release_vanish_pt();

  // .perception.common.Point2f vanish_cov = 3;
  bool has_vanish_cov() const;
  private:
  bool _internal_has_vanish_cov() const;
  public:
  void clear_vanish_cov();
  const ::perception::common::Point2f& vanish_cov() const;
  ::perception::common::Point2f* release_vanish_cov();
  ::perception::common::Point2f* mutable_vanish_cov();
  void set_allocated_vanish_cov(::perception::common::Point2f* vanish_cov);
  private:
  const ::perception::common::Point2f& _internal_vanish_cov() const;
  ::perception::common::Point2f* _internal_mutable_vanish_cov();
  public:
  void unsafe_arena_set_allocated_vanish_cov(
      ::perception::common::Point2f* vanish_cov);
  ::perception::common::Point2f* unsafe_arena_release_vanish_cov();

  // float pitch_est = 1;
  void clear_pitch_est();
  float pitch_est() const;
  void set_pitch_est(float value);
  private:
  float _internal_pitch_est() const;
  void _internal_set_pitch_est(float value);
  public:

  // bool is_valid = 4;
  void clear_is_valid();
  bool is_valid() const;
  void set_is_valid(bool value);
  private:
  bool _internal_is_valid() const;
  void _internal_set_is_valid(bool value);
  public:

  // uint32 camera_id = 5;
  void clear_camera_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 camera_id() const;
  void set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_camera_id() const;
  void _internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float dpitch = 6;
  void clear_dpitch();
  float dpitch() const;
  void set_dpitch(float value);
  private:
  float _internal_dpitch() const;
  void _internal_set_dpitch(float value);
  public:

  // float confidence = 7;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.PoseEst)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::perception::common::Point2f* vanish_pt_;
  ::perception::common::Point2f* vanish_cov_;
  float pitch_est_;
  bool is_valid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 camera_id_;
  float dpitch_;
  float confidence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_HppInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.HppInfo) */ {
 public:
  inline Roadmarking_HppInfo() : Roadmarking_HppInfo(nullptr) {};
  virtual ~Roadmarking_HppInfo();

  Roadmarking_HppInfo(const Roadmarking_HppInfo& from);
  Roadmarking_HppInfo(Roadmarking_HppInfo&& from) noexcept
    : Roadmarking_HppInfo() {
    *this = ::std::move(from);
  }

  inline Roadmarking_HppInfo& operator=(const Roadmarking_HppInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_HppInfo& operator=(Roadmarking_HppInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_HppInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_HppInfo* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_HppInfo*>(
               &_Roadmarking_HppInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Roadmarking_HppInfo& a, Roadmarking_HppInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_HppInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_HppInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_HppInfo* New() const final {
    return CreateMaybeMessage<Roadmarking_HppInfo>(nullptr);
  }

  Roadmarking_HppInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_HppInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_HppInfo& from);
  void MergeFrom(const Roadmarking_HppInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_HppInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.HppInfo";
  }
  protected:
  explicit Roadmarking_HppInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Roadmarking_HppInfo_PlanningSource PlanningSource;
  static constexpr PlanningSource kInvalid =
    Roadmarking_HppInfo_PlanningSource_kInvalid;
  static constexpr PlanningSource kDoubleLaneline =
    Roadmarking_HppInfo_PlanningSource_kDoubleLaneline;
  static constexpr PlanningSource kLeftLaneline =
    Roadmarking_HppInfo_PlanningSource_kLeftLaneline;
  static constexpr PlanningSource kRightLaneline =
    Roadmarking_HppInfo_PlanningSource_kRightLaneline;
  static constexpr PlanningSource kLeftRoadEdge =
    Roadmarking_HppInfo_PlanningSource_kLeftRoadEdge;
  static constexpr PlanningSource kRightRoadEdge =
    Roadmarking_HppInfo_PlanningSource_kRightRoadEdge;
  static constexpr PlanningSource kHeadingVehTrace =
    Roadmarking_HppInfo_PlanningSource_kHeadingVehTrace;
  static constexpr PlanningSource kFreespace =
    Roadmarking_HppInfo_PlanningSource_kFreespace;
  static constexpr PlanningSource kSelfVehTrace =
    Roadmarking_HppInfo_PlanningSource_kSelfVehTrace;
  static inline bool PlanningSource_IsValid(int value) {
    return Roadmarking_HppInfo_PlanningSource_IsValid(value);
  }
  static constexpr PlanningSource PlanningSource_MIN =
    Roadmarking_HppInfo_PlanningSource_PlanningSource_MIN;
  static constexpr PlanningSource PlanningSource_MAX =
    Roadmarking_HppInfo_PlanningSource_PlanningSource_MAX;
  static constexpr int PlanningSource_ARRAYSIZE =
    Roadmarking_HppInfo_PlanningSource_PlanningSource_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PlanningSource_descriptor() {
    return Roadmarking_HppInfo_PlanningSource_descriptor();
  }
  template<typename T>
  static inline const std::string& PlanningSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PlanningSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PlanningSource_Name.");
    return Roadmarking_HppInfo_PlanningSource_Name(enum_t_value);
  }
  static inline bool PlanningSource_Parse(const std::string& name,
      PlanningSource* value) {
    return Roadmarking_HppInfo_PlanningSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathPredictionCoeffFieldNumber = 1,
    kHppLineFieldNumber = 8,
    kVirtualEgoLaneLeftFieldNumber = 9,
    kVirtualEgoLaneRightFieldNumber = 10,
    kPreviewPtFieldNumber = 11,
    kPreviewPtPerspFieldNumber = 12,
    kIsLanelineValidFieldNumber = 3,
    kIsValidFieldNumber = 4,
    kPlanningSourceFieldNumber = 5,
    kConfidenceFieldNumber = 6,
    kEgoLaneWidthFieldNumber = 7,
    kEgoLaneRadiusFieldNumber = 13,
  };
  // .perception.hz.Roadmarking.CurveCoeff path_prediction_coeff = 1;
  bool has_path_prediction_coeff() const;
  private:
  bool _internal_has_path_prediction_coeff() const;
  public:
  void clear_path_prediction_coeff();
  const ::perception::hz::Roadmarking_CurveCoeff& path_prediction_coeff() const;
  ::perception::hz::Roadmarking_CurveCoeff* release_path_prediction_coeff();
  ::perception::hz::Roadmarking_CurveCoeff* mutable_path_prediction_coeff();
  void set_allocated_path_prediction_coeff(::perception::hz::Roadmarking_CurveCoeff* path_prediction_coeff);
  private:
  const ::perception::hz::Roadmarking_CurveCoeff& _internal_path_prediction_coeff() const;
  ::perception::hz::Roadmarking_CurveCoeff* _internal_mutable_path_prediction_coeff();
  public:
  void unsafe_arena_set_allocated_path_prediction_coeff(
      ::perception::hz::Roadmarking_CurveCoeff* path_prediction_coeff);
  ::perception::hz::Roadmarking_CurveCoeff* unsafe_arena_release_path_prediction_coeff();

  // .perception.hz.Roadmarking.Laneline hpp_line = 8;
  bool has_hpp_line() const;
  private:
  bool _internal_has_hpp_line() const;
  public:
  void clear_hpp_line();
  const ::perception::hz::Roadmarking_Laneline& hpp_line() const;
  ::perception::hz::Roadmarking_Laneline* release_hpp_line();
  ::perception::hz::Roadmarking_Laneline* mutable_hpp_line();
  void set_allocated_hpp_line(::perception::hz::Roadmarking_Laneline* hpp_line);
  private:
  const ::perception::hz::Roadmarking_Laneline& _internal_hpp_line() const;
  ::perception::hz::Roadmarking_Laneline* _internal_mutable_hpp_line();
  public:
  void unsafe_arena_set_allocated_hpp_line(
      ::perception::hz::Roadmarking_Laneline* hpp_line);
  ::perception::hz::Roadmarking_Laneline* unsafe_arena_release_hpp_line();

  // .perception.hz.Roadmarking.Laneline virtual_ego_lane_left = 9;
  bool has_virtual_ego_lane_left() const;
  private:
  bool _internal_has_virtual_ego_lane_left() const;
  public:
  void clear_virtual_ego_lane_left();
  const ::perception::hz::Roadmarking_Laneline& virtual_ego_lane_left() const;
  ::perception::hz::Roadmarking_Laneline* release_virtual_ego_lane_left();
  ::perception::hz::Roadmarking_Laneline* mutable_virtual_ego_lane_left();
  void set_allocated_virtual_ego_lane_left(::perception::hz::Roadmarking_Laneline* virtual_ego_lane_left);
  private:
  const ::perception::hz::Roadmarking_Laneline& _internal_virtual_ego_lane_left() const;
  ::perception::hz::Roadmarking_Laneline* _internal_mutable_virtual_ego_lane_left();
  public:
  void unsafe_arena_set_allocated_virtual_ego_lane_left(
      ::perception::hz::Roadmarking_Laneline* virtual_ego_lane_left);
  ::perception::hz::Roadmarking_Laneline* unsafe_arena_release_virtual_ego_lane_left();

  // .perception.hz.Roadmarking.Laneline virtual_ego_lane_right = 10;
  bool has_virtual_ego_lane_right() const;
  private:
  bool _internal_has_virtual_ego_lane_right() const;
  public:
  void clear_virtual_ego_lane_right();
  const ::perception::hz::Roadmarking_Laneline& virtual_ego_lane_right() const;
  ::perception::hz::Roadmarking_Laneline* release_virtual_ego_lane_right();
  ::perception::hz::Roadmarking_Laneline* mutable_virtual_ego_lane_right();
  void set_allocated_virtual_ego_lane_right(::perception::hz::Roadmarking_Laneline* virtual_ego_lane_right);
  private:
  const ::perception::hz::Roadmarking_Laneline& _internal_virtual_ego_lane_right() const;
  ::perception::hz::Roadmarking_Laneline* _internal_mutable_virtual_ego_lane_right();
  public:
  void unsafe_arena_set_allocated_virtual_ego_lane_right(
      ::perception::hz::Roadmarking_Laneline* virtual_ego_lane_right);
  ::perception::hz::Roadmarking_Laneline* unsafe_arena_release_virtual_ego_lane_right();

  // .perception.common.Point2f preview_pt = 11;
  bool has_preview_pt() const;
  private:
  bool _internal_has_preview_pt() const;
  public:
  void clear_preview_pt();
  const ::perception::common::Point2f& preview_pt() const;
  ::perception::common::Point2f* release_preview_pt();
  ::perception::common::Point2f* mutable_preview_pt();
  void set_allocated_preview_pt(::perception::common::Point2f* preview_pt);
  private:
  const ::perception::common::Point2f& _internal_preview_pt() const;
  ::perception::common::Point2f* _internal_mutable_preview_pt();
  public:
  void unsafe_arena_set_allocated_preview_pt(
      ::perception::common::Point2f* preview_pt);
  ::perception::common::Point2f* unsafe_arena_release_preview_pt();

  // .perception.common.Point2f preview_pt_persp = 12;
  bool has_preview_pt_persp() const;
  private:
  bool _internal_has_preview_pt_persp() const;
  public:
  void clear_preview_pt_persp();
  const ::perception::common::Point2f& preview_pt_persp() const;
  ::perception::common::Point2f* release_preview_pt_persp();
  ::perception::common::Point2f* mutable_preview_pt_persp();
  void set_allocated_preview_pt_persp(::perception::common::Point2f* preview_pt_persp);
  private:
  const ::perception::common::Point2f& _internal_preview_pt_persp() const;
  ::perception::common::Point2f* _internal_mutable_preview_pt_persp();
  public:
  void unsafe_arena_set_allocated_preview_pt_persp(
      ::perception::common::Point2f* preview_pt_persp);
  ::perception::common::Point2f* unsafe_arena_release_preview_pt_persp();

  // bool is_laneline_valid = 3;
  void clear_is_laneline_valid();
  bool is_laneline_valid() const;
  void set_is_laneline_valid(bool value);
  private:
  bool _internal_is_laneline_valid() const;
  void _internal_set_is_laneline_valid(bool value);
  public:

  // bool is_valid = 4;
  void clear_is_valid();
  bool is_valid() const;
  void set_is_valid(bool value);
  private:
  bool _internal_is_valid() const;
  void _internal_set_is_valid(bool value);
  public:

  // uint32 planning_source = 5;
  void clear_planning_source();
  ::PROTOBUF_NAMESPACE_ID::uint32 planning_source() const;
  void set_planning_source(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_planning_source() const;
  void _internal_set_planning_source(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float confidence = 6;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // float ego_lane_width = 7;
  void clear_ego_lane_width();
  float ego_lane_width() const;
  void set_ego_lane_width(float value);
  private:
  float _internal_ego_lane_width() const;
  void _internal_set_ego_lane_width(float value);
  public:

  // float ego_lane_radius = 13;
  void clear_ego_lane_radius();
  float ego_lane_radius() const;
  void set_ego_lane_radius(float value);
  private:
  float _internal_ego_lane_radius() const;
  void _internal_set_ego_lane_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.HppInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::perception::hz::Roadmarking_CurveCoeff* path_prediction_coeff_;
  ::perception::hz::Roadmarking_Laneline* hpp_line_;
  ::perception::hz::Roadmarking_Laneline* virtual_ego_lane_left_;
  ::perception::hz::Roadmarking_Laneline* virtual_ego_lane_right_;
  ::perception::common::Point2f* preview_pt_;
  ::perception::common::Point2f* preview_pt_persp_;
  bool is_laneline_valid_;
  bool is_valid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 planning_source_;
  float confidence_;
  float ego_lane_width_;
  float ego_lane_radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_Junction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.Junction) */ {
 public:
  inline Roadmarking_Junction() : Roadmarking_Junction(nullptr) {};
  virtual ~Roadmarking_Junction();

  Roadmarking_Junction(const Roadmarking_Junction& from);
  Roadmarking_Junction(Roadmarking_Junction&& from) noexcept
    : Roadmarking_Junction() {
    *this = ::std::move(from);
  }

  inline Roadmarking_Junction& operator=(const Roadmarking_Junction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_Junction& operator=(Roadmarking_Junction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_Junction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_Junction* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_Junction*>(
               &_Roadmarking_Junction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Roadmarking_Junction& a, Roadmarking_Junction& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_Junction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_Junction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_Junction* New() const final {
    return CreateMaybeMessage<Roadmarking_Junction>(nullptr);
  }

  Roadmarking_Junction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_Junction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_Junction& from);
  void MergeFrom(const Roadmarking_Junction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_Junction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.Junction";
  }
  protected:
  explicit Roadmarking_Junction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Roadmarking_Junction_Type Type;
  static constexpr Type kMergingPoints =
    Roadmarking_Junction_Type_kMergingPoints;
  static constexpr Type kDivergingPoints =
    Roadmarking_Junction_Type_kDivergingPoints;
  static inline bool Type_IsValid(int value) {
    return Roadmarking_Junction_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Roadmarking_Junction_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Roadmarking_Junction_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Roadmarking_Junction_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Roadmarking_Junction_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Roadmarking_Junction_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return Roadmarking_Junction_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLanelineIdFieldNumber = 4,
    kPtImageCoordFieldNumber = 2,
    kPtVehicleCoordFieldNumber = 3,
    kTypeFieldNumber = 1,
    kStateFieldNumber = 5,
    kConfidenceFieldNumber = 6,
  };
  // repeated uint64 laneline_id = 4;
  int laneline_id_size() const;
  private:
  int _internal_laneline_id_size() const;
  public:
  void clear_laneline_id();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_laneline_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_laneline_id() const;
  void _internal_add_laneline_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_laneline_id();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 laneline_id(int index) const;
  void set_laneline_id(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_laneline_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      laneline_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_laneline_id();

  // .perception.common.Point2f pt_image_coord = 2;
  bool has_pt_image_coord() const;
  private:
  bool _internal_has_pt_image_coord() const;
  public:
  void clear_pt_image_coord();
  const ::perception::common::Point2f& pt_image_coord() const;
  ::perception::common::Point2f* release_pt_image_coord();
  ::perception::common::Point2f* mutable_pt_image_coord();
  void set_allocated_pt_image_coord(::perception::common::Point2f* pt_image_coord);
  private:
  const ::perception::common::Point2f& _internal_pt_image_coord() const;
  ::perception::common::Point2f* _internal_mutable_pt_image_coord();
  public:
  void unsafe_arena_set_allocated_pt_image_coord(
      ::perception::common::Point2f* pt_image_coord);
  ::perception::common::Point2f* unsafe_arena_release_pt_image_coord();

  // .perception.common.Point2f pt_vehicle_coord = 3;
  bool has_pt_vehicle_coord() const;
  private:
  bool _internal_has_pt_vehicle_coord() const;
  public:
  void clear_pt_vehicle_coord();
  const ::perception::common::Point2f& pt_vehicle_coord() const;
  ::perception::common::Point2f* release_pt_vehicle_coord();
  ::perception::common::Point2f* mutable_pt_vehicle_coord();
  void set_allocated_pt_vehicle_coord(::perception::common::Point2f* pt_vehicle_coord);
  private:
  const ::perception::common::Point2f& _internal_pt_vehicle_coord() const;
  ::perception::common::Point2f* _internal_mutable_pt_vehicle_coord();
  public:
  void unsafe_arena_set_allocated_pt_vehicle_coord(
      ::perception::common::Point2f* pt_vehicle_coord);
  ::perception::common::Point2f* unsafe_arena_release_pt_vehicle_coord();

  // .perception.hz.Roadmarking.Junction.Type type = 1;
  void clear_type();
  ::perception::hz::Roadmarking_Junction_Type type() const;
  void set_type(::perception::hz::Roadmarking_Junction_Type value);
  private:
  ::perception::hz::Roadmarking_Junction_Type _internal_type() const;
  void _internal_set_type(::perception::hz::Roadmarking_Junction_Type value);
  public:

  // int32 state = 5;
  void clear_state();
  ::PROTOBUF_NAMESPACE_ID::int32 state() const;
  void set_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_state() const;
  void _internal_set_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float confidence = 6;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.Junction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > laneline_id_;
  mutable std::atomic<int> _laneline_id_cached_byte_size_;
  ::perception::common::Point2f* pt_image_coord_;
  ::perception::common::Point2f* pt_vehicle_coord_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 state_;
  float confidence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking_JunctionList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking.JunctionList) */ {
 public:
  inline Roadmarking_JunctionList() : Roadmarking_JunctionList(nullptr) {};
  virtual ~Roadmarking_JunctionList();

  Roadmarking_JunctionList(const Roadmarking_JunctionList& from);
  Roadmarking_JunctionList(Roadmarking_JunctionList&& from) noexcept
    : Roadmarking_JunctionList() {
    *this = ::std::move(from);
  }

  inline Roadmarking_JunctionList& operator=(const Roadmarking_JunctionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking_JunctionList& operator=(Roadmarking_JunctionList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking_JunctionList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking_JunctionList* internal_default_instance() {
    return reinterpret_cast<const Roadmarking_JunctionList*>(
               &_Roadmarking_JunctionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Roadmarking_JunctionList& a, Roadmarking_JunctionList& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking_JunctionList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking_JunctionList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking_JunctionList* New() const final {
    return CreateMaybeMessage<Roadmarking_JunctionList>(nullptr);
  }

  Roadmarking_JunctionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking_JunctionList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking_JunctionList& from);
  void MergeFrom(const Roadmarking_JunctionList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking_JunctionList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking.JunctionList";
  }
  protected:
  explicit Roadmarking_JunctionList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJuncFieldNumber = 1,
  };
  // repeated .perception.hz.Roadmarking.Junction junc = 1;
  int junc_size() const;
  private:
  int _internal_junc_size() const;
  public:
  void clear_junc();
  ::perception::hz::Roadmarking_Junction* mutable_junc(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Junction >*
      mutable_junc();
  private:
  const ::perception::hz::Roadmarking_Junction& _internal_junc(int index) const;
  ::perception::hz::Roadmarking_Junction* _internal_add_junc();
  public:
  const ::perception::hz::Roadmarking_Junction& junc(int index) const;
  ::perception::hz::Roadmarking_Junction* add_junc();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Junction >&
      junc() const;

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking.JunctionList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Junction > junc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// -------------------------------------------------------------------

class Roadmarking PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:perception.hz.Roadmarking) */ {
 public:
  inline Roadmarking() : Roadmarking(nullptr) {};
  virtual ~Roadmarking();

  Roadmarking(const Roadmarking& from);
  Roadmarking(Roadmarking&& from) noexcept
    : Roadmarking() {
    *this = ::std::move(from);
  }

  inline Roadmarking& operator=(const Roadmarking& from) {
    CopyFrom(from);
    return *this;
  }
  inline Roadmarking& operator=(Roadmarking&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Roadmarking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Roadmarking* internal_default_instance() {
    return reinterpret_cast<const Roadmarking*>(
               &_Roadmarking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Roadmarking& a, Roadmarking& b) {
    a.Swap(&b);
  }
  inline void Swap(Roadmarking* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Roadmarking* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Roadmarking* New() const final {
    return CreateMaybeMessage<Roadmarking>(nullptr);
  }

  Roadmarking* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Roadmarking>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Roadmarking& from);
  void MergeFrom(const Roadmarking& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Roadmarking* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perception.hz.Roadmarking";
  }
  protected:
  explicit Roadmarking(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_roadmarking_5fhz_2eproto);
    return ::descriptor_table_roadmarking_5fhz_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Roadmarking_CurveCoeff CurveCoeff;
  typedef Roadmarking_Laneline Laneline;
  typedef Roadmarking_LanelineList LanelineList;
  typedef Roadmarking_FreeSpaces FreeSpaces;
  typedef Roadmarking_RoadEdge RoadEdge;
  typedef Roadmarking_RoadEdgeList RoadEdgeList;
  typedef Roadmarking_Roadmarks Roadmarks;
  typedef Roadmarking_LDWInfo LDWInfo;
  typedef Roadmarking_MotionEst MotionEst;
  typedef Roadmarking_PoseEst PoseEst;
  typedef Roadmarking_HppInfo HppInfo;
  typedef Roadmarking_Junction Junction;
  typedef Roadmarking_JunctionList JunctionList;

  typedef Roadmarking_LanelinePositionType LanelinePositionType;
  static constexpr LanelinePositionType kAdjacentLeft =
    Roadmarking_LanelinePositionType_kAdjacentLeft;
  static constexpr LanelinePositionType kEgoLeft =
    Roadmarking_LanelinePositionType_kEgoLeft;
  static constexpr LanelinePositionType kEgoRight =
    Roadmarking_LanelinePositionType_kEgoRight;
  static constexpr LanelinePositionType kAdjacentRight =
    Roadmarking_LanelinePositionType_kAdjacentRight;
  static constexpr LanelinePositionType kThirdLeft =
    Roadmarking_LanelinePositionType_kThirdLeft;
  static constexpr LanelinePositionType kThirdRight =
    Roadmarking_LanelinePositionType_kThirdRight;
  static constexpr LanelinePositionType kFourthLeft =
    Roadmarking_LanelinePositionType_kFourthLeft;
  static constexpr LanelinePositionType kFourthRight =
    Roadmarking_LanelinePositionType_kFourthRight;
  static constexpr LanelinePositionType kOther =
    Roadmarking_LanelinePositionType_kOther;
  static inline bool LanelinePositionType_IsValid(int value) {
    return Roadmarking_LanelinePositionType_IsValid(value);
  }
  static constexpr LanelinePositionType LanelinePositionType_MIN =
    Roadmarking_LanelinePositionType_LanelinePositionType_MIN;
  static constexpr LanelinePositionType LanelinePositionType_MAX =
    Roadmarking_LanelinePositionType_LanelinePositionType_MAX;
  static constexpr int LanelinePositionType_ARRAYSIZE =
    Roadmarking_LanelinePositionType_LanelinePositionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LanelinePositionType_descriptor() {
    return Roadmarking_LanelinePositionType_descriptor();
  }
  template<typename T>
  static inline const std::string& LanelinePositionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LanelinePositionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LanelinePositionType_Name.");
    return Roadmarking_LanelinePositionType_Name(enum_t_value);
  }
  static inline bool LanelinePositionType_Parse(const std::string& name,
      LanelinePositionType* value) {
    return Roadmarking_LanelinePositionType_Parse(name, value);
  }

  typedef Roadmarking_LineType LineType;
  static constexpr LineType kLineSingleSolid =
    Roadmarking_LineType_kLineSingleSolid;
  static constexpr LineType kLineSingleDashed =
    Roadmarking_LineType_kLineSingleDashed;
  static constexpr LineType kLineBold =
    Roadmarking_LineType_kLineBold;
  static constexpr LineType kLineDoubleSolid =
    Roadmarking_LineType_kLineDoubleSolid;
  static constexpr LineType kLineDoubleDashed =
    Roadmarking_LineType_kLineDoubleDashed;
  static constexpr LineType kLineSolidDashed =
    Roadmarking_LineType_kLineSolidDashed;
  static constexpr LineType kLineDashedSolid =
    Roadmarking_LineType_kLineDashedSolid;
  static constexpr LineType kFence =
    Roadmarking_LineType_kFence;
  static constexpr LineType kCurb =
    Roadmarking_LineType_kCurb;
  static constexpr LineType kLineDeceleration =
    Roadmarking_LineType_kLineDeceleration;
  static constexpr LineType kLineUnknown =
    Roadmarking_LineType_kLineUnknown;
  static inline bool LineType_IsValid(int value) {
    return Roadmarking_LineType_IsValid(value);
  }
  static constexpr LineType LineType_MIN =
    Roadmarking_LineType_LineType_MIN;
  static constexpr LineType LineType_MAX =
    Roadmarking_LineType_LineType_MAX;
  static constexpr int LineType_ARRAYSIZE =
    Roadmarking_LineType_LineType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LineType_descriptor() {
    return Roadmarking_LineType_descriptor();
  }
  template<typename T>
  static inline const std::string& LineType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LineType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LineType_Name.");
    return Roadmarking_LineType_Name(enum_t_value);
  }
  static inline bool LineType_Parse(const std::string& name,
      LineType* value) {
    return Roadmarking_LineType_Parse(name, value);
  }

  typedef Roadmarking_ColorType ColorType;
  static constexpr ColorType kColorWhite =
    Roadmarking_ColorType_kColorWhite;
  static constexpr ColorType kColorYellow =
    Roadmarking_ColorType_kColorYellow;
  static constexpr ColorType kColorOrange =
    Roadmarking_ColorType_kColorOrange;
  static constexpr ColorType kColorBlue =
    Roadmarking_ColorType_kColorBlue;
  static constexpr ColorType kColorGreen =
    Roadmarking_ColorType_kColorGreen;
  static constexpr ColorType kColorGray =
    Roadmarking_ColorType_kColorGray;
  static constexpr ColorType kColorWhiteYellow =
    Roadmarking_ColorType_kColorWhiteYellow;
  static constexpr ColorType kColorYellowWhite =
    Roadmarking_ColorType_kColorYellowWhite;
  static constexpr ColorType kColorYellowGrayFusion =
    Roadmarking_ColorType_kColorYellowGrayFusion;
  static constexpr ColorType kColorUnknown =
    Roadmarking_ColorType_kColorUnknown;
  static inline bool ColorType_IsValid(int value) {
    return Roadmarking_ColorType_IsValid(value);
  }
  static constexpr ColorType ColorType_MIN =
    Roadmarking_ColorType_ColorType_MIN;
  static constexpr ColorType ColorType_MAX =
    Roadmarking_ColorType_ColorType_MAX;
  static constexpr int ColorType_ARRAYSIZE =
    Roadmarking_ColorType_ColorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ColorType_descriptor() {
    return Roadmarking_ColorType_descriptor();
  }
  template<typename T>
  static inline const std::string& ColorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ColorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ColorType_Name.");
    return Roadmarking_ColorType_Name(enum_t_value);
  }
  static inline bool ColorType_Parse(const std::string& name,
      ColorType* value) {
    return Roadmarking_ColorType_Parse(name, value);
  }

  typedef Roadmarking_LineState LineState;
  static constexpr LineState kDetected =
    Roadmarking_LineState_kDetected;
  static constexpr LineState kPredicted =
    Roadmarking_LineState_kPredicted;
  static constexpr LineState kStableTrack =
    Roadmarking_LineState_kStableTrack;
  static inline bool LineState_IsValid(int value) {
    return Roadmarking_LineState_IsValid(value);
  }
  static constexpr LineState LineState_MIN =
    Roadmarking_LineState_LineState_MIN;
  static constexpr LineState LineState_MAX =
    Roadmarking_LineState_LineState_MAX;
  static constexpr int LineState_ARRAYSIZE =
    Roadmarking_LineState_LineState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LineState_descriptor() {
    return Roadmarking_LineState_descriptor();
  }
  template<typename T>
  static inline const std::string& LineState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LineState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LineState_Name.");
    return Roadmarking_LineState_Name(enum_t_value);
  }
  static inline bool LineState_Parse(const std::string& name,
      LineState* value) {
    return Roadmarking_LineState_Parse(name, value);
  }

  typedef Roadmarking_LaneIdx LaneIdx;
  static constexpr LaneIdx kLaneIdxUnknown =
    Roadmarking_LaneIdx_kLaneIdxUnknown;
  static constexpr LaneIdx kEgoLane =
    Roadmarking_LaneIdx_kEgoLane;
  static constexpr LaneIdx kAdjacentLeftLane =
    Roadmarking_LaneIdx_kAdjacentLeftLane;
  static constexpr LaneIdx kAdjacentRightLane =
    Roadmarking_LaneIdx_kAdjacentRightLane;
  static constexpr LaneIdx kSecondaryLeftLane =
    Roadmarking_LaneIdx_kSecondaryLeftLane;
  static constexpr LaneIdx kSecondaryRightLane =
    Roadmarking_LaneIdx_kSecondaryRightLane;
  static constexpr LaneIdx kThirdLeftLane =
    Roadmarking_LaneIdx_kThirdLeftLane;
  static constexpr LaneIdx kThirdRightLane =
    Roadmarking_LaneIdx_kThirdRightLane;
  static inline bool LaneIdx_IsValid(int value) {
    return Roadmarking_LaneIdx_IsValid(value);
  }
  static constexpr LaneIdx LaneIdx_MIN =
    Roadmarking_LaneIdx_LaneIdx_MIN;
  static constexpr LaneIdx LaneIdx_MAX =
    Roadmarking_LaneIdx_LaneIdx_MAX;
  static constexpr int LaneIdx_ARRAYSIZE =
    Roadmarking_LaneIdx_LaneIdx_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LaneIdx_descriptor() {
    return Roadmarking_LaneIdx_descriptor();
  }
  template<typename T>
  static inline const std::string& LaneIdx_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LaneIdx>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LaneIdx_Name.");
    return Roadmarking_LaneIdx_Name(enum_t_value);
  }
  static inline bool LaneIdx_Parse(const std::string& name,
      LaneIdx* value) {
    return Roadmarking_LaneIdx_Parse(name, value);
  }

  typedef Roadmarking_SpaceType SpaceType;
  static constexpr SpaceType kBackground =
    Roadmarking_SpaceType_kBackground;
  static constexpr SpaceType kFreeSpace =
    Roadmarking_SpaceType_kFreeSpace;
  static constexpr SpaceType kRoadBoundary =
    Roadmarking_SpaceType_kRoadBoundary;
  static constexpr SpaceType kVehicle =
    Roadmarking_SpaceType_kVehicle;
  static constexpr SpaceType kRoadSign =
    Roadmarking_SpaceType_kRoadSign;
  static constexpr SpaceType kPole =
    Roadmarking_SpaceType_kPole;
  static constexpr SpaceType kGuardrail =
    Roadmarking_SpaceType_kGuardrail;
  static constexpr SpaceType kSpaceTypeNums =
    Roadmarking_SpaceType_kSpaceTypeNums;
  static inline bool SpaceType_IsValid(int value) {
    return Roadmarking_SpaceType_IsValid(value);
  }
  static constexpr SpaceType SpaceType_MIN =
    Roadmarking_SpaceType_SpaceType_MIN;
  static constexpr SpaceType SpaceType_MAX =
    Roadmarking_SpaceType_SpaceType_MAX;
  static constexpr int SpaceType_ARRAYSIZE =
    Roadmarking_SpaceType_SpaceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SpaceType_descriptor() {
    return Roadmarking_SpaceType_descriptor();
  }
  template<typename T>
  static inline const std::string& SpaceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SpaceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SpaceType_Name.");
    return Roadmarking_SpaceType_Name(enum_t_value);
  }
  static inline bool SpaceType_Parse(const std::string& name,
      SpaceType* value) {
    return Roadmarking_SpaceType_Parse(name, value);
  }

  typedef Roadmarking_DirectPosition DirectPosition;
  static constexpr DirectPosition kDirectSame =
    Roadmarking_DirectPosition_kDirectSame;
  static constexpr DirectPosition kDirectOpposite =
    Roadmarking_DirectPosition_kDirectOpposite;
  static inline bool DirectPosition_IsValid(int value) {
    return Roadmarking_DirectPosition_IsValid(value);
  }
  static constexpr DirectPosition DirectPosition_MIN =
    Roadmarking_DirectPosition_DirectPosition_MIN;
  static constexpr DirectPosition DirectPosition_MAX =
    Roadmarking_DirectPosition_DirectPosition_MAX;
  static constexpr int DirectPosition_ARRAYSIZE =
    Roadmarking_DirectPosition_DirectPosition_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DirectPosition_descriptor() {
    return Roadmarking_DirectPosition_descriptor();
  }
  template<typename T>
  static inline const std::string& DirectPosition_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DirectPosition>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DirectPosition_Name.");
    return Roadmarking_DirectPosition_Name(enum_t_value);
  }
  static inline bool DirectPosition_Parse(const std::string& name,
      DirectPosition* value) {
    return Roadmarking_DirectPosition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLanelineFieldNumber = 3,
    kFreespacesFieldNumber = 4,
    kRoadmarkersFieldNumber = 6,
    kRoadEdgesFieldNumber = 7,
    kLdwInfoFieldNumber = 8,
    kCalibLinesFieldNumber = 9,
    kMotionFieldNumber = 10,
    kPoseFieldNumber = 11,
    kHppInfoFieldNumber = 12,
    kSlopeEquationFieldNumber = 15,
    kJuncListFieldNumber = 17,
    kProfilingItemsFieldNumber = 18,
    kEgoMotionFieldNumber = 21,
    kCamIdFieldNumber = 23,
    kFrameIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kTickFieldNumber = 13,
    kFinishTimeFieldNumber = 16,
    kDataSourceFieldNumber = 14,
    kFpsFieldNumber = 20,
    kRecvTimeFieldNumber = 19,
    kEgoLaneWidthFieldNumber = 22,
  };
  // .perception.hz.Roadmarking.LanelineList laneline = 3;
  bool has_laneline() const;
  private:
  bool _internal_has_laneline() const;
  public:
  void clear_laneline();
  const ::perception::hz::Roadmarking_LanelineList& laneline() const;
  ::perception::hz::Roadmarking_LanelineList* release_laneline();
  ::perception::hz::Roadmarking_LanelineList* mutable_laneline();
  void set_allocated_laneline(::perception::hz::Roadmarking_LanelineList* laneline);
  private:
  const ::perception::hz::Roadmarking_LanelineList& _internal_laneline() const;
  ::perception::hz::Roadmarking_LanelineList* _internal_mutable_laneline();
  public:
  void unsafe_arena_set_allocated_laneline(
      ::perception::hz::Roadmarking_LanelineList* laneline);
  ::perception::hz::Roadmarking_LanelineList* unsafe_arena_release_laneline();

  // .perception.hz.Roadmarking.FreeSpaces freespaces = 4;
  bool has_freespaces() const;
  private:
  bool _internal_has_freespaces() const;
  public:
  void clear_freespaces();
  const ::perception::hz::Roadmarking_FreeSpaces& freespaces() const;
  ::perception::hz::Roadmarking_FreeSpaces* release_freespaces();
  ::perception::hz::Roadmarking_FreeSpaces* mutable_freespaces();
  void set_allocated_freespaces(::perception::hz::Roadmarking_FreeSpaces* freespaces);
  private:
  const ::perception::hz::Roadmarking_FreeSpaces& _internal_freespaces() const;
  ::perception::hz::Roadmarking_FreeSpaces* _internal_mutable_freespaces();
  public:
  void unsafe_arena_set_allocated_freespaces(
      ::perception::hz::Roadmarking_FreeSpaces* freespaces);
  ::perception::hz::Roadmarking_FreeSpaces* unsafe_arena_release_freespaces();

  // .perception.hz.Roadmarking.Roadmarks roadmarkers = 6;
  bool has_roadmarkers() const;
  private:
  bool _internal_has_roadmarkers() const;
  public:
  void clear_roadmarkers();
  const ::perception::hz::Roadmarking_Roadmarks& roadmarkers() const;
  ::perception::hz::Roadmarking_Roadmarks* release_roadmarkers();
  ::perception::hz::Roadmarking_Roadmarks* mutable_roadmarkers();
  void set_allocated_roadmarkers(::perception::hz::Roadmarking_Roadmarks* roadmarkers);
  private:
  const ::perception::hz::Roadmarking_Roadmarks& _internal_roadmarkers() const;
  ::perception::hz::Roadmarking_Roadmarks* _internal_mutable_roadmarkers();
  public:
  void unsafe_arena_set_allocated_roadmarkers(
      ::perception::hz::Roadmarking_Roadmarks* roadmarkers);
  ::perception::hz::Roadmarking_Roadmarks* unsafe_arena_release_roadmarkers();

  // .perception.hz.Roadmarking.RoadEdgeList road_edges = 7;
  bool has_road_edges() const;
  private:
  bool _internal_has_road_edges() const;
  public:
  void clear_road_edges();
  const ::perception::hz::Roadmarking_RoadEdgeList& road_edges() const;
  ::perception::hz::Roadmarking_RoadEdgeList* release_road_edges();
  ::perception::hz::Roadmarking_RoadEdgeList* mutable_road_edges();
  void set_allocated_road_edges(::perception::hz::Roadmarking_RoadEdgeList* road_edges);
  private:
  const ::perception::hz::Roadmarking_RoadEdgeList& _internal_road_edges() const;
  ::perception::hz::Roadmarking_RoadEdgeList* _internal_mutable_road_edges();
  public:
  void unsafe_arena_set_allocated_road_edges(
      ::perception::hz::Roadmarking_RoadEdgeList* road_edges);
  ::perception::hz::Roadmarking_RoadEdgeList* unsafe_arena_release_road_edges();

  // .perception.hz.Roadmarking.LDWInfo ldw_info = 8;
  bool has_ldw_info() const;
  private:
  bool _internal_has_ldw_info() const;
  public:
  void clear_ldw_info();
  const ::perception::hz::Roadmarking_LDWInfo& ldw_info() const;
  ::perception::hz::Roadmarking_LDWInfo* release_ldw_info();
  ::perception::hz::Roadmarking_LDWInfo* mutable_ldw_info();
  void set_allocated_ldw_info(::perception::hz::Roadmarking_LDWInfo* ldw_info);
  private:
  const ::perception::hz::Roadmarking_LDWInfo& _internal_ldw_info() const;
  ::perception::hz::Roadmarking_LDWInfo* _internal_mutable_ldw_info();
  public:
  void unsafe_arena_set_allocated_ldw_info(
      ::perception::hz::Roadmarking_LDWInfo* ldw_info);
  ::perception::hz::Roadmarking_LDWInfo* unsafe_arena_release_ldw_info();

  // .perception.hz.Roadmarking.LanelineList calib_lines = 9;
  bool has_calib_lines() const;
  private:
  bool _internal_has_calib_lines() const;
  public:
  void clear_calib_lines();
  const ::perception::hz::Roadmarking_LanelineList& calib_lines() const;
  ::perception::hz::Roadmarking_LanelineList* release_calib_lines();
  ::perception::hz::Roadmarking_LanelineList* mutable_calib_lines();
  void set_allocated_calib_lines(::perception::hz::Roadmarking_LanelineList* calib_lines);
  private:
  const ::perception::hz::Roadmarking_LanelineList& _internal_calib_lines() const;
  ::perception::hz::Roadmarking_LanelineList* _internal_mutable_calib_lines();
  public:
  void unsafe_arena_set_allocated_calib_lines(
      ::perception::hz::Roadmarking_LanelineList* calib_lines);
  ::perception::hz::Roadmarking_LanelineList* unsafe_arena_release_calib_lines();

  // .perception.hz.Roadmarking.MotionEst motion = 10;
  bool has_motion() const;
  private:
  bool _internal_has_motion() const;
  public:
  void clear_motion();
  const ::perception::hz::Roadmarking_MotionEst& motion() const;
  ::perception::hz::Roadmarking_MotionEst* release_motion();
  ::perception::hz::Roadmarking_MotionEst* mutable_motion();
  void set_allocated_motion(::perception::hz::Roadmarking_MotionEst* motion);
  private:
  const ::perception::hz::Roadmarking_MotionEst& _internal_motion() const;
  ::perception::hz::Roadmarking_MotionEst* _internal_mutable_motion();
  public:
  void unsafe_arena_set_allocated_motion(
      ::perception::hz::Roadmarking_MotionEst* motion);
  ::perception::hz::Roadmarking_MotionEst* unsafe_arena_release_motion();

  // .perception.hz.Roadmarking.PoseEst pose = 11;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::perception::hz::Roadmarking_PoseEst& pose() const;
  ::perception::hz::Roadmarking_PoseEst* release_pose();
  ::perception::hz::Roadmarking_PoseEst* mutable_pose();
  void set_allocated_pose(::perception::hz::Roadmarking_PoseEst* pose);
  private:
  const ::perception::hz::Roadmarking_PoseEst& _internal_pose() const;
  ::perception::hz::Roadmarking_PoseEst* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::perception::hz::Roadmarking_PoseEst* pose);
  ::perception::hz::Roadmarking_PoseEst* unsafe_arena_release_pose();

  // .perception.hz.Roadmarking.HppInfo hpp_info = 12;
  bool has_hpp_info() const;
  private:
  bool _internal_has_hpp_info() const;
  public:
  void clear_hpp_info();
  const ::perception::hz::Roadmarking_HppInfo& hpp_info() const;
  ::perception::hz::Roadmarking_HppInfo* release_hpp_info();
  ::perception::hz::Roadmarking_HppInfo* mutable_hpp_info();
  void set_allocated_hpp_info(::perception::hz::Roadmarking_HppInfo* hpp_info);
  private:
  const ::perception::hz::Roadmarking_HppInfo& _internal_hpp_info() const;
  ::perception::hz::Roadmarking_HppInfo* _internal_mutable_hpp_info();
  public:
  void unsafe_arena_set_allocated_hpp_info(
      ::perception::hz::Roadmarking_HppInfo* hpp_info);
  ::perception::hz::Roadmarking_HppInfo* unsafe_arena_release_hpp_info();

  // .perception.hz.Roadmarking.CurveCoeff slope_equation = 15;
  bool has_slope_equation() const;
  private:
  bool _internal_has_slope_equation() const;
  public:
  void clear_slope_equation();
  const ::perception::hz::Roadmarking_CurveCoeff& slope_equation() const;
  ::perception::hz::Roadmarking_CurveCoeff* release_slope_equation();
  ::perception::hz::Roadmarking_CurveCoeff* mutable_slope_equation();
  void set_allocated_slope_equation(::perception::hz::Roadmarking_CurveCoeff* slope_equation);
  private:
  const ::perception::hz::Roadmarking_CurveCoeff& _internal_slope_equation() const;
  ::perception::hz::Roadmarking_CurveCoeff* _internal_mutable_slope_equation();
  public:
  void unsafe_arena_set_allocated_slope_equation(
      ::perception::hz::Roadmarking_CurveCoeff* slope_equation);
  ::perception::hz::Roadmarking_CurveCoeff* unsafe_arena_release_slope_equation();

  // .perception.hz.Roadmarking.JunctionList junc_list = 17;
  bool has_junc_list() const;
  private:
  bool _internal_has_junc_list() const;
  public:
  void clear_junc_list();
  const ::perception::hz::Roadmarking_JunctionList& junc_list() const;
  ::perception::hz::Roadmarking_JunctionList* release_junc_list();
  ::perception::hz::Roadmarking_JunctionList* mutable_junc_list();
  void set_allocated_junc_list(::perception::hz::Roadmarking_JunctionList* junc_list);
  private:
  const ::perception::hz::Roadmarking_JunctionList& _internal_junc_list() const;
  ::perception::hz::Roadmarking_JunctionList* _internal_mutable_junc_list();
  public:
  void unsafe_arena_set_allocated_junc_list(
      ::perception::hz::Roadmarking_JunctionList* junc_list);
  ::perception::hz::Roadmarking_JunctionList* unsafe_arena_release_junc_list();

  // .perception.hz.RoadSysProfiling profiling_items = 18;
  bool has_profiling_items() const;
  private:
  bool _internal_has_profiling_items() const;
  public:
  void clear_profiling_items();
  const ::perception::hz::RoadSysProfiling& profiling_items() const;
  ::perception::hz::RoadSysProfiling* release_profiling_items();
  ::perception::hz::RoadSysProfiling* mutable_profiling_items();
  void set_allocated_profiling_items(::perception::hz::RoadSysProfiling* profiling_items);
  private:
  const ::perception::hz::RoadSysProfiling& _internal_profiling_items() const;
  ::perception::hz::RoadSysProfiling* _internal_mutable_profiling_items();
  public:
  void unsafe_arena_set_allocated_profiling_items(
      ::perception::hz::RoadSysProfiling* profiling_items);
  ::perception::hz::RoadSysProfiling* unsafe_arena_release_profiling_items();

  // .minieye.EgoMotion ego_motion = 21;
  bool has_ego_motion() const;
  private:
  bool _internal_has_ego_motion() const;
  public:
  void clear_ego_motion();
  const ::minieye::EgoMotion& ego_motion() const;
  ::minieye::EgoMotion* release_ego_motion();
  ::minieye::EgoMotion* mutable_ego_motion();
  void set_allocated_ego_motion(::minieye::EgoMotion* ego_motion);
  private:
  const ::minieye::EgoMotion& _internal_ego_motion() const;
  ::minieye::EgoMotion* _internal_mutable_ego_motion();
  public:
  void unsafe_arena_set_allocated_ego_motion(
      ::minieye::EgoMotion* ego_motion);
  ::minieye::EgoMotion* unsafe_arena_release_ego_motion();

  // .minieye.CamID cam_id = 23;
  bool has_cam_id() const;
  private:
  bool _internal_has_cam_id() const;
  public:
  void clear_cam_id();
  const ::minieye::CamID& cam_id() const;
  ::minieye::CamID* release_cam_id();
  ::minieye::CamID* mutable_cam_id();
  void set_allocated_cam_id(::minieye::CamID* cam_id);
  private:
  const ::minieye::CamID& _internal_cam_id() const;
  ::minieye::CamID* _internal_mutable_cam_id();
  public:
  void unsafe_arena_set_allocated_cam_id(
      ::minieye::CamID* cam_id);
  ::minieye::CamID* unsafe_arena_release_cam_id();

  // uint64 frame_id = 1;
  void clear_frame_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id() const;
  void set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_frame_id() const;
  void _internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 timestamp = 2;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 tick = 13;
  void clear_tick();
  ::PROTOBUF_NAMESPACE_ID::uint64 tick() const;
  void set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tick() const;
  void _internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 finish_time = 16;
  void clear_finish_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 finish_time() const;
  void set_finish_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_finish_time() const;
  void _internal_set_finish_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .minieye.DataSource data_source = 14;
  void clear_data_source();
  ::minieye::DataSource data_source() const;
  void set_data_source(::minieye::DataSource value);
  private:
  ::minieye::DataSource _internal_data_source() const;
  void _internal_set_data_source(::minieye::DataSource value);
  public:

  // float fps = 20;
  void clear_fps();
  float fps() const;
  void set_fps(float value);
  private:
  float _internal_fps() const;
  void _internal_set_fps(float value);
  public:

  // uint64 recv_time = 19;
  void clear_recv_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 recv_time() const;
  void set_recv_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_recv_time() const;
  void _internal_set_recv_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // float ego_lane_width = 22;
  void clear_ego_lane_width();
  float ego_lane_width() const;
  void set_ego_lane_width(float value);
  private:
  float _internal_ego_lane_width() const;
  void _internal_set_ego_lane_width(float value);
  public:

  // @@protoc_insertion_point(class_scope:perception.hz.Roadmarking)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::perception::hz::Roadmarking_LanelineList* laneline_;
  ::perception::hz::Roadmarking_FreeSpaces* freespaces_;
  ::perception::hz::Roadmarking_Roadmarks* roadmarkers_;
  ::perception::hz::Roadmarking_RoadEdgeList* road_edges_;
  ::perception::hz::Roadmarking_LDWInfo* ldw_info_;
  ::perception::hz::Roadmarking_LanelineList* calib_lines_;
  ::perception::hz::Roadmarking_MotionEst* motion_;
  ::perception::hz::Roadmarking_PoseEst* pose_;
  ::perception::hz::Roadmarking_HppInfo* hpp_info_;
  ::perception::hz::Roadmarking_CurveCoeff* slope_equation_;
  ::perception::hz::Roadmarking_JunctionList* junc_list_;
  ::perception::hz::RoadSysProfiling* profiling_items_;
  ::minieye::EgoMotion* ego_motion_;
  ::minieye::CamID* cam_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 frame_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tick_;
  ::PROTOBUF_NAMESPACE_ID::uint64 finish_time_;
  int data_source_;
  float fps_;
  ::PROTOBUF_NAMESPACE_ID::uint64 recv_time_;
  float ego_lane_width_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_roadmarking_5fhz_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoadSysProfiling_Item

// string name = 1;
inline void RoadSysProfiling_Item::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RoadSysProfiling_Item::name() const {
  // @@protoc_insertion_point(field_get:perception.hz.RoadSysProfiling.Item.name)
  return _internal_name();
}
inline void RoadSysProfiling_Item::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:perception.hz.RoadSysProfiling.Item.name)
}
inline std::string* RoadSysProfiling_Item::mutable_name() {
  // @@protoc_insertion_point(field_mutable:perception.hz.RoadSysProfiling.Item.name)
  return _internal_mutable_name();
}
inline const std::string& RoadSysProfiling_Item::_internal_name() const {
  return name_.Get();
}
inline void RoadSysProfiling_Item::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RoadSysProfiling_Item::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:perception.hz.RoadSysProfiling.Item.name)
}
inline void RoadSysProfiling_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:perception.hz.RoadSysProfiling.Item.name)
}
inline void RoadSysProfiling_Item::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:perception.hz.RoadSysProfiling.Item.name)
}
inline std::string* RoadSysProfiling_Item::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RoadSysProfiling_Item::release_name() {
  // @@protoc_insertion_point(field_release:perception.hz.RoadSysProfiling.Item.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RoadSysProfiling_Item::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:perception.hz.RoadSysProfiling.Item.name)
}
inline std::string* RoadSysProfiling_Item::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:perception.hz.RoadSysProfiling.Item.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RoadSysProfiling_Item::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.RoadSysProfiling.Item.name)
}

// float val = 2;
inline void RoadSysProfiling_Item::clear_val() {
  val_ = 0;
}
inline float RoadSysProfiling_Item::_internal_val() const {
  return val_;
}
inline float RoadSysProfiling_Item::val() const {
  // @@protoc_insertion_point(field_get:perception.hz.RoadSysProfiling.Item.val)
  return _internal_val();
}
inline void RoadSysProfiling_Item::_internal_set_val(float value) {
  
  val_ = value;
}
inline void RoadSysProfiling_Item::set_val(float value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:perception.hz.RoadSysProfiling.Item.val)
}

// -------------------------------------------------------------------

// RoadSysProfiling

// repeated .perception.hz.RoadSysProfiling.Item items = 3;
inline int RoadSysProfiling::_internal_items_size() const {
  return items_.size();
}
inline int RoadSysProfiling::items_size() const {
  return _internal_items_size();
}
inline void RoadSysProfiling::clear_items() {
  items_.Clear();
}
inline ::perception::hz::RoadSysProfiling_Item* RoadSysProfiling::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:perception.hz.RoadSysProfiling.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::RoadSysProfiling_Item >*
RoadSysProfiling::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:perception.hz.RoadSysProfiling.items)
  return &items_;
}
inline const ::perception::hz::RoadSysProfiling_Item& RoadSysProfiling::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::perception::hz::RoadSysProfiling_Item& RoadSysProfiling::items(int index) const {
  // @@protoc_insertion_point(field_get:perception.hz.RoadSysProfiling.items)
  return _internal_items(index);
}
inline ::perception::hz::RoadSysProfiling_Item* RoadSysProfiling::_internal_add_items() {
  return items_.Add();
}
inline ::perception::hz::RoadSysProfiling_Item* RoadSysProfiling::add_items() {
  // @@protoc_insertion_point(field_add:perception.hz.RoadSysProfiling.items)
  return _internal_add_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::RoadSysProfiling_Item >&
RoadSysProfiling::items() const {
  // @@protoc_insertion_point(field_list:perception.hz.RoadSysProfiling.items)
  return items_;
}

// -------------------------------------------------------------------

// Roadmarking_CurveCoeff

// float longitude_min = 1;
inline void Roadmarking_CurveCoeff::clear_longitude_min() {
  longitude_min_ = 0;
}
inline float Roadmarking_CurveCoeff::_internal_longitude_min() const {
  return longitude_min_;
}
inline float Roadmarking_CurveCoeff::longitude_min() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.CurveCoeff.longitude_min)
  return _internal_longitude_min();
}
inline void Roadmarking_CurveCoeff::_internal_set_longitude_min(float value) {
  
  longitude_min_ = value;
}
inline void Roadmarking_CurveCoeff::set_longitude_min(float value) {
  _internal_set_longitude_min(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.CurveCoeff.longitude_min)
}

// float longitude_max = 2;
inline void Roadmarking_CurveCoeff::clear_longitude_max() {
  longitude_max_ = 0;
}
inline float Roadmarking_CurveCoeff::_internal_longitude_max() const {
  return longitude_max_;
}
inline float Roadmarking_CurveCoeff::longitude_max() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.CurveCoeff.longitude_max)
  return _internal_longitude_max();
}
inline void Roadmarking_CurveCoeff::_internal_set_longitude_max(float value) {
  
  longitude_max_ = value;
}
inline void Roadmarking_CurveCoeff::set_longitude_max(float value) {
  _internal_set_longitude_max(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.CurveCoeff.longitude_max)
}

// double c0 = 3;
inline void Roadmarking_CurveCoeff::clear_c0() {
  c0_ = 0;
}
inline double Roadmarking_CurveCoeff::_internal_c0() const {
  return c0_;
}
inline double Roadmarking_CurveCoeff::c0() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.CurveCoeff.c0)
  return _internal_c0();
}
inline void Roadmarking_CurveCoeff::_internal_set_c0(double value) {
  
  c0_ = value;
}
inline void Roadmarking_CurveCoeff::set_c0(double value) {
  _internal_set_c0(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.CurveCoeff.c0)
}

// double c1 = 4;
inline void Roadmarking_CurveCoeff::clear_c1() {
  c1_ = 0;
}
inline double Roadmarking_CurveCoeff::_internal_c1() const {
  return c1_;
}
inline double Roadmarking_CurveCoeff::c1() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.CurveCoeff.c1)
  return _internal_c1();
}
inline void Roadmarking_CurveCoeff::_internal_set_c1(double value) {
  
  c1_ = value;
}
inline void Roadmarking_CurveCoeff::set_c1(double value) {
  _internal_set_c1(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.CurveCoeff.c1)
}

// double c2 = 5;
inline void Roadmarking_CurveCoeff::clear_c2() {
  c2_ = 0;
}
inline double Roadmarking_CurveCoeff::_internal_c2() const {
  return c2_;
}
inline double Roadmarking_CurveCoeff::c2() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.CurveCoeff.c2)
  return _internal_c2();
}
inline void Roadmarking_CurveCoeff::_internal_set_c2(double value) {
  
  c2_ = value;
}
inline void Roadmarking_CurveCoeff::set_c2(double value) {
  _internal_set_c2(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.CurveCoeff.c2)
}

// double c3 = 6;
inline void Roadmarking_CurveCoeff::clear_c3() {
  c3_ = 0;
}
inline double Roadmarking_CurveCoeff::_internal_c3() const {
  return c3_;
}
inline double Roadmarking_CurveCoeff::c3() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.CurveCoeff.c3)
  return _internal_c3();
}
inline void Roadmarking_CurveCoeff::_internal_set_c3(double value) {
  
  c3_ = value;
}
inline void Roadmarking_CurveCoeff::set_c3(double value) {
  _internal_set_c3(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.CurveCoeff.c3)
}

// double dev_c0 = 7;
inline void Roadmarking_CurveCoeff::clear_dev_c0() {
  dev_c0_ = 0;
}
inline double Roadmarking_CurveCoeff::_internal_dev_c0() const {
  return dev_c0_;
}
inline double Roadmarking_CurveCoeff::dev_c0() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.CurveCoeff.dev_c0)
  return _internal_dev_c0();
}
inline void Roadmarking_CurveCoeff::_internal_set_dev_c0(double value) {
  
  dev_c0_ = value;
}
inline void Roadmarking_CurveCoeff::set_dev_c0(double value) {
  _internal_set_dev_c0(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.CurveCoeff.dev_c0)
}

// double dev_c1 = 8;
inline void Roadmarking_CurveCoeff::clear_dev_c1() {
  dev_c1_ = 0;
}
inline double Roadmarking_CurveCoeff::_internal_dev_c1() const {
  return dev_c1_;
}
inline double Roadmarking_CurveCoeff::dev_c1() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.CurveCoeff.dev_c1)
  return _internal_dev_c1();
}
inline void Roadmarking_CurveCoeff::_internal_set_dev_c1(double value) {
  
  dev_c1_ = value;
}
inline void Roadmarking_CurveCoeff::set_dev_c1(double value) {
  _internal_set_dev_c1(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.CurveCoeff.dev_c1)
}

// double dev_c2 = 9;
inline void Roadmarking_CurveCoeff::clear_dev_c2() {
  dev_c2_ = 0;
}
inline double Roadmarking_CurveCoeff::_internal_dev_c2() const {
  return dev_c2_;
}
inline double Roadmarking_CurveCoeff::dev_c2() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.CurveCoeff.dev_c2)
  return _internal_dev_c2();
}
inline void Roadmarking_CurveCoeff::_internal_set_dev_c2(double value) {
  
  dev_c2_ = value;
}
inline void Roadmarking_CurveCoeff::set_dev_c2(double value) {
  _internal_set_dev_c2(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.CurveCoeff.dev_c2)
}

// double dev_c3 = 10;
inline void Roadmarking_CurveCoeff::clear_dev_c3() {
  dev_c3_ = 0;
}
inline double Roadmarking_CurveCoeff::_internal_dev_c3() const {
  return dev_c3_;
}
inline double Roadmarking_CurveCoeff::dev_c3() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.CurveCoeff.dev_c3)
  return _internal_dev_c3();
}
inline void Roadmarking_CurveCoeff::_internal_set_dev_c3(double value) {
  
  dev_c3_ = value;
}
inline void Roadmarking_CurveCoeff::set_dev_c3(double value) {
  _internal_set_dev_c3(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.CurveCoeff.dev_c3)
}

// -------------------------------------------------------------------

// Roadmarking_Laneline

// .perception.hz.Roadmarking.LineType type = 1;
inline void Roadmarking_Laneline::clear_type() {
  type_ = 0;
}
inline ::perception::hz::Roadmarking_LineType Roadmarking_Laneline::_internal_type() const {
  return static_cast< ::perception::hz::Roadmarking_LineType >(type_);
}
inline ::perception::hz::Roadmarking_LineType Roadmarking_Laneline::type() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.type)
  return _internal_type();
}
inline void Roadmarking_Laneline::_internal_set_type(::perception::hz::Roadmarking_LineType value) {
  
  type_ = value;
}
inline void Roadmarking_Laneline::set_type(::perception::hz::Roadmarking_LineType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Laneline.type)
}

// .perception.hz.Roadmarking.LanelinePositionType pos_type = 2;
inline void Roadmarking_Laneline::clear_pos_type() {
  pos_type_ = 0;
}
inline ::perception::hz::Roadmarking_LanelinePositionType Roadmarking_Laneline::_internal_pos_type() const {
  return static_cast< ::perception::hz::Roadmarking_LanelinePositionType >(pos_type_);
}
inline ::perception::hz::Roadmarking_LanelinePositionType Roadmarking_Laneline::pos_type() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.pos_type)
  return _internal_pos_type();
}
inline void Roadmarking_Laneline::_internal_set_pos_type(::perception::hz::Roadmarking_LanelinePositionType value) {
  
  pos_type_ = value;
}
inline void Roadmarking_Laneline::set_pos_type(::perception::hz::Roadmarking_LanelinePositionType value) {
  _internal_set_pos_type(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Laneline.pos_type)
}

// .perception.hz.Roadmarking.ColorType color_type = 3;
inline void Roadmarking_Laneline::clear_color_type() {
  color_type_ = 0;
}
inline ::perception::hz::Roadmarking_ColorType Roadmarking_Laneline::_internal_color_type() const {
  return static_cast< ::perception::hz::Roadmarking_ColorType >(color_type_);
}
inline ::perception::hz::Roadmarking_ColorType Roadmarking_Laneline::color_type() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.color_type)
  return _internal_color_type();
}
inline void Roadmarking_Laneline::_internal_set_color_type(::perception::hz::Roadmarking_ColorType value) {
  
  color_type_ = value;
}
inline void Roadmarking_Laneline::set_color_type(::perception::hz::Roadmarking_ColorType value) {
  _internal_set_color_type(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Laneline.color_type)
}

// .perception.hz.Roadmarking.CurveCoeff curve_vehicle_coord = 4;
inline bool Roadmarking_Laneline::_internal_has_curve_vehicle_coord() const {
  return this != internal_default_instance() && curve_vehicle_coord_ != nullptr;
}
inline bool Roadmarking_Laneline::has_curve_vehicle_coord() const {
  return _internal_has_curve_vehicle_coord();
}
inline void Roadmarking_Laneline::clear_curve_vehicle_coord() {
  if (GetArena() == nullptr && curve_vehicle_coord_ != nullptr) {
    delete curve_vehicle_coord_;
  }
  curve_vehicle_coord_ = nullptr;
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking_Laneline::_internal_curve_vehicle_coord() const {
  const ::perception::hz::Roadmarking_CurveCoeff* p = curve_vehicle_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_CurveCoeff*>(
      &::perception::hz::_Roadmarking_CurveCoeff_default_instance_);
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking_Laneline::curve_vehicle_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.curve_vehicle_coord)
  return _internal_curve_vehicle_coord();
}
inline void Roadmarking_Laneline::unsafe_arena_set_allocated_curve_vehicle_coord(
    ::perception::hz::Roadmarking_CurveCoeff* curve_vehicle_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(curve_vehicle_coord_);
  }
  curve_vehicle_coord_ = curve_vehicle_coord;
  if (curve_vehicle_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Laneline.curve_vehicle_coord)
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_Laneline::release_curve_vehicle_coord() {
  auto temp = unsafe_arena_release_curve_vehicle_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_Laneline::unsafe_arena_release_curve_vehicle_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Laneline.curve_vehicle_coord)
  
  ::perception::hz::Roadmarking_CurveCoeff* temp = curve_vehicle_coord_;
  curve_vehicle_coord_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_Laneline::_internal_mutable_curve_vehicle_coord() {
  
  if (curve_vehicle_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_CurveCoeff>(GetArena());
    curve_vehicle_coord_ = p;
  }
  return curve_vehicle_coord_;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_Laneline::mutable_curve_vehicle_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Laneline.curve_vehicle_coord)
  return _internal_mutable_curve_vehicle_coord();
}
inline void Roadmarking_Laneline::set_allocated_curve_vehicle_coord(::perception::hz::Roadmarking_CurveCoeff* curve_vehicle_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete curve_vehicle_coord_;
  }
  if (curve_vehicle_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(curve_vehicle_coord);
    if (message_arena != submessage_arena) {
      curve_vehicle_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curve_vehicle_coord, submessage_arena);
    }
    
  } else {
    
  }
  curve_vehicle_coord_ = curve_vehicle_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Laneline.curve_vehicle_coord)
}

// .perception.hz.Roadmarking.CurveCoeff curve_image_coord = 5;
inline bool Roadmarking_Laneline::_internal_has_curve_image_coord() const {
  return this != internal_default_instance() && curve_image_coord_ != nullptr;
}
inline bool Roadmarking_Laneline::has_curve_image_coord() const {
  return _internal_has_curve_image_coord();
}
inline void Roadmarking_Laneline::clear_curve_image_coord() {
  if (GetArena() == nullptr && curve_image_coord_ != nullptr) {
    delete curve_image_coord_;
  }
  curve_image_coord_ = nullptr;
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking_Laneline::_internal_curve_image_coord() const {
  const ::perception::hz::Roadmarking_CurveCoeff* p = curve_image_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_CurveCoeff*>(
      &::perception::hz::_Roadmarking_CurveCoeff_default_instance_);
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking_Laneline::curve_image_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.curve_image_coord)
  return _internal_curve_image_coord();
}
inline void Roadmarking_Laneline::unsafe_arena_set_allocated_curve_image_coord(
    ::perception::hz::Roadmarking_CurveCoeff* curve_image_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(curve_image_coord_);
  }
  curve_image_coord_ = curve_image_coord;
  if (curve_image_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Laneline.curve_image_coord)
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_Laneline::release_curve_image_coord() {
  auto temp = unsafe_arena_release_curve_image_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_Laneline::unsafe_arena_release_curve_image_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Laneline.curve_image_coord)
  
  ::perception::hz::Roadmarking_CurveCoeff* temp = curve_image_coord_;
  curve_image_coord_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_Laneline::_internal_mutable_curve_image_coord() {
  
  if (curve_image_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_CurveCoeff>(GetArena());
    curve_image_coord_ = p;
  }
  return curve_image_coord_;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_Laneline::mutable_curve_image_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Laneline.curve_image_coord)
  return _internal_mutable_curve_image_coord();
}
inline void Roadmarking_Laneline::set_allocated_curve_image_coord(::perception::hz::Roadmarking_CurveCoeff* curve_image_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete curve_image_coord_;
  }
  if (curve_image_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(curve_image_coord);
    if (message_arena != submessage_arena) {
      curve_image_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curve_image_coord, submessage_arena);
    }
    
  } else {
    
  }
  curve_image_coord_ = curve_image_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Laneline.curve_image_coord)
}

// .perception.common.Point2fList points_image_coord = 6;
inline bool Roadmarking_Laneline::_internal_has_points_image_coord() const {
  return this != internal_default_instance() && points_image_coord_ != nullptr;
}
inline bool Roadmarking_Laneline::has_points_image_coord() const {
  return _internal_has_points_image_coord();
}
inline const ::perception::common::Point2fList& Roadmarking_Laneline::_internal_points_image_coord() const {
  const ::perception::common::Point2fList* p = points_image_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2fList*>(
      &::perception::common::_Point2fList_default_instance_);
}
inline const ::perception::common::Point2fList& Roadmarking_Laneline::points_image_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.points_image_coord)
  return _internal_points_image_coord();
}
inline void Roadmarking_Laneline::unsafe_arena_set_allocated_points_image_coord(
    ::perception::common::Point2fList* points_image_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_image_coord_);
  }
  points_image_coord_ = points_image_coord;
  if (points_image_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Laneline.points_image_coord)
}
inline ::perception::common::Point2fList* Roadmarking_Laneline::release_points_image_coord() {
  auto temp = unsafe_arena_release_points_image_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2fList* Roadmarking_Laneline::unsafe_arena_release_points_image_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Laneline.points_image_coord)
  
  ::perception::common::Point2fList* temp = points_image_coord_;
  points_image_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point2fList* Roadmarking_Laneline::_internal_mutable_points_image_coord() {
  
  if (points_image_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2fList>(GetArena());
    points_image_coord_ = p;
  }
  return points_image_coord_;
}
inline ::perception::common::Point2fList* Roadmarking_Laneline::mutable_points_image_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Laneline.points_image_coord)
  return _internal_mutable_points_image_coord();
}
inline void Roadmarking_Laneline::set_allocated_points_image_coord(::perception::common::Point2fList* points_image_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_image_coord_);
  }
  if (points_image_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_image_coord)->GetArena();
    if (message_arena != submessage_arena) {
      points_image_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points_image_coord, submessage_arena);
    }
    
  } else {
    
  }
  points_image_coord_ = points_image_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Laneline.points_image_coord)
}

// .perception.common.Point3fList points_vehicle_coord = 7;
inline bool Roadmarking_Laneline::_internal_has_points_vehicle_coord() const {
  return this != internal_default_instance() && points_vehicle_coord_ != nullptr;
}
inline bool Roadmarking_Laneline::has_points_vehicle_coord() const {
  return _internal_has_points_vehicle_coord();
}
inline const ::perception::common::Point3fList& Roadmarking_Laneline::_internal_points_vehicle_coord() const {
  const ::perception::common::Point3fList* p = points_vehicle_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point3fList*>(
      &::perception::common::_Point3fList_default_instance_);
}
inline const ::perception::common::Point3fList& Roadmarking_Laneline::points_vehicle_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.points_vehicle_coord)
  return _internal_points_vehicle_coord();
}
inline void Roadmarking_Laneline::unsafe_arena_set_allocated_points_vehicle_coord(
    ::perception::common::Point3fList* points_vehicle_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_vehicle_coord_);
  }
  points_vehicle_coord_ = points_vehicle_coord;
  if (points_vehicle_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Laneline.points_vehicle_coord)
}
inline ::perception::common::Point3fList* Roadmarking_Laneline::release_points_vehicle_coord() {
  auto temp = unsafe_arena_release_points_vehicle_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point3fList* Roadmarking_Laneline::unsafe_arena_release_points_vehicle_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Laneline.points_vehicle_coord)
  
  ::perception::common::Point3fList* temp = points_vehicle_coord_;
  points_vehicle_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point3fList* Roadmarking_Laneline::_internal_mutable_points_vehicle_coord() {
  
  if (points_vehicle_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point3fList>(GetArena());
    points_vehicle_coord_ = p;
  }
  return points_vehicle_coord_;
}
inline ::perception::common::Point3fList* Roadmarking_Laneline::mutable_points_vehicle_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Laneline.points_vehicle_coord)
  return _internal_mutable_points_vehicle_coord();
}
inline void Roadmarking_Laneline::set_allocated_points_vehicle_coord(::perception::common::Point3fList* points_vehicle_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_vehicle_coord_);
  }
  if (points_vehicle_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_vehicle_coord)->GetArena();
    if (message_arena != submessage_arena) {
      points_vehicle_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points_vehicle_coord, submessage_arena);
    }
    
  } else {
    
  }
  points_vehicle_coord_ = points_vehicle_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Laneline.points_vehicle_coord)
}

// .perception.common.Point2fList fit_points_image_coord = 8;
inline bool Roadmarking_Laneline::_internal_has_fit_points_image_coord() const {
  return this != internal_default_instance() && fit_points_image_coord_ != nullptr;
}
inline bool Roadmarking_Laneline::has_fit_points_image_coord() const {
  return _internal_has_fit_points_image_coord();
}
inline const ::perception::common::Point2fList& Roadmarking_Laneline::_internal_fit_points_image_coord() const {
  const ::perception::common::Point2fList* p = fit_points_image_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2fList*>(
      &::perception::common::_Point2fList_default_instance_);
}
inline const ::perception::common::Point2fList& Roadmarking_Laneline::fit_points_image_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.fit_points_image_coord)
  return _internal_fit_points_image_coord();
}
inline void Roadmarking_Laneline::unsafe_arena_set_allocated_fit_points_image_coord(
    ::perception::common::Point2fList* fit_points_image_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_image_coord_);
  }
  fit_points_image_coord_ = fit_points_image_coord;
  if (fit_points_image_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Laneline.fit_points_image_coord)
}
inline ::perception::common::Point2fList* Roadmarking_Laneline::release_fit_points_image_coord() {
  auto temp = unsafe_arena_release_fit_points_image_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2fList* Roadmarking_Laneline::unsafe_arena_release_fit_points_image_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Laneline.fit_points_image_coord)
  
  ::perception::common::Point2fList* temp = fit_points_image_coord_;
  fit_points_image_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point2fList* Roadmarking_Laneline::_internal_mutable_fit_points_image_coord() {
  
  if (fit_points_image_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2fList>(GetArena());
    fit_points_image_coord_ = p;
  }
  return fit_points_image_coord_;
}
inline ::perception::common::Point2fList* Roadmarking_Laneline::mutable_fit_points_image_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Laneline.fit_points_image_coord)
  return _internal_mutable_fit_points_image_coord();
}
inline void Roadmarking_Laneline::set_allocated_fit_points_image_coord(::perception::common::Point2fList* fit_points_image_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_image_coord_);
  }
  if (fit_points_image_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_image_coord)->GetArena();
    if (message_arena != submessage_arena) {
      fit_points_image_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fit_points_image_coord, submessage_arena);
    }
    
  } else {
    
  }
  fit_points_image_coord_ = fit_points_image_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Laneline.fit_points_image_coord)
}

// .perception.common.Point3fList fit_points_vehicle_coord = 9;
inline bool Roadmarking_Laneline::_internal_has_fit_points_vehicle_coord() const {
  return this != internal_default_instance() && fit_points_vehicle_coord_ != nullptr;
}
inline bool Roadmarking_Laneline::has_fit_points_vehicle_coord() const {
  return _internal_has_fit_points_vehicle_coord();
}
inline const ::perception::common::Point3fList& Roadmarking_Laneline::_internal_fit_points_vehicle_coord() const {
  const ::perception::common::Point3fList* p = fit_points_vehicle_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point3fList*>(
      &::perception::common::_Point3fList_default_instance_);
}
inline const ::perception::common::Point3fList& Roadmarking_Laneline::fit_points_vehicle_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.fit_points_vehicle_coord)
  return _internal_fit_points_vehicle_coord();
}
inline void Roadmarking_Laneline::unsafe_arena_set_allocated_fit_points_vehicle_coord(
    ::perception::common::Point3fList* fit_points_vehicle_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_vehicle_coord_);
  }
  fit_points_vehicle_coord_ = fit_points_vehicle_coord;
  if (fit_points_vehicle_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Laneline.fit_points_vehicle_coord)
}
inline ::perception::common::Point3fList* Roadmarking_Laneline::release_fit_points_vehicle_coord() {
  auto temp = unsafe_arena_release_fit_points_vehicle_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point3fList* Roadmarking_Laneline::unsafe_arena_release_fit_points_vehicle_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Laneline.fit_points_vehicle_coord)
  
  ::perception::common::Point3fList* temp = fit_points_vehicle_coord_;
  fit_points_vehicle_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point3fList* Roadmarking_Laneline::_internal_mutable_fit_points_vehicle_coord() {
  
  if (fit_points_vehicle_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point3fList>(GetArena());
    fit_points_vehicle_coord_ = p;
  }
  return fit_points_vehicle_coord_;
}
inline ::perception::common::Point3fList* Roadmarking_Laneline::mutable_fit_points_vehicle_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Laneline.fit_points_vehicle_coord)
  return _internal_mutable_fit_points_vehicle_coord();
}
inline void Roadmarking_Laneline::set_allocated_fit_points_vehicle_coord(::perception::common::Point3fList* fit_points_vehicle_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_vehicle_coord_);
  }
  if (fit_points_vehicle_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_vehicle_coord)->GetArena();
    if (message_arena != submessage_arena) {
      fit_points_vehicle_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fit_points_vehicle_coord, submessage_arena);
    }
    
  } else {
    
  }
  fit_points_vehicle_coord_ = fit_points_vehicle_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Laneline.fit_points_vehicle_coord)
}

// uint64 id = 10;
inline void Roadmarking_Laneline::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking_Laneline::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking_Laneline::id() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.id)
  return _internal_id();
}
inline void Roadmarking_Laneline::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Roadmarking_Laneline::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Laneline.id)
}

// .perception.hz.Roadmarking.LineState line_state = 11;
inline void Roadmarking_Laneline::clear_line_state() {
  line_state_ = 0;
}
inline ::perception::hz::Roadmarking_LineState Roadmarking_Laneline::_internal_line_state() const {
  return static_cast< ::perception::hz::Roadmarking_LineState >(line_state_);
}
inline ::perception::hz::Roadmarking_LineState Roadmarking_Laneline::line_state() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.line_state)
  return _internal_line_state();
}
inline void Roadmarking_Laneline::_internal_set_line_state(::perception::hz::Roadmarking_LineState value) {
  
  line_state_ = value;
}
inline void Roadmarking_Laneline::set_line_state(::perception::hz::Roadmarking_LineState value) {
  _internal_set_line_state(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Laneline.line_state)
}

// float confidence = 12;
inline void Roadmarking_Laneline::clear_confidence() {
  confidence_ = 0;
}
inline float Roadmarking_Laneline::_internal_confidence() const {
  return confidence_;
}
inline float Roadmarking_Laneline::confidence() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.confidence)
  return _internal_confidence();
}
inline void Roadmarking_Laneline::_internal_set_confidence(float value) {
  
  confidence_ = value;
}
inline void Roadmarking_Laneline::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Laneline.confidence)
}

// float width = 13;
inline void Roadmarking_Laneline::clear_width() {
  width_ = 0;
}
inline float Roadmarking_Laneline::_internal_width() const {
  return width_;
}
inline float Roadmarking_Laneline::width() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.width)
  return _internal_width();
}
inline void Roadmarking_Laneline::_internal_set_width(float value) {
  
  width_ = value;
}
inline void Roadmarking_Laneline::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Laneline.width)
}

// uint32 age = 14;
inline void Roadmarking_Laneline::clear_age() {
  age_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_Laneline::_internal_age() const {
  return age_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_Laneline::age() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.age)
  return _internal_age();
}
inline void Roadmarking_Laneline::_internal_set_age(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  age_ = value;
}
inline void Roadmarking_Laneline::set_age(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_age(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Laneline.age)
}

// repeated uint32 point_cam_id = 15;
inline int Roadmarking_Laneline::_internal_point_cam_id_size() const {
  return point_cam_id_.size();
}
inline int Roadmarking_Laneline::point_cam_id_size() const {
  return _internal_point_cam_id_size();
}
inline void Roadmarking_Laneline::clear_point_cam_id() {
  point_cam_id_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_Laneline::_internal_point_cam_id(int index) const {
  return point_cam_id_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_Laneline::point_cam_id(int index) const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.point_cam_id)
  return _internal_point_cam_id(index);
}
inline void Roadmarking_Laneline::set_point_cam_id(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  point_cam_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Laneline.point_cam_id)
}
inline void Roadmarking_Laneline::_internal_add_point_cam_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  point_cam_id_.Add(value);
}
inline void Roadmarking_Laneline::add_point_cam_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_point_cam_id(value);
  // @@protoc_insertion_point(field_add:perception.hz.Roadmarking.Laneline.point_cam_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Roadmarking_Laneline::_internal_point_cam_id() const {
  return point_cam_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Roadmarking_Laneline::point_cam_id() const {
  // @@protoc_insertion_point(field_list:perception.hz.Roadmarking.Laneline.point_cam_id)
  return _internal_point_cam_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Roadmarking_Laneline::_internal_mutable_point_cam_id() {
  return &point_cam_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Roadmarking_Laneline::mutable_point_cam_id() {
  // @@protoc_insertion_point(field_mutable_list:perception.hz.Roadmarking.Laneline.point_cam_id)
  return _internal_mutable_point_cam_id();
}

// .perception.common.Point2f centroid_pt = 16;
inline bool Roadmarking_Laneline::_internal_has_centroid_pt() const {
  return this != internal_default_instance() && centroid_pt_ != nullptr;
}
inline bool Roadmarking_Laneline::has_centroid_pt() const {
  return _internal_has_centroid_pt();
}
inline const ::perception::common::Point2f& Roadmarking_Laneline::_internal_centroid_pt() const {
  const ::perception::common::Point2f* p = centroid_pt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2f*>(
      &::perception::common::_Point2f_default_instance_);
}
inline const ::perception::common::Point2f& Roadmarking_Laneline::centroid_pt() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.centroid_pt)
  return _internal_centroid_pt();
}
inline void Roadmarking_Laneline::unsafe_arena_set_allocated_centroid_pt(
    ::perception::common::Point2f* centroid_pt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(centroid_pt_);
  }
  centroid_pt_ = centroid_pt;
  if (centroid_pt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Laneline.centroid_pt)
}
inline ::perception::common::Point2f* Roadmarking_Laneline::release_centroid_pt() {
  auto temp = unsafe_arena_release_centroid_pt();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_Laneline::unsafe_arena_release_centroid_pt() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Laneline.centroid_pt)
  
  ::perception::common::Point2f* temp = centroid_pt_;
  centroid_pt_ = nullptr;
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_Laneline::_internal_mutable_centroid_pt() {
  
  if (centroid_pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2f>(GetArena());
    centroid_pt_ = p;
  }
  return centroid_pt_;
}
inline ::perception::common::Point2f* Roadmarking_Laneline::mutable_centroid_pt() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Laneline.centroid_pt)
  return _internal_mutable_centroid_pt();
}
inline void Roadmarking_Laneline::set_allocated_centroid_pt(::perception::common::Point2f* centroid_pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(centroid_pt_);
  }
  if (centroid_pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(centroid_pt)->GetArena();
    if (message_arena != submessage_arena) {
      centroid_pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, centroid_pt, submessage_arena);
    }
    
  } else {
    
  }
  centroid_pt_ = centroid_pt;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Laneline.centroid_pt)
}

// int32 lane_id = 17;
inline void Roadmarking_Laneline::clear_lane_id() {
  lane_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Roadmarking_Laneline::_internal_lane_id() const {
  return lane_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Roadmarking_Laneline::lane_id() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Laneline.lane_id)
  return _internal_lane_id();
}
inline void Roadmarking_Laneline::_internal_set_lane_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lane_id_ = value;
}
inline void Roadmarking_Laneline::set_lane_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lane_id(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Laneline.lane_id)
}

// -------------------------------------------------------------------

// Roadmarking_LanelineList

// repeated .perception.hz.Roadmarking.Laneline line = 1;
inline int Roadmarking_LanelineList::_internal_line_size() const {
  return line_.size();
}
inline int Roadmarking_LanelineList::line_size() const {
  return _internal_line_size();
}
inline void Roadmarking_LanelineList::clear_line() {
  line_.Clear();
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_LanelineList::mutable_line(int index) {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.LanelineList.line)
  return line_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Laneline >*
Roadmarking_LanelineList::mutable_line() {
  // @@protoc_insertion_point(field_mutable_list:perception.hz.Roadmarking.LanelineList.line)
  return &line_;
}
inline const ::perception::hz::Roadmarking_Laneline& Roadmarking_LanelineList::_internal_line(int index) const {
  return line_.Get(index);
}
inline const ::perception::hz::Roadmarking_Laneline& Roadmarking_LanelineList::line(int index) const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LanelineList.line)
  return _internal_line(index);
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_LanelineList::_internal_add_line() {
  return line_.Add();
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_LanelineList::add_line() {
  // @@protoc_insertion_point(field_add:perception.hz.Roadmarking.LanelineList.line)
  return _internal_add_line();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Laneline >&
Roadmarking_LanelineList::line() const {
  // @@protoc_insertion_point(field_list:perception.hz.Roadmarking.LanelineList.line)
  return line_;
}

// -------------------------------------------------------------------

// Roadmarking_FreeSpaces_FreeZone

// .perception.common.Point2f point_image_coord = 1;
inline bool Roadmarking_FreeSpaces_FreeZone::_internal_has_point_image_coord() const {
  return this != internal_default_instance() && point_image_coord_ != nullptr;
}
inline bool Roadmarking_FreeSpaces_FreeZone::has_point_image_coord() const {
  return _internal_has_point_image_coord();
}
inline const ::perception::common::Point2f& Roadmarking_FreeSpaces_FreeZone::_internal_point_image_coord() const {
  const ::perception::common::Point2f* p = point_image_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2f*>(
      &::perception::common::_Point2f_default_instance_);
}
inline const ::perception::common::Point2f& Roadmarking_FreeSpaces_FreeZone::point_image_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.FreeZone.point_image_coord)
  return _internal_point_image_coord();
}
inline void Roadmarking_FreeSpaces_FreeZone::unsafe_arena_set_allocated_point_image_coord(
    ::perception::common::Point2f* point_image_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_image_coord_);
  }
  point_image_coord_ = point_image_coord;
  if (point_image_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.FreeSpaces.FreeZone.point_image_coord)
}
inline ::perception::common::Point2f* Roadmarking_FreeSpaces_FreeZone::release_point_image_coord() {
  auto temp = unsafe_arena_release_point_image_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_FreeSpaces_FreeZone::unsafe_arena_release_point_image_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.FreeSpaces.FreeZone.point_image_coord)
  
  ::perception::common::Point2f* temp = point_image_coord_;
  point_image_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_FreeSpaces_FreeZone::_internal_mutable_point_image_coord() {
  
  if (point_image_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2f>(GetArena());
    point_image_coord_ = p;
  }
  return point_image_coord_;
}
inline ::perception::common::Point2f* Roadmarking_FreeSpaces_FreeZone::mutable_point_image_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.FreeSpaces.FreeZone.point_image_coord)
  return _internal_mutable_point_image_coord();
}
inline void Roadmarking_FreeSpaces_FreeZone::set_allocated_point_image_coord(::perception::common::Point2f* point_image_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_image_coord_);
  }
  if (point_image_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_image_coord)->GetArena();
    if (message_arena != submessage_arena) {
      point_image_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_image_coord, submessage_arena);
    }
    
  } else {
    
  }
  point_image_coord_ = point_image_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.FreeSpaces.FreeZone.point_image_coord)
}

// .perception.common.Point3f point_vehicle_coord = 2;
inline bool Roadmarking_FreeSpaces_FreeZone::_internal_has_point_vehicle_coord() const {
  return this != internal_default_instance() && point_vehicle_coord_ != nullptr;
}
inline bool Roadmarking_FreeSpaces_FreeZone::has_point_vehicle_coord() const {
  return _internal_has_point_vehicle_coord();
}
inline const ::perception::common::Point3f& Roadmarking_FreeSpaces_FreeZone::_internal_point_vehicle_coord() const {
  const ::perception::common::Point3f* p = point_vehicle_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point3f*>(
      &::perception::common::_Point3f_default_instance_);
}
inline const ::perception::common::Point3f& Roadmarking_FreeSpaces_FreeZone::point_vehicle_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.FreeZone.point_vehicle_coord)
  return _internal_point_vehicle_coord();
}
inline void Roadmarking_FreeSpaces_FreeZone::unsafe_arena_set_allocated_point_vehicle_coord(
    ::perception::common::Point3f* point_vehicle_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_vehicle_coord_);
  }
  point_vehicle_coord_ = point_vehicle_coord;
  if (point_vehicle_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.FreeSpaces.FreeZone.point_vehicle_coord)
}
inline ::perception::common::Point3f* Roadmarking_FreeSpaces_FreeZone::release_point_vehicle_coord() {
  auto temp = unsafe_arena_release_point_vehicle_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point3f* Roadmarking_FreeSpaces_FreeZone::unsafe_arena_release_point_vehicle_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.FreeSpaces.FreeZone.point_vehicle_coord)
  
  ::perception::common::Point3f* temp = point_vehicle_coord_;
  point_vehicle_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point3f* Roadmarking_FreeSpaces_FreeZone::_internal_mutable_point_vehicle_coord() {
  
  if (point_vehicle_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point3f>(GetArena());
    point_vehicle_coord_ = p;
  }
  return point_vehicle_coord_;
}
inline ::perception::common::Point3f* Roadmarking_FreeSpaces_FreeZone::mutable_point_vehicle_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.FreeSpaces.FreeZone.point_vehicle_coord)
  return _internal_mutable_point_vehicle_coord();
}
inline void Roadmarking_FreeSpaces_FreeZone::set_allocated_point_vehicle_coord(::perception::common::Point3f* point_vehicle_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_vehicle_coord_);
  }
  if (point_vehicle_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_vehicle_coord)->GetArena();
    if (message_arena != submessage_arena) {
      point_vehicle_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_vehicle_coord, submessage_arena);
    }
    
  } else {
    
  }
  point_vehicle_coord_ = point_vehicle_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.FreeSpaces.FreeZone.point_vehicle_coord)
}

// float dist = 3;
inline void Roadmarking_FreeSpaces_FreeZone::clear_dist() {
  dist_ = 0;
}
inline float Roadmarking_FreeSpaces_FreeZone::_internal_dist() const {
  return dist_;
}
inline float Roadmarking_FreeSpaces_FreeZone::dist() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.FreeZone.dist)
  return _internal_dist();
}
inline void Roadmarking_FreeSpaces_FreeZone::_internal_set_dist(float value) {
  
  dist_ = value;
}
inline void Roadmarking_FreeSpaces_FreeZone::set_dist(float value) {
  _internal_set_dist(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.FreeSpaces.FreeZone.dist)
}

// float angle = 4;
inline void Roadmarking_FreeSpaces_FreeZone::clear_angle() {
  angle_ = 0;
}
inline float Roadmarking_FreeSpaces_FreeZone::_internal_angle() const {
  return angle_;
}
inline float Roadmarking_FreeSpaces_FreeZone::angle() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.FreeZone.angle)
  return _internal_angle();
}
inline void Roadmarking_FreeSpaces_FreeZone::_internal_set_angle(float value) {
  
  angle_ = value;
}
inline void Roadmarking_FreeSpaces_FreeZone::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.FreeSpaces.FreeZone.angle)
}

// .perception.hz.Roadmarking.LaneIdx lane_index = 5;
inline void Roadmarking_FreeSpaces_FreeZone::clear_lane_index() {
  lane_index_ = 0;
}
inline ::perception::hz::Roadmarking_LaneIdx Roadmarking_FreeSpaces_FreeZone::_internal_lane_index() const {
  return static_cast< ::perception::hz::Roadmarking_LaneIdx >(lane_index_);
}
inline ::perception::hz::Roadmarking_LaneIdx Roadmarking_FreeSpaces_FreeZone::lane_index() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.FreeZone.lane_index)
  return _internal_lane_index();
}
inline void Roadmarking_FreeSpaces_FreeZone::_internal_set_lane_index(::perception::hz::Roadmarking_LaneIdx value) {
  
  lane_index_ = value;
}
inline void Roadmarking_FreeSpaces_FreeZone::set_lane_index(::perception::hz::Roadmarking_LaneIdx value) {
  _internal_set_lane_index(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.FreeSpaces.FreeZone.lane_index)
}

// float confidence = 6;
inline void Roadmarking_FreeSpaces_FreeZone::clear_confidence() {
  confidence_ = 0;
}
inline float Roadmarking_FreeSpaces_FreeZone::_internal_confidence() const {
  return confidence_;
}
inline float Roadmarking_FreeSpaces_FreeZone::confidence() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.FreeZone.confidence)
  return _internal_confidence();
}
inline void Roadmarking_FreeSpaces_FreeZone::_internal_set_confidence(float value) {
  
  confidence_ = value;
}
inline void Roadmarking_FreeSpaces_FreeZone::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.FreeSpaces.FreeZone.confidence)
}

// .perception.hz.Roadmarking.SpaceType type = 7;
inline void Roadmarking_FreeSpaces_FreeZone::clear_type() {
  type_ = 0;
}
inline ::perception::hz::Roadmarking_SpaceType Roadmarking_FreeSpaces_FreeZone::_internal_type() const {
  return static_cast< ::perception::hz::Roadmarking_SpaceType >(type_);
}
inline ::perception::hz::Roadmarking_SpaceType Roadmarking_FreeSpaces_FreeZone::type() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.FreeZone.type)
  return _internal_type();
}
inline void Roadmarking_FreeSpaces_FreeZone::_internal_set_type(::perception::hz::Roadmarking_SpaceType value) {
  
  type_ = value;
}
inline void Roadmarking_FreeSpaces_FreeZone::set_type(::perception::hz::Roadmarking_SpaceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.FreeSpaces.FreeZone.type)
}

// .perception.hz.Roadmarking.FreeSpaces.MotionProp motion_prop = 8;
inline void Roadmarking_FreeSpaces_FreeZone::clear_motion_prop() {
  motion_prop_ = 0;
}
inline ::perception::hz::Roadmarking_FreeSpaces_MotionProp Roadmarking_FreeSpaces_FreeZone::_internal_motion_prop() const {
  return static_cast< ::perception::hz::Roadmarking_FreeSpaces_MotionProp >(motion_prop_);
}
inline ::perception::hz::Roadmarking_FreeSpaces_MotionProp Roadmarking_FreeSpaces_FreeZone::motion_prop() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.FreeZone.motion_prop)
  return _internal_motion_prop();
}
inline void Roadmarking_FreeSpaces_FreeZone::_internal_set_motion_prop(::perception::hz::Roadmarking_FreeSpaces_MotionProp value) {
  
  motion_prop_ = value;
}
inline void Roadmarking_FreeSpaces_FreeZone::set_motion_prop(::perception::hz::Roadmarking_FreeSpaces_MotionProp value) {
  _internal_set_motion_prop(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.FreeSpaces.FreeZone.motion_prop)
}

// uint32 camera_id = 9;
inline void Roadmarking_FreeSpaces_FreeZone::clear_camera_id() {
  camera_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_FreeSpaces_FreeZone::_internal_camera_id() const {
  return camera_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_FreeSpaces_FreeZone::camera_id() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.FreeZone.camera_id)
  return _internal_camera_id();
}
inline void Roadmarking_FreeSpaces_FreeZone::_internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  camera_id_ = value;
}
inline void Roadmarking_FreeSpaces_FreeZone::set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_camera_id(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.FreeSpaces.FreeZone.camera_id)
}

// uint32 sensor_type = 10;
inline void Roadmarking_FreeSpaces_FreeZone::clear_sensor_type() {
  sensor_type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_FreeSpaces_FreeZone::_internal_sensor_type() const {
  return sensor_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_FreeSpaces_FreeZone::sensor_type() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.FreeZone.sensor_type)
  return _internal_sensor_type();
}
inline void Roadmarking_FreeSpaces_FreeZone::_internal_set_sensor_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sensor_type_ = value;
}
inline void Roadmarking_FreeSpaces_FreeZone::set_sensor_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sensor_type(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.FreeSpaces.FreeZone.sensor_type)
}

// -------------------------------------------------------------------

// Roadmarking_FreeSpaces

// repeated .perception.hz.Roadmarking.FreeSpaces.FreeZone freezone = 1;
inline int Roadmarking_FreeSpaces::_internal_freezone_size() const {
  return freezone_.size();
}
inline int Roadmarking_FreeSpaces::freezone_size() const {
  return _internal_freezone_size();
}
inline void Roadmarking_FreeSpaces::clear_freezone() {
  freezone_.Clear();
}
inline ::perception::hz::Roadmarking_FreeSpaces_FreeZone* Roadmarking_FreeSpaces::mutable_freezone(int index) {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.FreeSpaces.freezone)
  return freezone_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_FreeSpaces_FreeZone >*
Roadmarking_FreeSpaces::mutable_freezone() {
  // @@protoc_insertion_point(field_mutable_list:perception.hz.Roadmarking.FreeSpaces.freezone)
  return &freezone_;
}
inline const ::perception::hz::Roadmarking_FreeSpaces_FreeZone& Roadmarking_FreeSpaces::_internal_freezone(int index) const {
  return freezone_.Get(index);
}
inline const ::perception::hz::Roadmarking_FreeSpaces_FreeZone& Roadmarking_FreeSpaces::freezone(int index) const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.freezone)
  return _internal_freezone(index);
}
inline ::perception::hz::Roadmarking_FreeSpaces_FreeZone* Roadmarking_FreeSpaces::_internal_add_freezone() {
  return freezone_.Add();
}
inline ::perception::hz::Roadmarking_FreeSpaces_FreeZone* Roadmarking_FreeSpaces::add_freezone() {
  // @@protoc_insertion_point(field_add:perception.hz.Roadmarking.FreeSpaces.freezone)
  return _internal_add_freezone();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_FreeSpaces_FreeZone >&
Roadmarking_FreeSpaces::freezone() const {
  // @@protoc_insertion_point(field_list:perception.hz.Roadmarking.FreeSpaces.freezone)
  return freezone_;
}

// float dist_std = 2;
inline void Roadmarking_FreeSpaces::clear_dist_std() {
  dist_std_ = 0;
}
inline float Roadmarking_FreeSpaces::_internal_dist_std() const {
  return dist_std_;
}
inline float Roadmarking_FreeSpaces::dist_std() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.dist_std)
  return _internal_dist_std();
}
inline void Roadmarking_FreeSpaces::_internal_set_dist_std(float value) {
  
  dist_std_ = value;
}
inline void Roadmarking_FreeSpaces::set_dist_std(float value) {
  _internal_set_dist_std(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.FreeSpaces.dist_std)
}

// float angle_std = 3;
inline void Roadmarking_FreeSpaces::clear_angle_std() {
  angle_std_ = 0;
}
inline float Roadmarking_FreeSpaces::_internal_angle_std() const {
  return angle_std_;
}
inline float Roadmarking_FreeSpaces::angle_std() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.angle_std)
  return _internal_angle_std();
}
inline void Roadmarking_FreeSpaces::_internal_set_angle_std(float value) {
  
  angle_std_ = value;
}
inline void Roadmarking_FreeSpaces::set_angle_std(float value) {
  _internal_set_angle_std(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.FreeSpaces.angle_std)
}

// float height_std = 4;
inline void Roadmarking_FreeSpaces::clear_height_std() {
  height_std_ = 0;
}
inline float Roadmarking_FreeSpaces::_internal_height_std() const {
  return height_std_;
}
inline float Roadmarking_FreeSpaces::height_std() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.FreeSpaces.height_std)
  return _internal_height_std();
}
inline void Roadmarking_FreeSpaces::_internal_set_height_std(float value) {
  
  height_std_ = value;
}
inline void Roadmarking_FreeSpaces::set_height_std(float value) {
  _internal_set_height_std(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.FreeSpaces.height_std)
}

// -------------------------------------------------------------------

// Roadmarking_RoadEdge

// uint32 id = 1;
inline void Roadmarking_RoadEdge::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_RoadEdge::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_RoadEdge::id() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.id)
  return _internal_id();
}
inline void Roadmarking_RoadEdge::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void Roadmarking_RoadEdge::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.RoadEdge.id)
}

// uint32 age = 2;
inline void Roadmarking_RoadEdge::clear_age() {
  age_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_RoadEdge::_internal_age() const {
  return age_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_RoadEdge::age() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.age)
  return _internal_age();
}
inline void Roadmarking_RoadEdge::_internal_set_age(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  age_ = value;
}
inline void Roadmarking_RoadEdge::set_age(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_age(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.RoadEdge.age)
}

// .perception.hz.Roadmarking.CurveCoeff curve_vehicle_coord = 3;
inline bool Roadmarking_RoadEdge::_internal_has_curve_vehicle_coord() const {
  return this != internal_default_instance() && curve_vehicle_coord_ != nullptr;
}
inline bool Roadmarking_RoadEdge::has_curve_vehicle_coord() const {
  return _internal_has_curve_vehicle_coord();
}
inline void Roadmarking_RoadEdge::clear_curve_vehicle_coord() {
  if (GetArena() == nullptr && curve_vehicle_coord_ != nullptr) {
    delete curve_vehicle_coord_;
  }
  curve_vehicle_coord_ = nullptr;
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking_RoadEdge::_internal_curve_vehicle_coord() const {
  const ::perception::hz::Roadmarking_CurveCoeff* p = curve_vehicle_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_CurveCoeff*>(
      &::perception::hz::_Roadmarking_CurveCoeff_default_instance_);
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking_RoadEdge::curve_vehicle_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.curve_vehicle_coord)
  return _internal_curve_vehicle_coord();
}
inline void Roadmarking_RoadEdge::unsafe_arena_set_allocated_curve_vehicle_coord(
    ::perception::hz::Roadmarking_CurveCoeff* curve_vehicle_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(curve_vehicle_coord_);
  }
  curve_vehicle_coord_ = curve_vehicle_coord;
  if (curve_vehicle_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.RoadEdge.curve_vehicle_coord)
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_RoadEdge::release_curve_vehicle_coord() {
  auto temp = unsafe_arena_release_curve_vehicle_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_RoadEdge::unsafe_arena_release_curve_vehicle_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.RoadEdge.curve_vehicle_coord)
  
  ::perception::hz::Roadmarking_CurveCoeff* temp = curve_vehicle_coord_;
  curve_vehicle_coord_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_RoadEdge::_internal_mutable_curve_vehicle_coord() {
  
  if (curve_vehicle_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_CurveCoeff>(GetArena());
    curve_vehicle_coord_ = p;
  }
  return curve_vehicle_coord_;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_RoadEdge::mutable_curve_vehicle_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.RoadEdge.curve_vehicle_coord)
  return _internal_mutable_curve_vehicle_coord();
}
inline void Roadmarking_RoadEdge::set_allocated_curve_vehicle_coord(::perception::hz::Roadmarking_CurveCoeff* curve_vehicle_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete curve_vehicle_coord_;
  }
  if (curve_vehicle_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(curve_vehicle_coord);
    if (message_arena != submessage_arena) {
      curve_vehicle_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curve_vehicle_coord, submessage_arena);
    }
    
  } else {
    
  }
  curve_vehicle_coord_ = curve_vehicle_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.RoadEdge.curve_vehicle_coord)
}

// .perception.hz.Roadmarking.CurveCoeff curve_image_coord = 4;
inline bool Roadmarking_RoadEdge::_internal_has_curve_image_coord() const {
  return this != internal_default_instance() && curve_image_coord_ != nullptr;
}
inline bool Roadmarking_RoadEdge::has_curve_image_coord() const {
  return _internal_has_curve_image_coord();
}
inline void Roadmarking_RoadEdge::clear_curve_image_coord() {
  if (GetArena() == nullptr && curve_image_coord_ != nullptr) {
    delete curve_image_coord_;
  }
  curve_image_coord_ = nullptr;
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking_RoadEdge::_internal_curve_image_coord() const {
  const ::perception::hz::Roadmarking_CurveCoeff* p = curve_image_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_CurveCoeff*>(
      &::perception::hz::_Roadmarking_CurveCoeff_default_instance_);
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking_RoadEdge::curve_image_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.curve_image_coord)
  return _internal_curve_image_coord();
}
inline void Roadmarking_RoadEdge::unsafe_arena_set_allocated_curve_image_coord(
    ::perception::hz::Roadmarking_CurveCoeff* curve_image_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(curve_image_coord_);
  }
  curve_image_coord_ = curve_image_coord;
  if (curve_image_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.RoadEdge.curve_image_coord)
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_RoadEdge::release_curve_image_coord() {
  auto temp = unsafe_arena_release_curve_image_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_RoadEdge::unsafe_arena_release_curve_image_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.RoadEdge.curve_image_coord)
  
  ::perception::hz::Roadmarking_CurveCoeff* temp = curve_image_coord_;
  curve_image_coord_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_RoadEdge::_internal_mutable_curve_image_coord() {
  
  if (curve_image_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_CurveCoeff>(GetArena());
    curve_image_coord_ = p;
  }
  return curve_image_coord_;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_RoadEdge::mutable_curve_image_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.RoadEdge.curve_image_coord)
  return _internal_mutable_curve_image_coord();
}
inline void Roadmarking_RoadEdge::set_allocated_curve_image_coord(::perception::hz::Roadmarking_CurveCoeff* curve_image_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete curve_image_coord_;
  }
  if (curve_image_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(curve_image_coord);
    if (message_arena != submessage_arena) {
      curve_image_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curve_image_coord, submessage_arena);
    }
    
  } else {
    
  }
  curve_image_coord_ = curve_image_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.RoadEdge.curve_image_coord)
}

// .perception.common.Point3fList points_vehicle_coord = 5;
inline bool Roadmarking_RoadEdge::_internal_has_points_vehicle_coord() const {
  return this != internal_default_instance() && points_vehicle_coord_ != nullptr;
}
inline bool Roadmarking_RoadEdge::has_points_vehicle_coord() const {
  return _internal_has_points_vehicle_coord();
}
inline const ::perception::common::Point3fList& Roadmarking_RoadEdge::_internal_points_vehicle_coord() const {
  const ::perception::common::Point3fList* p = points_vehicle_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point3fList*>(
      &::perception::common::_Point3fList_default_instance_);
}
inline const ::perception::common::Point3fList& Roadmarking_RoadEdge::points_vehicle_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.points_vehicle_coord)
  return _internal_points_vehicle_coord();
}
inline void Roadmarking_RoadEdge::unsafe_arena_set_allocated_points_vehicle_coord(
    ::perception::common::Point3fList* points_vehicle_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_vehicle_coord_);
  }
  points_vehicle_coord_ = points_vehicle_coord;
  if (points_vehicle_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.RoadEdge.points_vehicle_coord)
}
inline ::perception::common::Point3fList* Roadmarking_RoadEdge::release_points_vehicle_coord() {
  auto temp = unsafe_arena_release_points_vehicle_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point3fList* Roadmarking_RoadEdge::unsafe_arena_release_points_vehicle_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.RoadEdge.points_vehicle_coord)
  
  ::perception::common::Point3fList* temp = points_vehicle_coord_;
  points_vehicle_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point3fList* Roadmarking_RoadEdge::_internal_mutable_points_vehicle_coord() {
  
  if (points_vehicle_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point3fList>(GetArena());
    points_vehicle_coord_ = p;
  }
  return points_vehicle_coord_;
}
inline ::perception::common::Point3fList* Roadmarking_RoadEdge::mutable_points_vehicle_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.RoadEdge.points_vehicle_coord)
  return _internal_mutable_points_vehicle_coord();
}
inline void Roadmarking_RoadEdge::set_allocated_points_vehicle_coord(::perception::common::Point3fList* points_vehicle_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_vehicle_coord_);
  }
  if (points_vehicle_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_vehicle_coord)->GetArena();
    if (message_arena != submessage_arena) {
      points_vehicle_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points_vehicle_coord, submessage_arena);
    }
    
  } else {
    
  }
  points_vehicle_coord_ = points_vehicle_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.RoadEdge.points_vehicle_coord)
}

// .perception.common.Point2fList points_image_coord = 6;
inline bool Roadmarking_RoadEdge::_internal_has_points_image_coord() const {
  return this != internal_default_instance() && points_image_coord_ != nullptr;
}
inline bool Roadmarking_RoadEdge::has_points_image_coord() const {
  return _internal_has_points_image_coord();
}
inline const ::perception::common::Point2fList& Roadmarking_RoadEdge::_internal_points_image_coord() const {
  const ::perception::common::Point2fList* p = points_image_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2fList*>(
      &::perception::common::_Point2fList_default_instance_);
}
inline const ::perception::common::Point2fList& Roadmarking_RoadEdge::points_image_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.points_image_coord)
  return _internal_points_image_coord();
}
inline void Roadmarking_RoadEdge::unsafe_arena_set_allocated_points_image_coord(
    ::perception::common::Point2fList* points_image_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_image_coord_);
  }
  points_image_coord_ = points_image_coord;
  if (points_image_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.RoadEdge.points_image_coord)
}
inline ::perception::common::Point2fList* Roadmarking_RoadEdge::release_points_image_coord() {
  auto temp = unsafe_arena_release_points_image_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2fList* Roadmarking_RoadEdge::unsafe_arena_release_points_image_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.RoadEdge.points_image_coord)
  
  ::perception::common::Point2fList* temp = points_image_coord_;
  points_image_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point2fList* Roadmarking_RoadEdge::_internal_mutable_points_image_coord() {
  
  if (points_image_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2fList>(GetArena());
    points_image_coord_ = p;
  }
  return points_image_coord_;
}
inline ::perception::common::Point2fList* Roadmarking_RoadEdge::mutable_points_image_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.RoadEdge.points_image_coord)
  return _internal_mutable_points_image_coord();
}
inline void Roadmarking_RoadEdge::set_allocated_points_image_coord(::perception::common::Point2fList* points_image_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_image_coord_);
  }
  if (points_image_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_image_coord)->GetArena();
    if (message_arena != submessage_arena) {
      points_image_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points_image_coord, submessage_arena);
    }
    
  } else {
    
  }
  points_image_coord_ = points_image_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.RoadEdge.points_image_coord)
}

// .perception.common.Point2fList fit_points_image_coord = 7;
inline bool Roadmarking_RoadEdge::_internal_has_fit_points_image_coord() const {
  return this != internal_default_instance() && fit_points_image_coord_ != nullptr;
}
inline bool Roadmarking_RoadEdge::has_fit_points_image_coord() const {
  return _internal_has_fit_points_image_coord();
}
inline const ::perception::common::Point2fList& Roadmarking_RoadEdge::_internal_fit_points_image_coord() const {
  const ::perception::common::Point2fList* p = fit_points_image_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2fList*>(
      &::perception::common::_Point2fList_default_instance_);
}
inline const ::perception::common::Point2fList& Roadmarking_RoadEdge::fit_points_image_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.fit_points_image_coord)
  return _internal_fit_points_image_coord();
}
inline void Roadmarking_RoadEdge::unsafe_arena_set_allocated_fit_points_image_coord(
    ::perception::common::Point2fList* fit_points_image_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_image_coord_);
  }
  fit_points_image_coord_ = fit_points_image_coord;
  if (fit_points_image_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.RoadEdge.fit_points_image_coord)
}
inline ::perception::common::Point2fList* Roadmarking_RoadEdge::release_fit_points_image_coord() {
  auto temp = unsafe_arena_release_fit_points_image_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2fList* Roadmarking_RoadEdge::unsafe_arena_release_fit_points_image_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.RoadEdge.fit_points_image_coord)
  
  ::perception::common::Point2fList* temp = fit_points_image_coord_;
  fit_points_image_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point2fList* Roadmarking_RoadEdge::_internal_mutable_fit_points_image_coord() {
  
  if (fit_points_image_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2fList>(GetArena());
    fit_points_image_coord_ = p;
  }
  return fit_points_image_coord_;
}
inline ::perception::common::Point2fList* Roadmarking_RoadEdge::mutable_fit_points_image_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.RoadEdge.fit_points_image_coord)
  return _internal_mutable_fit_points_image_coord();
}
inline void Roadmarking_RoadEdge::set_allocated_fit_points_image_coord(::perception::common::Point2fList* fit_points_image_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_image_coord_);
  }
  if (fit_points_image_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_image_coord)->GetArena();
    if (message_arena != submessage_arena) {
      fit_points_image_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fit_points_image_coord, submessage_arena);
    }
    
  } else {
    
  }
  fit_points_image_coord_ = fit_points_image_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.RoadEdge.fit_points_image_coord)
}

// .perception.common.Point3fList fit_points_vehicle_coord = 8;
inline bool Roadmarking_RoadEdge::_internal_has_fit_points_vehicle_coord() const {
  return this != internal_default_instance() && fit_points_vehicle_coord_ != nullptr;
}
inline bool Roadmarking_RoadEdge::has_fit_points_vehicle_coord() const {
  return _internal_has_fit_points_vehicle_coord();
}
inline const ::perception::common::Point3fList& Roadmarking_RoadEdge::_internal_fit_points_vehicle_coord() const {
  const ::perception::common::Point3fList* p = fit_points_vehicle_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point3fList*>(
      &::perception::common::_Point3fList_default_instance_);
}
inline const ::perception::common::Point3fList& Roadmarking_RoadEdge::fit_points_vehicle_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.fit_points_vehicle_coord)
  return _internal_fit_points_vehicle_coord();
}
inline void Roadmarking_RoadEdge::unsafe_arena_set_allocated_fit_points_vehicle_coord(
    ::perception::common::Point3fList* fit_points_vehicle_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_vehicle_coord_);
  }
  fit_points_vehicle_coord_ = fit_points_vehicle_coord;
  if (fit_points_vehicle_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.RoadEdge.fit_points_vehicle_coord)
}
inline ::perception::common::Point3fList* Roadmarking_RoadEdge::release_fit_points_vehicle_coord() {
  auto temp = unsafe_arena_release_fit_points_vehicle_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point3fList* Roadmarking_RoadEdge::unsafe_arena_release_fit_points_vehicle_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.RoadEdge.fit_points_vehicle_coord)
  
  ::perception::common::Point3fList* temp = fit_points_vehicle_coord_;
  fit_points_vehicle_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point3fList* Roadmarking_RoadEdge::_internal_mutable_fit_points_vehicle_coord() {
  
  if (fit_points_vehicle_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point3fList>(GetArena());
    fit_points_vehicle_coord_ = p;
  }
  return fit_points_vehicle_coord_;
}
inline ::perception::common::Point3fList* Roadmarking_RoadEdge::mutable_fit_points_vehicle_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.RoadEdge.fit_points_vehicle_coord)
  return _internal_mutable_fit_points_vehicle_coord();
}
inline void Roadmarking_RoadEdge::set_allocated_fit_points_vehicle_coord(::perception::common::Point3fList* fit_points_vehicle_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_vehicle_coord_);
  }
  if (fit_points_vehicle_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fit_points_vehicle_coord)->GetArena();
    if (message_arena != submessage_arena) {
      fit_points_vehicle_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fit_points_vehicle_coord, submessage_arena);
    }
    
  } else {
    
  }
  fit_points_vehicle_coord_ = fit_points_vehicle_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.RoadEdge.fit_points_vehicle_coord)
}

// .perception.hz.Roadmarking.LineState state = 9;
inline void Roadmarking_RoadEdge::clear_state() {
  state_ = 0;
}
inline ::perception::hz::Roadmarking_LineState Roadmarking_RoadEdge::_internal_state() const {
  return static_cast< ::perception::hz::Roadmarking_LineState >(state_);
}
inline ::perception::hz::Roadmarking_LineState Roadmarking_RoadEdge::state() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.state)
  return _internal_state();
}
inline void Roadmarking_RoadEdge::_internal_set_state(::perception::hz::Roadmarking_LineState value) {
  
  state_ = value;
}
inline void Roadmarking_RoadEdge::set_state(::perception::hz::Roadmarking_LineState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.RoadEdge.state)
}

// int32 side = 10;
inline void Roadmarking_RoadEdge::clear_side() {
  side_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Roadmarking_RoadEdge::_internal_side() const {
  return side_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Roadmarking_RoadEdge::side() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.side)
  return _internal_side();
}
inline void Roadmarking_RoadEdge::_internal_set_side(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  side_ = value;
}
inline void Roadmarking_RoadEdge::set_side(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.RoadEdge.side)
}

// float confidence = 11;
inline void Roadmarking_RoadEdge::clear_confidence() {
  confidence_ = 0;
}
inline float Roadmarking_RoadEdge::_internal_confidence() const {
  return confidence_;
}
inline float Roadmarking_RoadEdge::confidence() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.confidence)
  return _internal_confidence();
}
inline void Roadmarking_RoadEdge::_internal_set_confidence(float value) {
  
  confidence_ = value;
}
inline void Roadmarking_RoadEdge::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.RoadEdge.confidence)
}

// repeated uint32 camera_id = 12;
inline int Roadmarking_RoadEdge::_internal_camera_id_size() const {
  return camera_id_.size();
}
inline int Roadmarking_RoadEdge::camera_id_size() const {
  return _internal_camera_id_size();
}
inline void Roadmarking_RoadEdge::clear_camera_id() {
  camera_id_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_RoadEdge::_internal_camera_id(int index) const {
  return camera_id_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_RoadEdge::camera_id(int index) const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdge.camera_id)
  return _internal_camera_id(index);
}
inline void Roadmarking_RoadEdge::set_camera_id(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  camera_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.RoadEdge.camera_id)
}
inline void Roadmarking_RoadEdge::_internal_add_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  camera_id_.Add(value);
}
inline void Roadmarking_RoadEdge::add_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_camera_id(value);
  // @@protoc_insertion_point(field_add:perception.hz.Roadmarking.RoadEdge.camera_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Roadmarking_RoadEdge::_internal_camera_id() const {
  return camera_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Roadmarking_RoadEdge::camera_id() const {
  // @@protoc_insertion_point(field_list:perception.hz.Roadmarking.RoadEdge.camera_id)
  return _internal_camera_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Roadmarking_RoadEdge::_internal_mutable_camera_id() {
  return &camera_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Roadmarking_RoadEdge::mutable_camera_id() {
  // @@protoc_insertion_point(field_mutable_list:perception.hz.Roadmarking.RoadEdge.camera_id)
  return _internal_mutable_camera_id();
}

// -------------------------------------------------------------------

// Roadmarking_RoadEdgeList

// repeated .perception.hz.Roadmarking.RoadEdge road_edges = 1;
inline int Roadmarking_RoadEdgeList::_internal_road_edges_size() const {
  return road_edges_.size();
}
inline int Roadmarking_RoadEdgeList::road_edges_size() const {
  return _internal_road_edges_size();
}
inline void Roadmarking_RoadEdgeList::clear_road_edges() {
  road_edges_.Clear();
}
inline ::perception::hz::Roadmarking_RoadEdge* Roadmarking_RoadEdgeList::mutable_road_edges(int index) {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.RoadEdgeList.road_edges)
  return road_edges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_RoadEdge >*
Roadmarking_RoadEdgeList::mutable_road_edges() {
  // @@protoc_insertion_point(field_mutable_list:perception.hz.Roadmarking.RoadEdgeList.road_edges)
  return &road_edges_;
}
inline const ::perception::hz::Roadmarking_RoadEdge& Roadmarking_RoadEdgeList::_internal_road_edges(int index) const {
  return road_edges_.Get(index);
}
inline const ::perception::hz::Roadmarking_RoadEdge& Roadmarking_RoadEdgeList::road_edges(int index) const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.RoadEdgeList.road_edges)
  return _internal_road_edges(index);
}
inline ::perception::hz::Roadmarking_RoadEdge* Roadmarking_RoadEdgeList::_internal_add_road_edges() {
  return road_edges_.Add();
}
inline ::perception::hz::Roadmarking_RoadEdge* Roadmarking_RoadEdgeList::add_road_edges() {
  // @@protoc_insertion_point(field_add:perception.hz.Roadmarking.RoadEdgeList.road_edges)
  return _internal_add_road_edges();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_RoadEdge >&
Roadmarking_RoadEdgeList::road_edges() const {
  // @@protoc_insertion_point(field_list:perception.hz.Roadmarking.RoadEdgeList.road_edges)
  return road_edges_;
}

// -------------------------------------------------------------------

// Roadmarking_Roadmarks_Roadmark

// uint32 id = 1;
inline void Roadmarking_Roadmarks_Roadmark::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_Roadmarks_Roadmark::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_Roadmarks_Roadmark::id() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.id)
  return _internal_id();
}
inline void Roadmarking_Roadmarks_Roadmark::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void Roadmarking_Roadmarks_Roadmark::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Roadmarks.Roadmark.id)
}

// .perception.hz.Roadmarking.Roadmarks.Type type = 2;
inline void Roadmarking_Roadmarks_Roadmark::clear_type() {
  type_ = 0;
}
inline ::perception::hz::Roadmarking_Roadmarks_Type Roadmarking_Roadmarks_Roadmark::_internal_type() const {
  return static_cast< ::perception::hz::Roadmarking_Roadmarks_Type >(type_);
}
inline ::perception::hz::Roadmarking_Roadmarks_Type Roadmarking_Roadmarks_Roadmark::type() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.type)
  return _internal_type();
}
inline void Roadmarking_Roadmarks_Roadmark::_internal_set_type(::perception::hz::Roadmarking_Roadmarks_Type value) {
  
  type_ = value;
}
inline void Roadmarking_Roadmarks_Roadmark::set_type(::perception::hz::Roadmarking_Roadmarks_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Roadmarks.Roadmark.type)
}

// .perception.common.Point2fList corner_pt_image_coord = 3;
inline bool Roadmarking_Roadmarks_Roadmark::_internal_has_corner_pt_image_coord() const {
  return this != internal_default_instance() && corner_pt_image_coord_ != nullptr;
}
inline bool Roadmarking_Roadmarks_Roadmark::has_corner_pt_image_coord() const {
  return _internal_has_corner_pt_image_coord();
}
inline const ::perception::common::Point2fList& Roadmarking_Roadmarks_Roadmark::_internal_corner_pt_image_coord() const {
  const ::perception::common::Point2fList* p = corner_pt_image_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2fList*>(
      &::perception::common::_Point2fList_default_instance_);
}
inline const ::perception::common::Point2fList& Roadmarking_Roadmarks_Roadmark::corner_pt_image_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.corner_pt_image_coord)
  return _internal_corner_pt_image_coord();
}
inline void Roadmarking_Roadmarks_Roadmark::unsafe_arena_set_allocated_corner_pt_image_coord(
    ::perception::common::Point2fList* corner_pt_image_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(corner_pt_image_coord_);
  }
  corner_pt_image_coord_ = corner_pt_image_coord;
  if (corner_pt_image_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Roadmarks.Roadmark.corner_pt_image_coord)
}
inline ::perception::common::Point2fList* Roadmarking_Roadmarks_Roadmark::release_corner_pt_image_coord() {
  auto temp = unsafe_arena_release_corner_pt_image_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2fList* Roadmarking_Roadmarks_Roadmark::unsafe_arena_release_corner_pt_image_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Roadmarks.Roadmark.corner_pt_image_coord)
  
  ::perception::common::Point2fList* temp = corner_pt_image_coord_;
  corner_pt_image_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point2fList* Roadmarking_Roadmarks_Roadmark::_internal_mutable_corner_pt_image_coord() {
  
  if (corner_pt_image_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2fList>(GetArena());
    corner_pt_image_coord_ = p;
  }
  return corner_pt_image_coord_;
}
inline ::perception::common::Point2fList* Roadmarking_Roadmarks_Roadmark::mutable_corner_pt_image_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Roadmarks.Roadmark.corner_pt_image_coord)
  return _internal_mutable_corner_pt_image_coord();
}
inline void Roadmarking_Roadmarks_Roadmark::set_allocated_corner_pt_image_coord(::perception::common::Point2fList* corner_pt_image_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(corner_pt_image_coord_);
  }
  if (corner_pt_image_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(corner_pt_image_coord)->GetArena();
    if (message_arena != submessage_arena) {
      corner_pt_image_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, corner_pt_image_coord, submessage_arena);
    }
    
  } else {
    
  }
  corner_pt_image_coord_ = corner_pt_image_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Roadmarks.Roadmark.corner_pt_image_coord)
}

// .perception.common.Point3fList corner_pt_vehicle_coord = 4;
inline bool Roadmarking_Roadmarks_Roadmark::_internal_has_corner_pt_vehicle_coord() const {
  return this != internal_default_instance() && corner_pt_vehicle_coord_ != nullptr;
}
inline bool Roadmarking_Roadmarks_Roadmark::has_corner_pt_vehicle_coord() const {
  return _internal_has_corner_pt_vehicle_coord();
}
inline const ::perception::common::Point3fList& Roadmarking_Roadmarks_Roadmark::_internal_corner_pt_vehicle_coord() const {
  const ::perception::common::Point3fList* p = corner_pt_vehicle_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point3fList*>(
      &::perception::common::_Point3fList_default_instance_);
}
inline const ::perception::common::Point3fList& Roadmarking_Roadmarks_Roadmark::corner_pt_vehicle_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.corner_pt_vehicle_coord)
  return _internal_corner_pt_vehicle_coord();
}
inline void Roadmarking_Roadmarks_Roadmark::unsafe_arena_set_allocated_corner_pt_vehicle_coord(
    ::perception::common::Point3fList* corner_pt_vehicle_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(corner_pt_vehicle_coord_);
  }
  corner_pt_vehicle_coord_ = corner_pt_vehicle_coord;
  if (corner_pt_vehicle_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Roadmarks.Roadmark.corner_pt_vehicle_coord)
}
inline ::perception::common::Point3fList* Roadmarking_Roadmarks_Roadmark::release_corner_pt_vehicle_coord() {
  auto temp = unsafe_arena_release_corner_pt_vehicle_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point3fList* Roadmarking_Roadmarks_Roadmark::unsafe_arena_release_corner_pt_vehicle_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Roadmarks.Roadmark.corner_pt_vehicle_coord)
  
  ::perception::common::Point3fList* temp = corner_pt_vehicle_coord_;
  corner_pt_vehicle_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point3fList* Roadmarking_Roadmarks_Roadmark::_internal_mutable_corner_pt_vehicle_coord() {
  
  if (corner_pt_vehicle_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point3fList>(GetArena());
    corner_pt_vehicle_coord_ = p;
  }
  return corner_pt_vehicle_coord_;
}
inline ::perception::common::Point3fList* Roadmarking_Roadmarks_Roadmark::mutable_corner_pt_vehicle_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Roadmarks.Roadmark.corner_pt_vehicle_coord)
  return _internal_mutable_corner_pt_vehicle_coord();
}
inline void Roadmarking_Roadmarks_Roadmark::set_allocated_corner_pt_vehicle_coord(::perception::common::Point3fList* corner_pt_vehicle_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(corner_pt_vehicle_coord_);
  }
  if (corner_pt_vehicle_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(corner_pt_vehicle_coord)->GetArena();
    if (message_arena != submessage_arena) {
      corner_pt_vehicle_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, corner_pt_vehicle_coord, submessage_arena);
    }
    
  } else {
    
  }
  corner_pt_vehicle_coord_ = corner_pt_vehicle_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Roadmarks.Roadmark.corner_pt_vehicle_coord)
}

// .perception.common.Point3f centroid_vehicle_coord = 5;
inline bool Roadmarking_Roadmarks_Roadmark::_internal_has_centroid_vehicle_coord() const {
  return this != internal_default_instance() && centroid_vehicle_coord_ != nullptr;
}
inline bool Roadmarking_Roadmarks_Roadmark::has_centroid_vehicle_coord() const {
  return _internal_has_centroid_vehicle_coord();
}
inline const ::perception::common::Point3f& Roadmarking_Roadmarks_Roadmark::_internal_centroid_vehicle_coord() const {
  const ::perception::common::Point3f* p = centroid_vehicle_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point3f*>(
      &::perception::common::_Point3f_default_instance_);
}
inline const ::perception::common::Point3f& Roadmarking_Roadmarks_Roadmark::centroid_vehicle_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.centroid_vehicle_coord)
  return _internal_centroid_vehicle_coord();
}
inline void Roadmarking_Roadmarks_Roadmark::unsafe_arena_set_allocated_centroid_vehicle_coord(
    ::perception::common::Point3f* centroid_vehicle_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(centroid_vehicle_coord_);
  }
  centroid_vehicle_coord_ = centroid_vehicle_coord;
  if (centroid_vehicle_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Roadmarks.Roadmark.centroid_vehicle_coord)
}
inline ::perception::common::Point3f* Roadmarking_Roadmarks_Roadmark::release_centroid_vehicle_coord() {
  auto temp = unsafe_arena_release_centroid_vehicle_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point3f* Roadmarking_Roadmarks_Roadmark::unsafe_arena_release_centroid_vehicle_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Roadmarks.Roadmark.centroid_vehicle_coord)
  
  ::perception::common::Point3f* temp = centroid_vehicle_coord_;
  centroid_vehicle_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point3f* Roadmarking_Roadmarks_Roadmark::_internal_mutable_centroid_vehicle_coord() {
  
  if (centroid_vehicle_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point3f>(GetArena());
    centroid_vehicle_coord_ = p;
  }
  return centroid_vehicle_coord_;
}
inline ::perception::common::Point3f* Roadmarking_Roadmarks_Roadmark::mutable_centroid_vehicle_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Roadmarks.Roadmark.centroid_vehicle_coord)
  return _internal_mutable_centroid_vehicle_coord();
}
inline void Roadmarking_Roadmarks_Roadmark::set_allocated_centroid_vehicle_coord(::perception::common::Point3f* centroid_vehicle_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(centroid_vehicle_coord_);
  }
  if (centroid_vehicle_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(centroid_vehicle_coord)->GetArena();
    if (message_arena != submessage_arena) {
      centroid_vehicle_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, centroid_vehicle_coord, submessage_arena);
    }
    
  } else {
    
  }
  centroid_vehicle_coord_ = centroid_vehicle_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Roadmarks.Roadmark.centroid_vehicle_coord)
}

// float confidence = 6;
inline void Roadmarking_Roadmarks_Roadmark::clear_confidence() {
  confidence_ = 0;
}
inline float Roadmarking_Roadmarks_Roadmark::_internal_confidence() const {
  return confidence_;
}
inline float Roadmarking_Roadmarks_Roadmark::confidence() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.confidence)
  return _internal_confidence();
}
inline void Roadmarking_Roadmarks_Roadmark::_internal_set_confidence(float value) {
  
  confidence_ = value;
}
inline void Roadmarking_Roadmarks_Roadmark::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Roadmarks.Roadmark.confidence)
}

// uint32 lane_idx = 7;
inline void Roadmarking_Roadmarks_Roadmark::clear_lane_idx() {
  lane_idx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_Roadmarks_Roadmark::_internal_lane_idx() const {
  return lane_idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_Roadmarks_Roadmark::lane_idx() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.lane_idx)
  return _internal_lane_idx();
}
inline void Roadmarking_Roadmarks_Roadmark::_internal_set_lane_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  lane_idx_ = value;
}
inline void Roadmarking_Roadmarks_Roadmark::set_lane_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lane_idx(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Roadmarks.Roadmark.lane_idx)
}

// .perception.hz.Roadmarking.Roadmarks.Form form = 8;
inline void Roadmarking_Roadmarks_Roadmark::clear_form() {
  form_ = 0;
}
inline ::perception::hz::Roadmarking_Roadmarks_Form Roadmarking_Roadmarks_Roadmark::_internal_form() const {
  return static_cast< ::perception::hz::Roadmarking_Roadmarks_Form >(form_);
}
inline ::perception::hz::Roadmarking_Roadmarks_Form Roadmarking_Roadmarks_Roadmark::form() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.form)
  return _internal_form();
}
inline void Roadmarking_Roadmarks_Roadmark::_internal_set_form(::perception::hz::Roadmarking_Roadmarks_Form value) {
  
  form_ = value;
}
inline void Roadmarking_Roadmarks_Roadmark::set_form(::perception::hz::Roadmarking_Roadmarks_Form value) {
  _internal_set_form(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Roadmarks.Roadmark.form)
}

// .perception.hz.Roadmarking.Roadmarks.State state = 9;
inline void Roadmarking_Roadmarks_Roadmark::clear_state() {
  state_ = 0;
}
inline ::perception::hz::Roadmarking_Roadmarks_State Roadmarking_Roadmarks_Roadmark::_internal_state() const {
  return static_cast< ::perception::hz::Roadmarking_Roadmarks_State >(state_);
}
inline ::perception::hz::Roadmarking_Roadmarks_State Roadmarking_Roadmarks_Roadmark::state() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.state)
  return _internal_state();
}
inline void Roadmarking_Roadmarks_Roadmark::_internal_set_state(::perception::hz::Roadmarking_Roadmarks_State value) {
  
  state_ = value;
}
inline void Roadmarking_Roadmarks_Roadmark::set_state(::perception::hz::Roadmarking_Roadmarks_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Roadmarks.Roadmark.state)
}

// .perception.common.Point2f centroid_image_coord = 10;
inline bool Roadmarking_Roadmarks_Roadmark::_internal_has_centroid_image_coord() const {
  return this != internal_default_instance() && centroid_image_coord_ != nullptr;
}
inline bool Roadmarking_Roadmarks_Roadmark::has_centroid_image_coord() const {
  return _internal_has_centroid_image_coord();
}
inline const ::perception::common::Point2f& Roadmarking_Roadmarks_Roadmark::_internal_centroid_image_coord() const {
  const ::perception::common::Point2f* p = centroid_image_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2f*>(
      &::perception::common::_Point2f_default_instance_);
}
inline const ::perception::common::Point2f& Roadmarking_Roadmarks_Roadmark::centroid_image_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.centroid_image_coord)
  return _internal_centroid_image_coord();
}
inline void Roadmarking_Roadmarks_Roadmark::unsafe_arena_set_allocated_centroid_image_coord(
    ::perception::common::Point2f* centroid_image_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(centroid_image_coord_);
  }
  centroid_image_coord_ = centroid_image_coord;
  if (centroid_image_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Roadmarks.Roadmark.centroid_image_coord)
}
inline ::perception::common::Point2f* Roadmarking_Roadmarks_Roadmark::release_centroid_image_coord() {
  auto temp = unsafe_arena_release_centroid_image_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_Roadmarks_Roadmark::unsafe_arena_release_centroid_image_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Roadmarks.Roadmark.centroid_image_coord)
  
  ::perception::common::Point2f* temp = centroid_image_coord_;
  centroid_image_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_Roadmarks_Roadmark::_internal_mutable_centroid_image_coord() {
  
  if (centroid_image_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2f>(GetArena());
    centroid_image_coord_ = p;
  }
  return centroid_image_coord_;
}
inline ::perception::common::Point2f* Roadmarking_Roadmarks_Roadmark::mutable_centroid_image_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Roadmarks.Roadmark.centroid_image_coord)
  return _internal_mutable_centroid_image_coord();
}
inline void Roadmarking_Roadmarks_Roadmark::set_allocated_centroid_image_coord(::perception::common::Point2f* centroid_image_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(centroid_image_coord_);
  }
  if (centroid_image_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(centroid_image_coord)->GetArena();
    if (message_arena != submessage_arena) {
      centroid_image_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, centroid_image_coord, submessage_arena);
    }
    
  } else {
    
  }
  centroid_image_coord_ = centroid_image_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Roadmarks.Roadmark.centroid_image_coord)
}

// float width = 11;
inline void Roadmarking_Roadmarks_Roadmark::clear_width() {
  width_ = 0;
}
inline float Roadmarking_Roadmarks_Roadmark::_internal_width() const {
  return width_;
}
inline float Roadmarking_Roadmarks_Roadmark::width() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.width)
  return _internal_width();
}
inline void Roadmarking_Roadmarks_Roadmark::_internal_set_width(float value) {
  
  width_ = value;
}
inline void Roadmarking_Roadmarks_Roadmark::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Roadmarks.Roadmark.width)
}

// uint32 camera_id = 12;
inline void Roadmarking_Roadmarks_Roadmark::clear_camera_id() {
  camera_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_Roadmarks_Roadmark::_internal_camera_id() const {
  return camera_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_Roadmarks_Roadmark::camera_id() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.Roadmark.camera_id)
  return _internal_camera_id();
}
inline void Roadmarking_Roadmarks_Roadmark::_internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  camera_id_ = value;
}
inline void Roadmarking_Roadmarks_Roadmark::set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_camera_id(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Roadmarks.Roadmark.camera_id)
}

// -------------------------------------------------------------------

// Roadmarking_Roadmarks

// repeated .perception.hz.Roadmarking.Roadmarks.Roadmark roadmarks = 1;
inline int Roadmarking_Roadmarks::_internal_roadmarks_size() const {
  return roadmarks_.size();
}
inline int Roadmarking_Roadmarks::roadmarks_size() const {
  return _internal_roadmarks_size();
}
inline void Roadmarking_Roadmarks::clear_roadmarks() {
  roadmarks_.Clear();
}
inline ::perception::hz::Roadmarking_Roadmarks_Roadmark* Roadmarking_Roadmarks::mutable_roadmarks(int index) {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Roadmarks.roadmarks)
  return roadmarks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Roadmarks_Roadmark >*
Roadmarking_Roadmarks::mutable_roadmarks() {
  // @@protoc_insertion_point(field_mutable_list:perception.hz.Roadmarking.Roadmarks.roadmarks)
  return &roadmarks_;
}
inline const ::perception::hz::Roadmarking_Roadmarks_Roadmark& Roadmarking_Roadmarks::_internal_roadmarks(int index) const {
  return roadmarks_.Get(index);
}
inline const ::perception::hz::Roadmarking_Roadmarks_Roadmark& Roadmarking_Roadmarks::roadmarks(int index) const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Roadmarks.roadmarks)
  return _internal_roadmarks(index);
}
inline ::perception::hz::Roadmarking_Roadmarks_Roadmark* Roadmarking_Roadmarks::_internal_add_roadmarks() {
  return roadmarks_.Add();
}
inline ::perception::hz::Roadmarking_Roadmarks_Roadmark* Roadmarking_Roadmarks::add_roadmarks() {
  // @@protoc_insertion_point(field_add:perception.hz.Roadmarking.Roadmarks.roadmarks)
  return _internal_add_roadmarks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Roadmarks_Roadmark >&
Roadmarking_Roadmarks::roadmarks() const {
  // @@protoc_insertion_point(field_list:perception.hz.Roadmarking.Roadmarks.roadmarks)
  return roadmarks_;
}

// -------------------------------------------------------------------

// Roadmarking_LDWInfo

// .perception.hz.Roadmarking.LDWInfo.LdwState ldw_state = 1;
inline void Roadmarking_LDWInfo::clear_ldw_state() {
  ldw_state_ = 0;
}
inline ::perception::hz::Roadmarking_LDWInfo_LdwState Roadmarking_LDWInfo::_internal_ldw_state() const {
  return static_cast< ::perception::hz::Roadmarking_LDWInfo_LdwState >(ldw_state_);
}
inline ::perception::hz::Roadmarking_LDWInfo_LdwState Roadmarking_LDWInfo::ldw_state() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LDWInfo.ldw_state)
  return _internal_ldw_state();
}
inline void Roadmarking_LDWInfo::_internal_set_ldw_state(::perception::hz::Roadmarking_LDWInfo_LdwState value) {
  
  ldw_state_ = value;
}
inline void Roadmarking_LDWInfo::set_ldw_state(::perception::hz::Roadmarking_LDWInfo_LdwState value) {
  _internal_set_ldw_state(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.LDWInfo.ldw_state)
}

// float left_wheel_dist = 2;
inline void Roadmarking_LDWInfo::clear_left_wheel_dist() {
  left_wheel_dist_ = 0;
}
inline float Roadmarking_LDWInfo::_internal_left_wheel_dist() const {
  return left_wheel_dist_;
}
inline float Roadmarking_LDWInfo::left_wheel_dist() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LDWInfo.left_wheel_dist)
  return _internal_left_wheel_dist();
}
inline void Roadmarking_LDWInfo::_internal_set_left_wheel_dist(float value) {
  
  left_wheel_dist_ = value;
}
inline void Roadmarking_LDWInfo::set_left_wheel_dist(float value) {
  _internal_set_left_wheel_dist(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.LDWInfo.left_wheel_dist)
}

// float right_wheel_dist = 3;
inline void Roadmarking_LDWInfo::clear_right_wheel_dist() {
  right_wheel_dist_ = 0;
}
inline float Roadmarking_LDWInfo::_internal_right_wheel_dist() const {
  return right_wheel_dist_;
}
inline float Roadmarking_LDWInfo::right_wheel_dist() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LDWInfo.right_wheel_dist)
  return _internal_right_wheel_dist();
}
inline void Roadmarking_LDWInfo::_internal_set_right_wheel_dist(float value) {
  
  right_wheel_dist_ = value;
}
inline void Roadmarking_LDWInfo::set_right_wheel_dist(float value) {
  _internal_set_right_wheel_dist(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.LDWInfo.right_wheel_dist)
}

// float warning_dist = 4;
inline void Roadmarking_LDWInfo::clear_warning_dist() {
  warning_dist_ = 0;
}
inline float Roadmarking_LDWInfo::_internal_warning_dist() const {
  return warning_dist_;
}
inline float Roadmarking_LDWInfo::warning_dist() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LDWInfo.warning_dist)
  return _internal_warning_dist();
}
inline void Roadmarking_LDWInfo::_internal_set_warning_dist(float value) {
  
  warning_dist_ = value;
}
inline void Roadmarking_LDWInfo::set_warning_dist(float value) {
  _internal_set_warning_dist(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.LDWInfo.warning_dist)
}

// float earliest_dist = 5;
inline void Roadmarking_LDWInfo::clear_earliest_dist() {
  earliest_dist_ = 0;
}
inline float Roadmarking_LDWInfo::_internal_earliest_dist() const {
  return earliest_dist_;
}
inline float Roadmarking_LDWInfo::earliest_dist() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LDWInfo.earliest_dist)
  return _internal_earliest_dist();
}
inline void Roadmarking_LDWInfo::_internal_set_earliest_dist(float value) {
  
  earliest_dist_ = value;
}
inline void Roadmarking_LDWInfo::set_earliest_dist(float value) {
  _internal_set_earliest_dist(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.LDWInfo.earliest_dist)
}

// float latest_dist = 6;
inline void Roadmarking_LDWInfo::clear_latest_dist() {
  latest_dist_ = 0;
}
inline float Roadmarking_LDWInfo::_internal_latest_dist() const {
  return latest_dist_;
}
inline float Roadmarking_LDWInfo::latest_dist() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LDWInfo.latest_dist)
  return _internal_latest_dist();
}
inline void Roadmarking_LDWInfo::_internal_set_latest_dist(float value) {
  
  latest_dist_ = value;
}
inline void Roadmarking_LDWInfo::set_latest_dist(float value) {
  _internal_set_latest_dist(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.LDWInfo.latest_dist)
}

// bool ldw_state_changed = 7;
inline void Roadmarking_LDWInfo::clear_ldw_state_changed() {
  ldw_state_changed_ = false;
}
inline bool Roadmarking_LDWInfo::_internal_ldw_state_changed() const {
  return ldw_state_changed_;
}
inline bool Roadmarking_LDWInfo::ldw_state_changed() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LDWInfo.ldw_state_changed)
  return _internal_ldw_state_changed();
}
inline void Roadmarking_LDWInfo::_internal_set_ldw_state_changed(bool value) {
  
  ldw_state_changed_ = value;
}
inline void Roadmarking_LDWInfo::set_ldw_state_changed(bool value) {
  _internal_set_ldw_state_changed(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.LDWInfo.ldw_state_changed)
}

// .perception.hz.Roadmarking.LDWInfo.LdwWorkState ldw_work_state = 8;
inline void Roadmarking_LDWInfo::clear_ldw_work_state() {
  ldw_work_state_ = 0;
}
inline ::perception::hz::Roadmarking_LDWInfo_LdwWorkState Roadmarking_LDWInfo::_internal_ldw_work_state() const {
  return static_cast< ::perception::hz::Roadmarking_LDWInfo_LdwWorkState >(ldw_work_state_);
}
inline ::perception::hz::Roadmarking_LDWInfo_LdwWorkState Roadmarking_LDWInfo::ldw_work_state() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LDWInfo.ldw_work_state)
  return _internal_ldw_work_state();
}
inline void Roadmarking_LDWInfo::_internal_set_ldw_work_state(::perception::hz::Roadmarking_LDWInfo_LdwWorkState value) {
  
  ldw_work_state_ = value;
}
inline void Roadmarking_LDWInfo::set_ldw_work_state(::perception::hz::Roadmarking_LDWInfo_LdwWorkState value) {
  _internal_set_ldw_work_state(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.LDWInfo.ldw_work_state)
}

// float turn_radius = 9;
inline void Roadmarking_LDWInfo::clear_turn_radius() {
  turn_radius_ = 0;
}
inline float Roadmarking_LDWInfo::_internal_turn_radius() const {
  return turn_radius_;
}
inline float Roadmarking_LDWInfo::turn_radius() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LDWInfo.turn_radius)
  return _internal_turn_radius();
}
inline void Roadmarking_LDWInfo::_internal_set_turn_radius(float value) {
  
  turn_radius_ = value;
}
inline void Roadmarking_LDWInfo::set_turn_radius(float value) {
  _internal_set_turn_radius(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.LDWInfo.turn_radius)
}

// uint64 nearest_line_id = 10;
inline void Roadmarking_LDWInfo::clear_nearest_line_id() {
  nearest_line_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking_LDWInfo::_internal_nearest_line_id() const {
  return nearest_line_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking_LDWInfo::nearest_line_id() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LDWInfo.nearest_line_id)
  return _internal_nearest_line_id();
}
inline void Roadmarking_LDWInfo::_internal_set_nearest_line_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  nearest_line_id_ = value;
}
inline void Roadmarking_LDWInfo::set_nearest_line_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nearest_line_id(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.LDWInfo.nearest_line_id)
}

// uint32 ldw_level = 11;
inline void Roadmarking_LDWInfo::clear_ldw_level() {
  ldw_level_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_LDWInfo::_internal_ldw_level() const {
  return ldw_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_LDWInfo::ldw_level() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.LDWInfo.ldw_level)
  return _internal_ldw_level();
}
inline void Roadmarking_LDWInfo::_internal_set_ldw_level(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ldw_level_ = value;
}
inline void Roadmarking_LDWInfo::set_ldw_level(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ldw_level(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.LDWInfo.ldw_level)
}

// -------------------------------------------------------------------

// Roadmarking_MotionEst

// float lateral_speed = 1;
inline void Roadmarking_MotionEst::clear_lateral_speed() {
  lateral_speed_ = 0;
}
inline float Roadmarking_MotionEst::_internal_lateral_speed() const {
  return lateral_speed_;
}
inline float Roadmarking_MotionEst::lateral_speed() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.MotionEst.lateral_speed)
  return _internal_lateral_speed();
}
inline void Roadmarking_MotionEst::_internal_set_lateral_speed(float value) {
  
  lateral_speed_ = value;
}
inline void Roadmarking_MotionEst::set_lateral_speed(float value) {
  _internal_set_lateral_speed(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.MotionEst.lateral_speed)
}

// float lateral_acc = 2;
inline void Roadmarking_MotionEst::clear_lateral_acc() {
  lateral_acc_ = 0;
}
inline float Roadmarking_MotionEst::_internal_lateral_acc() const {
  return lateral_acc_;
}
inline float Roadmarking_MotionEst::lateral_acc() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.MotionEst.lateral_acc)
  return _internal_lateral_acc();
}
inline void Roadmarking_MotionEst::_internal_set_lateral_acc(float value) {
  
  lateral_acc_ = value;
}
inline void Roadmarking_MotionEst::set_lateral_acc(float value) {
  _internal_set_lateral_acc(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.MotionEst.lateral_acc)
}

// float confidence = 3;
inline void Roadmarking_MotionEst::clear_confidence() {
  confidence_ = 0;
}
inline float Roadmarking_MotionEst::_internal_confidence() const {
  return confidence_;
}
inline float Roadmarking_MotionEst::confidence() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.MotionEst.confidence)
  return _internal_confidence();
}
inline void Roadmarking_MotionEst::_internal_set_confidence(float value) {
  
  confidence_ = value;
}
inline void Roadmarking_MotionEst::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.MotionEst.confidence)
}

// -------------------------------------------------------------------

// Roadmarking_PoseEst

// float pitch_est = 1;
inline void Roadmarking_PoseEst::clear_pitch_est() {
  pitch_est_ = 0;
}
inline float Roadmarking_PoseEst::_internal_pitch_est() const {
  return pitch_est_;
}
inline float Roadmarking_PoseEst::pitch_est() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.PoseEst.pitch_est)
  return _internal_pitch_est();
}
inline void Roadmarking_PoseEst::_internal_set_pitch_est(float value) {
  
  pitch_est_ = value;
}
inline void Roadmarking_PoseEst::set_pitch_est(float value) {
  _internal_set_pitch_est(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.PoseEst.pitch_est)
}

// .perception.common.Point2f vanish_pt = 2;
inline bool Roadmarking_PoseEst::_internal_has_vanish_pt() const {
  return this != internal_default_instance() && vanish_pt_ != nullptr;
}
inline bool Roadmarking_PoseEst::has_vanish_pt() const {
  return _internal_has_vanish_pt();
}
inline const ::perception::common::Point2f& Roadmarking_PoseEst::_internal_vanish_pt() const {
  const ::perception::common::Point2f* p = vanish_pt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2f*>(
      &::perception::common::_Point2f_default_instance_);
}
inline const ::perception::common::Point2f& Roadmarking_PoseEst::vanish_pt() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.PoseEst.vanish_pt)
  return _internal_vanish_pt();
}
inline void Roadmarking_PoseEst::unsafe_arena_set_allocated_vanish_pt(
    ::perception::common::Point2f* vanish_pt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vanish_pt_);
  }
  vanish_pt_ = vanish_pt;
  if (vanish_pt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.PoseEst.vanish_pt)
}
inline ::perception::common::Point2f* Roadmarking_PoseEst::release_vanish_pt() {
  auto temp = unsafe_arena_release_vanish_pt();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_PoseEst::unsafe_arena_release_vanish_pt() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.PoseEst.vanish_pt)
  
  ::perception::common::Point2f* temp = vanish_pt_;
  vanish_pt_ = nullptr;
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_PoseEst::_internal_mutable_vanish_pt() {
  
  if (vanish_pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2f>(GetArena());
    vanish_pt_ = p;
  }
  return vanish_pt_;
}
inline ::perception::common::Point2f* Roadmarking_PoseEst::mutable_vanish_pt() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.PoseEst.vanish_pt)
  return _internal_mutable_vanish_pt();
}
inline void Roadmarking_PoseEst::set_allocated_vanish_pt(::perception::common::Point2f* vanish_pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vanish_pt_);
  }
  if (vanish_pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vanish_pt)->GetArena();
    if (message_arena != submessage_arena) {
      vanish_pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vanish_pt, submessage_arena);
    }
    
  } else {
    
  }
  vanish_pt_ = vanish_pt;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.PoseEst.vanish_pt)
}

// .perception.common.Point2f vanish_cov = 3;
inline bool Roadmarking_PoseEst::_internal_has_vanish_cov() const {
  return this != internal_default_instance() && vanish_cov_ != nullptr;
}
inline bool Roadmarking_PoseEst::has_vanish_cov() const {
  return _internal_has_vanish_cov();
}
inline const ::perception::common::Point2f& Roadmarking_PoseEst::_internal_vanish_cov() const {
  const ::perception::common::Point2f* p = vanish_cov_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2f*>(
      &::perception::common::_Point2f_default_instance_);
}
inline const ::perception::common::Point2f& Roadmarking_PoseEst::vanish_cov() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.PoseEst.vanish_cov)
  return _internal_vanish_cov();
}
inline void Roadmarking_PoseEst::unsafe_arena_set_allocated_vanish_cov(
    ::perception::common::Point2f* vanish_cov) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vanish_cov_);
  }
  vanish_cov_ = vanish_cov;
  if (vanish_cov) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.PoseEst.vanish_cov)
}
inline ::perception::common::Point2f* Roadmarking_PoseEst::release_vanish_cov() {
  auto temp = unsafe_arena_release_vanish_cov();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_PoseEst::unsafe_arena_release_vanish_cov() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.PoseEst.vanish_cov)
  
  ::perception::common::Point2f* temp = vanish_cov_;
  vanish_cov_ = nullptr;
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_PoseEst::_internal_mutable_vanish_cov() {
  
  if (vanish_cov_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2f>(GetArena());
    vanish_cov_ = p;
  }
  return vanish_cov_;
}
inline ::perception::common::Point2f* Roadmarking_PoseEst::mutable_vanish_cov() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.PoseEst.vanish_cov)
  return _internal_mutable_vanish_cov();
}
inline void Roadmarking_PoseEst::set_allocated_vanish_cov(::perception::common::Point2f* vanish_cov) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vanish_cov_);
  }
  if (vanish_cov) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vanish_cov)->GetArena();
    if (message_arena != submessage_arena) {
      vanish_cov = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vanish_cov, submessage_arena);
    }
    
  } else {
    
  }
  vanish_cov_ = vanish_cov;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.PoseEst.vanish_cov)
}

// bool is_valid = 4;
inline void Roadmarking_PoseEst::clear_is_valid() {
  is_valid_ = false;
}
inline bool Roadmarking_PoseEst::_internal_is_valid() const {
  return is_valid_;
}
inline bool Roadmarking_PoseEst::is_valid() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.PoseEst.is_valid)
  return _internal_is_valid();
}
inline void Roadmarking_PoseEst::_internal_set_is_valid(bool value) {
  
  is_valid_ = value;
}
inline void Roadmarking_PoseEst::set_is_valid(bool value) {
  _internal_set_is_valid(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.PoseEst.is_valid)
}

// uint32 camera_id = 5;
inline void Roadmarking_PoseEst::clear_camera_id() {
  camera_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_PoseEst::_internal_camera_id() const {
  return camera_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_PoseEst::camera_id() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.PoseEst.camera_id)
  return _internal_camera_id();
}
inline void Roadmarking_PoseEst::_internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  camera_id_ = value;
}
inline void Roadmarking_PoseEst::set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_camera_id(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.PoseEst.camera_id)
}

// float dpitch = 6;
inline void Roadmarking_PoseEst::clear_dpitch() {
  dpitch_ = 0;
}
inline float Roadmarking_PoseEst::_internal_dpitch() const {
  return dpitch_;
}
inline float Roadmarking_PoseEst::dpitch() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.PoseEst.dpitch)
  return _internal_dpitch();
}
inline void Roadmarking_PoseEst::_internal_set_dpitch(float value) {
  
  dpitch_ = value;
}
inline void Roadmarking_PoseEst::set_dpitch(float value) {
  _internal_set_dpitch(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.PoseEst.dpitch)
}

// float confidence = 7;
inline void Roadmarking_PoseEst::clear_confidence() {
  confidence_ = 0;
}
inline float Roadmarking_PoseEst::_internal_confidence() const {
  return confidence_;
}
inline float Roadmarking_PoseEst::confidence() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.PoseEst.confidence)
  return _internal_confidence();
}
inline void Roadmarking_PoseEst::_internal_set_confidence(float value) {
  
  confidence_ = value;
}
inline void Roadmarking_PoseEst::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.PoseEst.confidence)
}

// -------------------------------------------------------------------

// Roadmarking_HppInfo

// .perception.hz.Roadmarking.CurveCoeff path_prediction_coeff = 1;
inline bool Roadmarking_HppInfo::_internal_has_path_prediction_coeff() const {
  return this != internal_default_instance() && path_prediction_coeff_ != nullptr;
}
inline bool Roadmarking_HppInfo::has_path_prediction_coeff() const {
  return _internal_has_path_prediction_coeff();
}
inline void Roadmarking_HppInfo::clear_path_prediction_coeff() {
  if (GetArena() == nullptr && path_prediction_coeff_ != nullptr) {
    delete path_prediction_coeff_;
  }
  path_prediction_coeff_ = nullptr;
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking_HppInfo::_internal_path_prediction_coeff() const {
  const ::perception::hz::Roadmarking_CurveCoeff* p = path_prediction_coeff_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_CurveCoeff*>(
      &::perception::hz::_Roadmarking_CurveCoeff_default_instance_);
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking_HppInfo::path_prediction_coeff() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.path_prediction_coeff)
  return _internal_path_prediction_coeff();
}
inline void Roadmarking_HppInfo::unsafe_arena_set_allocated_path_prediction_coeff(
    ::perception::hz::Roadmarking_CurveCoeff* path_prediction_coeff) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_prediction_coeff_);
  }
  path_prediction_coeff_ = path_prediction_coeff;
  if (path_prediction_coeff) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.HppInfo.path_prediction_coeff)
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_HppInfo::release_path_prediction_coeff() {
  auto temp = unsafe_arena_release_path_prediction_coeff();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_HppInfo::unsafe_arena_release_path_prediction_coeff() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.HppInfo.path_prediction_coeff)
  
  ::perception::hz::Roadmarking_CurveCoeff* temp = path_prediction_coeff_;
  path_prediction_coeff_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_HppInfo::_internal_mutable_path_prediction_coeff() {
  
  if (path_prediction_coeff_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_CurveCoeff>(GetArena());
    path_prediction_coeff_ = p;
  }
  return path_prediction_coeff_;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking_HppInfo::mutable_path_prediction_coeff() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.HppInfo.path_prediction_coeff)
  return _internal_mutable_path_prediction_coeff();
}
inline void Roadmarking_HppInfo::set_allocated_path_prediction_coeff(::perception::hz::Roadmarking_CurveCoeff* path_prediction_coeff) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete path_prediction_coeff_;
  }
  if (path_prediction_coeff) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(path_prediction_coeff);
    if (message_arena != submessage_arena) {
      path_prediction_coeff = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path_prediction_coeff, submessage_arena);
    }
    
  } else {
    
  }
  path_prediction_coeff_ = path_prediction_coeff;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.HppInfo.path_prediction_coeff)
}

// bool is_laneline_valid = 3;
inline void Roadmarking_HppInfo::clear_is_laneline_valid() {
  is_laneline_valid_ = false;
}
inline bool Roadmarking_HppInfo::_internal_is_laneline_valid() const {
  return is_laneline_valid_;
}
inline bool Roadmarking_HppInfo::is_laneline_valid() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.is_laneline_valid)
  return _internal_is_laneline_valid();
}
inline void Roadmarking_HppInfo::_internal_set_is_laneline_valid(bool value) {
  
  is_laneline_valid_ = value;
}
inline void Roadmarking_HppInfo::set_is_laneline_valid(bool value) {
  _internal_set_is_laneline_valid(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.HppInfo.is_laneline_valid)
}

// bool is_valid = 4;
inline void Roadmarking_HppInfo::clear_is_valid() {
  is_valid_ = false;
}
inline bool Roadmarking_HppInfo::_internal_is_valid() const {
  return is_valid_;
}
inline bool Roadmarking_HppInfo::is_valid() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.is_valid)
  return _internal_is_valid();
}
inline void Roadmarking_HppInfo::_internal_set_is_valid(bool value) {
  
  is_valid_ = value;
}
inline void Roadmarking_HppInfo::set_is_valid(bool value) {
  _internal_set_is_valid(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.HppInfo.is_valid)
}

// uint32 planning_source = 5;
inline void Roadmarking_HppInfo::clear_planning_source() {
  planning_source_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_HppInfo::_internal_planning_source() const {
  return planning_source_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Roadmarking_HppInfo::planning_source() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.planning_source)
  return _internal_planning_source();
}
inline void Roadmarking_HppInfo::_internal_set_planning_source(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  planning_source_ = value;
}
inline void Roadmarking_HppInfo::set_planning_source(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_planning_source(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.HppInfo.planning_source)
}

// float confidence = 6;
inline void Roadmarking_HppInfo::clear_confidence() {
  confidence_ = 0;
}
inline float Roadmarking_HppInfo::_internal_confidence() const {
  return confidence_;
}
inline float Roadmarking_HppInfo::confidence() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.confidence)
  return _internal_confidence();
}
inline void Roadmarking_HppInfo::_internal_set_confidence(float value) {
  
  confidence_ = value;
}
inline void Roadmarking_HppInfo::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.HppInfo.confidence)
}

// float ego_lane_width = 7;
inline void Roadmarking_HppInfo::clear_ego_lane_width() {
  ego_lane_width_ = 0;
}
inline float Roadmarking_HppInfo::_internal_ego_lane_width() const {
  return ego_lane_width_;
}
inline float Roadmarking_HppInfo::ego_lane_width() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.ego_lane_width)
  return _internal_ego_lane_width();
}
inline void Roadmarking_HppInfo::_internal_set_ego_lane_width(float value) {
  
  ego_lane_width_ = value;
}
inline void Roadmarking_HppInfo::set_ego_lane_width(float value) {
  _internal_set_ego_lane_width(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.HppInfo.ego_lane_width)
}

// .perception.hz.Roadmarking.Laneline hpp_line = 8;
inline bool Roadmarking_HppInfo::_internal_has_hpp_line() const {
  return this != internal_default_instance() && hpp_line_ != nullptr;
}
inline bool Roadmarking_HppInfo::has_hpp_line() const {
  return _internal_has_hpp_line();
}
inline void Roadmarking_HppInfo::clear_hpp_line() {
  if (GetArena() == nullptr && hpp_line_ != nullptr) {
    delete hpp_line_;
  }
  hpp_line_ = nullptr;
}
inline const ::perception::hz::Roadmarking_Laneline& Roadmarking_HppInfo::_internal_hpp_line() const {
  const ::perception::hz::Roadmarking_Laneline* p = hpp_line_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_Laneline*>(
      &::perception::hz::_Roadmarking_Laneline_default_instance_);
}
inline const ::perception::hz::Roadmarking_Laneline& Roadmarking_HppInfo::hpp_line() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.hpp_line)
  return _internal_hpp_line();
}
inline void Roadmarking_HppInfo::unsafe_arena_set_allocated_hpp_line(
    ::perception::hz::Roadmarking_Laneline* hpp_line) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hpp_line_);
  }
  hpp_line_ = hpp_line;
  if (hpp_line) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.HppInfo.hpp_line)
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::release_hpp_line() {
  auto temp = unsafe_arena_release_hpp_line();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::unsafe_arena_release_hpp_line() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.HppInfo.hpp_line)
  
  ::perception::hz::Roadmarking_Laneline* temp = hpp_line_;
  hpp_line_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::_internal_mutable_hpp_line() {
  
  if (hpp_line_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_Laneline>(GetArena());
    hpp_line_ = p;
  }
  return hpp_line_;
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::mutable_hpp_line() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.HppInfo.hpp_line)
  return _internal_mutable_hpp_line();
}
inline void Roadmarking_HppInfo::set_allocated_hpp_line(::perception::hz::Roadmarking_Laneline* hpp_line) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hpp_line_;
  }
  if (hpp_line) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hpp_line);
    if (message_arena != submessage_arena) {
      hpp_line = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hpp_line, submessage_arena);
    }
    
  } else {
    
  }
  hpp_line_ = hpp_line;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.HppInfo.hpp_line)
}

// .perception.hz.Roadmarking.Laneline virtual_ego_lane_left = 9;
inline bool Roadmarking_HppInfo::_internal_has_virtual_ego_lane_left() const {
  return this != internal_default_instance() && virtual_ego_lane_left_ != nullptr;
}
inline bool Roadmarking_HppInfo::has_virtual_ego_lane_left() const {
  return _internal_has_virtual_ego_lane_left();
}
inline void Roadmarking_HppInfo::clear_virtual_ego_lane_left() {
  if (GetArena() == nullptr && virtual_ego_lane_left_ != nullptr) {
    delete virtual_ego_lane_left_;
  }
  virtual_ego_lane_left_ = nullptr;
}
inline const ::perception::hz::Roadmarking_Laneline& Roadmarking_HppInfo::_internal_virtual_ego_lane_left() const {
  const ::perception::hz::Roadmarking_Laneline* p = virtual_ego_lane_left_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_Laneline*>(
      &::perception::hz::_Roadmarking_Laneline_default_instance_);
}
inline const ::perception::hz::Roadmarking_Laneline& Roadmarking_HppInfo::virtual_ego_lane_left() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.virtual_ego_lane_left)
  return _internal_virtual_ego_lane_left();
}
inline void Roadmarking_HppInfo::unsafe_arena_set_allocated_virtual_ego_lane_left(
    ::perception::hz::Roadmarking_Laneline* virtual_ego_lane_left) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtual_ego_lane_left_);
  }
  virtual_ego_lane_left_ = virtual_ego_lane_left;
  if (virtual_ego_lane_left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.HppInfo.virtual_ego_lane_left)
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::release_virtual_ego_lane_left() {
  auto temp = unsafe_arena_release_virtual_ego_lane_left();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::unsafe_arena_release_virtual_ego_lane_left() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.HppInfo.virtual_ego_lane_left)
  
  ::perception::hz::Roadmarking_Laneline* temp = virtual_ego_lane_left_;
  virtual_ego_lane_left_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::_internal_mutable_virtual_ego_lane_left() {
  
  if (virtual_ego_lane_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_Laneline>(GetArena());
    virtual_ego_lane_left_ = p;
  }
  return virtual_ego_lane_left_;
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::mutable_virtual_ego_lane_left() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.HppInfo.virtual_ego_lane_left)
  return _internal_mutable_virtual_ego_lane_left();
}
inline void Roadmarking_HppInfo::set_allocated_virtual_ego_lane_left(::perception::hz::Roadmarking_Laneline* virtual_ego_lane_left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete virtual_ego_lane_left_;
  }
  if (virtual_ego_lane_left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(virtual_ego_lane_left);
    if (message_arena != submessage_arena) {
      virtual_ego_lane_left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtual_ego_lane_left, submessage_arena);
    }
    
  } else {
    
  }
  virtual_ego_lane_left_ = virtual_ego_lane_left;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.HppInfo.virtual_ego_lane_left)
}

// .perception.hz.Roadmarking.Laneline virtual_ego_lane_right = 10;
inline bool Roadmarking_HppInfo::_internal_has_virtual_ego_lane_right() const {
  return this != internal_default_instance() && virtual_ego_lane_right_ != nullptr;
}
inline bool Roadmarking_HppInfo::has_virtual_ego_lane_right() const {
  return _internal_has_virtual_ego_lane_right();
}
inline void Roadmarking_HppInfo::clear_virtual_ego_lane_right() {
  if (GetArena() == nullptr && virtual_ego_lane_right_ != nullptr) {
    delete virtual_ego_lane_right_;
  }
  virtual_ego_lane_right_ = nullptr;
}
inline const ::perception::hz::Roadmarking_Laneline& Roadmarking_HppInfo::_internal_virtual_ego_lane_right() const {
  const ::perception::hz::Roadmarking_Laneline* p = virtual_ego_lane_right_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_Laneline*>(
      &::perception::hz::_Roadmarking_Laneline_default_instance_);
}
inline const ::perception::hz::Roadmarking_Laneline& Roadmarking_HppInfo::virtual_ego_lane_right() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.virtual_ego_lane_right)
  return _internal_virtual_ego_lane_right();
}
inline void Roadmarking_HppInfo::unsafe_arena_set_allocated_virtual_ego_lane_right(
    ::perception::hz::Roadmarking_Laneline* virtual_ego_lane_right) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtual_ego_lane_right_);
  }
  virtual_ego_lane_right_ = virtual_ego_lane_right;
  if (virtual_ego_lane_right) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.HppInfo.virtual_ego_lane_right)
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::release_virtual_ego_lane_right() {
  auto temp = unsafe_arena_release_virtual_ego_lane_right();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::unsafe_arena_release_virtual_ego_lane_right() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.HppInfo.virtual_ego_lane_right)
  
  ::perception::hz::Roadmarking_Laneline* temp = virtual_ego_lane_right_;
  virtual_ego_lane_right_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::_internal_mutable_virtual_ego_lane_right() {
  
  if (virtual_ego_lane_right_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_Laneline>(GetArena());
    virtual_ego_lane_right_ = p;
  }
  return virtual_ego_lane_right_;
}
inline ::perception::hz::Roadmarking_Laneline* Roadmarking_HppInfo::mutable_virtual_ego_lane_right() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.HppInfo.virtual_ego_lane_right)
  return _internal_mutable_virtual_ego_lane_right();
}
inline void Roadmarking_HppInfo::set_allocated_virtual_ego_lane_right(::perception::hz::Roadmarking_Laneline* virtual_ego_lane_right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete virtual_ego_lane_right_;
  }
  if (virtual_ego_lane_right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(virtual_ego_lane_right);
    if (message_arena != submessage_arena) {
      virtual_ego_lane_right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtual_ego_lane_right, submessage_arena);
    }
    
  } else {
    
  }
  virtual_ego_lane_right_ = virtual_ego_lane_right;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.HppInfo.virtual_ego_lane_right)
}

// .perception.common.Point2f preview_pt = 11;
inline bool Roadmarking_HppInfo::_internal_has_preview_pt() const {
  return this != internal_default_instance() && preview_pt_ != nullptr;
}
inline bool Roadmarking_HppInfo::has_preview_pt() const {
  return _internal_has_preview_pt();
}
inline const ::perception::common::Point2f& Roadmarking_HppInfo::_internal_preview_pt() const {
  const ::perception::common::Point2f* p = preview_pt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2f*>(
      &::perception::common::_Point2f_default_instance_);
}
inline const ::perception::common::Point2f& Roadmarking_HppInfo::preview_pt() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.preview_pt)
  return _internal_preview_pt();
}
inline void Roadmarking_HppInfo::unsafe_arena_set_allocated_preview_pt(
    ::perception::common::Point2f* preview_pt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(preview_pt_);
  }
  preview_pt_ = preview_pt;
  if (preview_pt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.HppInfo.preview_pt)
}
inline ::perception::common::Point2f* Roadmarking_HppInfo::release_preview_pt() {
  auto temp = unsafe_arena_release_preview_pt();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_HppInfo::unsafe_arena_release_preview_pt() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.HppInfo.preview_pt)
  
  ::perception::common::Point2f* temp = preview_pt_;
  preview_pt_ = nullptr;
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_HppInfo::_internal_mutable_preview_pt() {
  
  if (preview_pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2f>(GetArena());
    preview_pt_ = p;
  }
  return preview_pt_;
}
inline ::perception::common::Point2f* Roadmarking_HppInfo::mutable_preview_pt() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.HppInfo.preview_pt)
  return _internal_mutable_preview_pt();
}
inline void Roadmarking_HppInfo::set_allocated_preview_pt(::perception::common::Point2f* preview_pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(preview_pt_);
  }
  if (preview_pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(preview_pt)->GetArena();
    if (message_arena != submessage_arena) {
      preview_pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, preview_pt, submessage_arena);
    }
    
  } else {
    
  }
  preview_pt_ = preview_pt;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.HppInfo.preview_pt)
}

// .perception.common.Point2f preview_pt_persp = 12;
inline bool Roadmarking_HppInfo::_internal_has_preview_pt_persp() const {
  return this != internal_default_instance() && preview_pt_persp_ != nullptr;
}
inline bool Roadmarking_HppInfo::has_preview_pt_persp() const {
  return _internal_has_preview_pt_persp();
}
inline const ::perception::common::Point2f& Roadmarking_HppInfo::_internal_preview_pt_persp() const {
  const ::perception::common::Point2f* p = preview_pt_persp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2f*>(
      &::perception::common::_Point2f_default_instance_);
}
inline const ::perception::common::Point2f& Roadmarking_HppInfo::preview_pt_persp() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.preview_pt_persp)
  return _internal_preview_pt_persp();
}
inline void Roadmarking_HppInfo::unsafe_arena_set_allocated_preview_pt_persp(
    ::perception::common::Point2f* preview_pt_persp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(preview_pt_persp_);
  }
  preview_pt_persp_ = preview_pt_persp;
  if (preview_pt_persp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.HppInfo.preview_pt_persp)
}
inline ::perception::common::Point2f* Roadmarking_HppInfo::release_preview_pt_persp() {
  auto temp = unsafe_arena_release_preview_pt_persp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_HppInfo::unsafe_arena_release_preview_pt_persp() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.HppInfo.preview_pt_persp)
  
  ::perception::common::Point2f* temp = preview_pt_persp_;
  preview_pt_persp_ = nullptr;
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_HppInfo::_internal_mutable_preview_pt_persp() {
  
  if (preview_pt_persp_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2f>(GetArena());
    preview_pt_persp_ = p;
  }
  return preview_pt_persp_;
}
inline ::perception::common::Point2f* Roadmarking_HppInfo::mutable_preview_pt_persp() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.HppInfo.preview_pt_persp)
  return _internal_mutable_preview_pt_persp();
}
inline void Roadmarking_HppInfo::set_allocated_preview_pt_persp(::perception::common::Point2f* preview_pt_persp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(preview_pt_persp_);
  }
  if (preview_pt_persp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(preview_pt_persp)->GetArena();
    if (message_arena != submessage_arena) {
      preview_pt_persp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, preview_pt_persp, submessage_arena);
    }
    
  } else {
    
  }
  preview_pt_persp_ = preview_pt_persp;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.HppInfo.preview_pt_persp)
}

// float ego_lane_radius = 13;
inline void Roadmarking_HppInfo::clear_ego_lane_radius() {
  ego_lane_radius_ = 0;
}
inline float Roadmarking_HppInfo::_internal_ego_lane_radius() const {
  return ego_lane_radius_;
}
inline float Roadmarking_HppInfo::ego_lane_radius() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.HppInfo.ego_lane_radius)
  return _internal_ego_lane_radius();
}
inline void Roadmarking_HppInfo::_internal_set_ego_lane_radius(float value) {
  
  ego_lane_radius_ = value;
}
inline void Roadmarking_HppInfo::set_ego_lane_radius(float value) {
  _internal_set_ego_lane_radius(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.HppInfo.ego_lane_radius)
}

// -------------------------------------------------------------------

// Roadmarking_Junction

// .perception.hz.Roadmarking.Junction.Type type = 1;
inline void Roadmarking_Junction::clear_type() {
  type_ = 0;
}
inline ::perception::hz::Roadmarking_Junction_Type Roadmarking_Junction::_internal_type() const {
  return static_cast< ::perception::hz::Roadmarking_Junction_Type >(type_);
}
inline ::perception::hz::Roadmarking_Junction_Type Roadmarking_Junction::type() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Junction.type)
  return _internal_type();
}
inline void Roadmarking_Junction::_internal_set_type(::perception::hz::Roadmarking_Junction_Type value) {
  
  type_ = value;
}
inline void Roadmarking_Junction::set_type(::perception::hz::Roadmarking_Junction_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Junction.type)
}

// .perception.common.Point2f pt_image_coord = 2;
inline bool Roadmarking_Junction::_internal_has_pt_image_coord() const {
  return this != internal_default_instance() && pt_image_coord_ != nullptr;
}
inline bool Roadmarking_Junction::has_pt_image_coord() const {
  return _internal_has_pt_image_coord();
}
inline const ::perception::common::Point2f& Roadmarking_Junction::_internal_pt_image_coord() const {
  const ::perception::common::Point2f* p = pt_image_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2f*>(
      &::perception::common::_Point2f_default_instance_);
}
inline const ::perception::common::Point2f& Roadmarking_Junction::pt_image_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Junction.pt_image_coord)
  return _internal_pt_image_coord();
}
inline void Roadmarking_Junction::unsafe_arena_set_allocated_pt_image_coord(
    ::perception::common::Point2f* pt_image_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pt_image_coord_);
  }
  pt_image_coord_ = pt_image_coord;
  if (pt_image_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Junction.pt_image_coord)
}
inline ::perception::common::Point2f* Roadmarking_Junction::release_pt_image_coord() {
  auto temp = unsafe_arena_release_pt_image_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_Junction::unsafe_arena_release_pt_image_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Junction.pt_image_coord)
  
  ::perception::common::Point2f* temp = pt_image_coord_;
  pt_image_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_Junction::_internal_mutable_pt_image_coord() {
  
  if (pt_image_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2f>(GetArena());
    pt_image_coord_ = p;
  }
  return pt_image_coord_;
}
inline ::perception::common::Point2f* Roadmarking_Junction::mutable_pt_image_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Junction.pt_image_coord)
  return _internal_mutable_pt_image_coord();
}
inline void Roadmarking_Junction::set_allocated_pt_image_coord(::perception::common::Point2f* pt_image_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pt_image_coord_);
  }
  if (pt_image_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pt_image_coord)->GetArena();
    if (message_arena != submessage_arena) {
      pt_image_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pt_image_coord, submessage_arena);
    }
    
  } else {
    
  }
  pt_image_coord_ = pt_image_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Junction.pt_image_coord)
}

// .perception.common.Point2f pt_vehicle_coord = 3;
inline bool Roadmarking_Junction::_internal_has_pt_vehicle_coord() const {
  return this != internal_default_instance() && pt_vehicle_coord_ != nullptr;
}
inline bool Roadmarking_Junction::has_pt_vehicle_coord() const {
  return _internal_has_pt_vehicle_coord();
}
inline const ::perception::common::Point2f& Roadmarking_Junction::_internal_pt_vehicle_coord() const {
  const ::perception::common::Point2f* p = pt_vehicle_coord_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::common::Point2f*>(
      &::perception::common::_Point2f_default_instance_);
}
inline const ::perception::common::Point2f& Roadmarking_Junction::pt_vehicle_coord() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Junction.pt_vehicle_coord)
  return _internal_pt_vehicle_coord();
}
inline void Roadmarking_Junction::unsafe_arena_set_allocated_pt_vehicle_coord(
    ::perception::common::Point2f* pt_vehicle_coord) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pt_vehicle_coord_);
  }
  pt_vehicle_coord_ = pt_vehicle_coord;
  if (pt_vehicle_coord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.Junction.pt_vehicle_coord)
}
inline ::perception::common::Point2f* Roadmarking_Junction::release_pt_vehicle_coord() {
  auto temp = unsafe_arena_release_pt_vehicle_coord();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_Junction::unsafe_arena_release_pt_vehicle_coord() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.Junction.pt_vehicle_coord)
  
  ::perception::common::Point2f* temp = pt_vehicle_coord_;
  pt_vehicle_coord_ = nullptr;
  return temp;
}
inline ::perception::common::Point2f* Roadmarking_Junction::_internal_mutable_pt_vehicle_coord() {
  
  if (pt_vehicle_coord_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::common::Point2f>(GetArena());
    pt_vehicle_coord_ = p;
  }
  return pt_vehicle_coord_;
}
inline ::perception::common::Point2f* Roadmarking_Junction::mutable_pt_vehicle_coord() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.Junction.pt_vehicle_coord)
  return _internal_mutable_pt_vehicle_coord();
}
inline void Roadmarking_Junction::set_allocated_pt_vehicle_coord(::perception::common::Point2f* pt_vehicle_coord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pt_vehicle_coord_);
  }
  if (pt_vehicle_coord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pt_vehicle_coord)->GetArena();
    if (message_arena != submessage_arena) {
      pt_vehicle_coord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pt_vehicle_coord, submessage_arena);
    }
    
  } else {
    
  }
  pt_vehicle_coord_ = pt_vehicle_coord;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.Junction.pt_vehicle_coord)
}

// repeated uint64 laneline_id = 4;
inline int Roadmarking_Junction::_internal_laneline_id_size() const {
  return laneline_id_.size();
}
inline int Roadmarking_Junction::laneline_id_size() const {
  return _internal_laneline_id_size();
}
inline void Roadmarking_Junction::clear_laneline_id() {
  laneline_id_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking_Junction::_internal_laneline_id(int index) const {
  return laneline_id_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking_Junction::laneline_id(int index) const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Junction.laneline_id)
  return _internal_laneline_id(index);
}
inline void Roadmarking_Junction::set_laneline_id(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  laneline_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Junction.laneline_id)
}
inline void Roadmarking_Junction::_internal_add_laneline_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  laneline_id_.Add(value);
}
inline void Roadmarking_Junction::add_laneline_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_laneline_id(value);
  // @@protoc_insertion_point(field_add:perception.hz.Roadmarking.Junction.laneline_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
Roadmarking_Junction::_internal_laneline_id() const {
  return laneline_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
Roadmarking_Junction::laneline_id() const {
  // @@protoc_insertion_point(field_list:perception.hz.Roadmarking.Junction.laneline_id)
  return _internal_laneline_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
Roadmarking_Junction::_internal_mutable_laneline_id() {
  return &laneline_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
Roadmarking_Junction::mutable_laneline_id() {
  // @@protoc_insertion_point(field_mutable_list:perception.hz.Roadmarking.Junction.laneline_id)
  return _internal_mutable_laneline_id();
}

// int32 state = 5;
inline void Roadmarking_Junction::clear_state() {
  state_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Roadmarking_Junction::_internal_state() const {
  return state_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Roadmarking_Junction::state() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Junction.state)
  return _internal_state();
}
inline void Roadmarking_Junction::_internal_set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  state_ = value;
}
inline void Roadmarking_Junction::set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Junction.state)
}

// float confidence = 6;
inline void Roadmarking_Junction::clear_confidence() {
  confidence_ = 0;
}
inline float Roadmarking_Junction::_internal_confidence() const {
  return confidence_;
}
inline float Roadmarking_Junction::confidence() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.Junction.confidence)
  return _internal_confidence();
}
inline void Roadmarking_Junction::_internal_set_confidence(float value) {
  
  confidence_ = value;
}
inline void Roadmarking_Junction::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.Junction.confidence)
}

// -------------------------------------------------------------------

// Roadmarking_JunctionList

// repeated .perception.hz.Roadmarking.Junction junc = 1;
inline int Roadmarking_JunctionList::_internal_junc_size() const {
  return junc_.size();
}
inline int Roadmarking_JunctionList::junc_size() const {
  return _internal_junc_size();
}
inline void Roadmarking_JunctionList::clear_junc() {
  junc_.Clear();
}
inline ::perception::hz::Roadmarking_Junction* Roadmarking_JunctionList::mutable_junc(int index) {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.JunctionList.junc)
  return junc_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Junction >*
Roadmarking_JunctionList::mutable_junc() {
  // @@protoc_insertion_point(field_mutable_list:perception.hz.Roadmarking.JunctionList.junc)
  return &junc_;
}
inline const ::perception::hz::Roadmarking_Junction& Roadmarking_JunctionList::_internal_junc(int index) const {
  return junc_.Get(index);
}
inline const ::perception::hz::Roadmarking_Junction& Roadmarking_JunctionList::junc(int index) const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.JunctionList.junc)
  return _internal_junc(index);
}
inline ::perception::hz::Roadmarking_Junction* Roadmarking_JunctionList::_internal_add_junc() {
  return junc_.Add();
}
inline ::perception::hz::Roadmarking_Junction* Roadmarking_JunctionList::add_junc() {
  // @@protoc_insertion_point(field_add:perception.hz.Roadmarking.JunctionList.junc)
  return _internal_add_junc();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perception::hz::Roadmarking_Junction >&
Roadmarking_JunctionList::junc() const {
  // @@protoc_insertion_point(field_list:perception.hz.Roadmarking.JunctionList.junc)
  return junc_;
}

// -------------------------------------------------------------------

// Roadmarking

// uint64 frame_id = 1;
inline void Roadmarking::clear_frame_id() {
  frame_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking::_internal_frame_id() const {
  return frame_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking::frame_id() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.frame_id)
  return _internal_frame_id();
}
inline void Roadmarking::_internal_set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  frame_id_ = value;
}
inline void Roadmarking::set_frame_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.frame_id)
}

// uint64 timestamp = 2;
inline void Roadmarking::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking::timestamp() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.timestamp)
  return _internal_timestamp();
}
inline void Roadmarking::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void Roadmarking::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.timestamp)
}

// .perception.hz.Roadmarking.LanelineList laneline = 3;
inline bool Roadmarking::_internal_has_laneline() const {
  return this != internal_default_instance() && laneline_ != nullptr;
}
inline bool Roadmarking::has_laneline() const {
  return _internal_has_laneline();
}
inline void Roadmarking::clear_laneline() {
  if (GetArena() == nullptr && laneline_ != nullptr) {
    delete laneline_;
  }
  laneline_ = nullptr;
}
inline const ::perception::hz::Roadmarking_LanelineList& Roadmarking::_internal_laneline() const {
  const ::perception::hz::Roadmarking_LanelineList* p = laneline_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_LanelineList*>(
      &::perception::hz::_Roadmarking_LanelineList_default_instance_);
}
inline const ::perception::hz::Roadmarking_LanelineList& Roadmarking::laneline() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.laneline)
  return _internal_laneline();
}
inline void Roadmarking::unsafe_arena_set_allocated_laneline(
    ::perception::hz::Roadmarking_LanelineList* laneline) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(laneline_);
  }
  laneline_ = laneline;
  if (laneline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.laneline)
}
inline ::perception::hz::Roadmarking_LanelineList* Roadmarking::release_laneline() {
  auto temp = unsafe_arena_release_laneline();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_LanelineList* Roadmarking::unsafe_arena_release_laneline() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.laneline)
  
  ::perception::hz::Roadmarking_LanelineList* temp = laneline_;
  laneline_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_LanelineList* Roadmarking::_internal_mutable_laneline() {
  
  if (laneline_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_LanelineList>(GetArena());
    laneline_ = p;
  }
  return laneline_;
}
inline ::perception::hz::Roadmarking_LanelineList* Roadmarking::mutable_laneline() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.laneline)
  return _internal_mutable_laneline();
}
inline void Roadmarking::set_allocated_laneline(::perception::hz::Roadmarking_LanelineList* laneline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete laneline_;
  }
  if (laneline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(laneline);
    if (message_arena != submessage_arena) {
      laneline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, laneline, submessage_arena);
    }
    
  } else {
    
  }
  laneline_ = laneline;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.laneline)
}

// .perception.hz.Roadmarking.FreeSpaces freespaces = 4;
inline bool Roadmarking::_internal_has_freespaces() const {
  return this != internal_default_instance() && freespaces_ != nullptr;
}
inline bool Roadmarking::has_freespaces() const {
  return _internal_has_freespaces();
}
inline void Roadmarking::clear_freespaces() {
  if (GetArena() == nullptr && freespaces_ != nullptr) {
    delete freespaces_;
  }
  freespaces_ = nullptr;
}
inline const ::perception::hz::Roadmarking_FreeSpaces& Roadmarking::_internal_freespaces() const {
  const ::perception::hz::Roadmarking_FreeSpaces* p = freespaces_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_FreeSpaces*>(
      &::perception::hz::_Roadmarking_FreeSpaces_default_instance_);
}
inline const ::perception::hz::Roadmarking_FreeSpaces& Roadmarking::freespaces() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.freespaces)
  return _internal_freespaces();
}
inline void Roadmarking::unsafe_arena_set_allocated_freespaces(
    ::perception::hz::Roadmarking_FreeSpaces* freespaces) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(freespaces_);
  }
  freespaces_ = freespaces;
  if (freespaces) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.freespaces)
}
inline ::perception::hz::Roadmarking_FreeSpaces* Roadmarking::release_freespaces() {
  auto temp = unsafe_arena_release_freespaces();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_FreeSpaces* Roadmarking::unsafe_arena_release_freespaces() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.freespaces)
  
  ::perception::hz::Roadmarking_FreeSpaces* temp = freespaces_;
  freespaces_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_FreeSpaces* Roadmarking::_internal_mutable_freespaces() {
  
  if (freespaces_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_FreeSpaces>(GetArena());
    freespaces_ = p;
  }
  return freespaces_;
}
inline ::perception::hz::Roadmarking_FreeSpaces* Roadmarking::mutable_freespaces() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.freespaces)
  return _internal_mutable_freespaces();
}
inline void Roadmarking::set_allocated_freespaces(::perception::hz::Roadmarking_FreeSpaces* freespaces) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete freespaces_;
  }
  if (freespaces) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(freespaces);
    if (message_arena != submessage_arena) {
      freespaces = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, freespaces, submessage_arena);
    }
    
  } else {
    
  }
  freespaces_ = freespaces;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.freespaces)
}

// .perception.hz.Roadmarking.Roadmarks roadmarkers = 6;
inline bool Roadmarking::_internal_has_roadmarkers() const {
  return this != internal_default_instance() && roadmarkers_ != nullptr;
}
inline bool Roadmarking::has_roadmarkers() const {
  return _internal_has_roadmarkers();
}
inline void Roadmarking::clear_roadmarkers() {
  if (GetArena() == nullptr && roadmarkers_ != nullptr) {
    delete roadmarkers_;
  }
  roadmarkers_ = nullptr;
}
inline const ::perception::hz::Roadmarking_Roadmarks& Roadmarking::_internal_roadmarkers() const {
  const ::perception::hz::Roadmarking_Roadmarks* p = roadmarkers_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_Roadmarks*>(
      &::perception::hz::_Roadmarking_Roadmarks_default_instance_);
}
inline const ::perception::hz::Roadmarking_Roadmarks& Roadmarking::roadmarkers() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.roadmarkers)
  return _internal_roadmarkers();
}
inline void Roadmarking::unsafe_arena_set_allocated_roadmarkers(
    ::perception::hz::Roadmarking_Roadmarks* roadmarkers) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roadmarkers_);
  }
  roadmarkers_ = roadmarkers;
  if (roadmarkers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.roadmarkers)
}
inline ::perception::hz::Roadmarking_Roadmarks* Roadmarking::release_roadmarkers() {
  auto temp = unsafe_arena_release_roadmarkers();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_Roadmarks* Roadmarking::unsafe_arena_release_roadmarkers() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.roadmarkers)
  
  ::perception::hz::Roadmarking_Roadmarks* temp = roadmarkers_;
  roadmarkers_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_Roadmarks* Roadmarking::_internal_mutable_roadmarkers() {
  
  if (roadmarkers_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_Roadmarks>(GetArena());
    roadmarkers_ = p;
  }
  return roadmarkers_;
}
inline ::perception::hz::Roadmarking_Roadmarks* Roadmarking::mutable_roadmarkers() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.roadmarkers)
  return _internal_mutable_roadmarkers();
}
inline void Roadmarking::set_allocated_roadmarkers(::perception::hz::Roadmarking_Roadmarks* roadmarkers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete roadmarkers_;
  }
  if (roadmarkers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(roadmarkers);
    if (message_arena != submessage_arena) {
      roadmarkers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roadmarkers, submessage_arena);
    }
    
  } else {
    
  }
  roadmarkers_ = roadmarkers;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.roadmarkers)
}

// .perception.hz.Roadmarking.RoadEdgeList road_edges = 7;
inline bool Roadmarking::_internal_has_road_edges() const {
  return this != internal_default_instance() && road_edges_ != nullptr;
}
inline bool Roadmarking::has_road_edges() const {
  return _internal_has_road_edges();
}
inline void Roadmarking::clear_road_edges() {
  if (GetArena() == nullptr && road_edges_ != nullptr) {
    delete road_edges_;
  }
  road_edges_ = nullptr;
}
inline const ::perception::hz::Roadmarking_RoadEdgeList& Roadmarking::_internal_road_edges() const {
  const ::perception::hz::Roadmarking_RoadEdgeList* p = road_edges_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_RoadEdgeList*>(
      &::perception::hz::_Roadmarking_RoadEdgeList_default_instance_);
}
inline const ::perception::hz::Roadmarking_RoadEdgeList& Roadmarking::road_edges() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.road_edges)
  return _internal_road_edges();
}
inline void Roadmarking::unsafe_arena_set_allocated_road_edges(
    ::perception::hz::Roadmarking_RoadEdgeList* road_edges) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(road_edges_);
  }
  road_edges_ = road_edges;
  if (road_edges) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.road_edges)
}
inline ::perception::hz::Roadmarking_RoadEdgeList* Roadmarking::release_road_edges() {
  auto temp = unsafe_arena_release_road_edges();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_RoadEdgeList* Roadmarking::unsafe_arena_release_road_edges() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.road_edges)
  
  ::perception::hz::Roadmarking_RoadEdgeList* temp = road_edges_;
  road_edges_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_RoadEdgeList* Roadmarking::_internal_mutable_road_edges() {
  
  if (road_edges_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_RoadEdgeList>(GetArena());
    road_edges_ = p;
  }
  return road_edges_;
}
inline ::perception::hz::Roadmarking_RoadEdgeList* Roadmarking::mutable_road_edges() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.road_edges)
  return _internal_mutable_road_edges();
}
inline void Roadmarking::set_allocated_road_edges(::perception::hz::Roadmarking_RoadEdgeList* road_edges) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete road_edges_;
  }
  if (road_edges) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(road_edges);
    if (message_arena != submessage_arena) {
      road_edges = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, road_edges, submessage_arena);
    }
    
  } else {
    
  }
  road_edges_ = road_edges;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.road_edges)
}

// .perception.hz.Roadmarking.LDWInfo ldw_info = 8;
inline bool Roadmarking::_internal_has_ldw_info() const {
  return this != internal_default_instance() && ldw_info_ != nullptr;
}
inline bool Roadmarking::has_ldw_info() const {
  return _internal_has_ldw_info();
}
inline void Roadmarking::clear_ldw_info() {
  if (GetArena() == nullptr && ldw_info_ != nullptr) {
    delete ldw_info_;
  }
  ldw_info_ = nullptr;
}
inline const ::perception::hz::Roadmarking_LDWInfo& Roadmarking::_internal_ldw_info() const {
  const ::perception::hz::Roadmarking_LDWInfo* p = ldw_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_LDWInfo*>(
      &::perception::hz::_Roadmarking_LDWInfo_default_instance_);
}
inline const ::perception::hz::Roadmarking_LDWInfo& Roadmarking::ldw_info() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.ldw_info)
  return _internal_ldw_info();
}
inline void Roadmarking::unsafe_arena_set_allocated_ldw_info(
    ::perception::hz::Roadmarking_LDWInfo* ldw_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ldw_info_);
  }
  ldw_info_ = ldw_info;
  if (ldw_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.ldw_info)
}
inline ::perception::hz::Roadmarking_LDWInfo* Roadmarking::release_ldw_info() {
  auto temp = unsafe_arena_release_ldw_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_LDWInfo* Roadmarking::unsafe_arena_release_ldw_info() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.ldw_info)
  
  ::perception::hz::Roadmarking_LDWInfo* temp = ldw_info_;
  ldw_info_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_LDWInfo* Roadmarking::_internal_mutable_ldw_info() {
  
  if (ldw_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_LDWInfo>(GetArena());
    ldw_info_ = p;
  }
  return ldw_info_;
}
inline ::perception::hz::Roadmarking_LDWInfo* Roadmarking::mutable_ldw_info() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.ldw_info)
  return _internal_mutable_ldw_info();
}
inline void Roadmarking::set_allocated_ldw_info(::perception::hz::Roadmarking_LDWInfo* ldw_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ldw_info_;
  }
  if (ldw_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ldw_info);
    if (message_arena != submessage_arena) {
      ldw_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ldw_info, submessage_arena);
    }
    
  } else {
    
  }
  ldw_info_ = ldw_info;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.ldw_info)
}

// .perception.hz.Roadmarking.LanelineList calib_lines = 9;
inline bool Roadmarking::_internal_has_calib_lines() const {
  return this != internal_default_instance() && calib_lines_ != nullptr;
}
inline bool Roadmarking::has_calib_lines() const {
  return _internal_has_calib_lines();
}
inline void Roadmarking::clear_calib_lines() {
  if (GetArena() == nullptr && calib_lines_ != nullptr) {
    delete calib_lines_;
  }
  calib_lines_ = nullptr;
}
inline const ::perception::hz::Roadmarking_LanelineList& Roadmarking::_internal_calib_lines() const {
  const ::perception::hz::Roadmarking_LanelineList* p = calib_lines_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_LanelineList*>(
      &::perception::hz::_Roadmarking_LanelineList_default_instance_);
}
inline const ::perception::hz::Roadmarking_LanelineList& Roadmarking::calib_lines() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.calib_lines)
  return _internal_calib_lines();
}
inline void Roadmarking::unsafe_arena_set_allocated_calib_lines(
    ::perception::hz::Roadmarking_LanelineList* calib_lines) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(calib_lines_);
  }
  calib_lines_ = calib_lines;
  if (calib_lines) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.calib_lines)
}
inline ::perception::hz::Roadmarking_LanelineList* Roadmarking::release_calib_lines() {
  auto temp = unsafe_arena_release_calib_lines();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_LanelineList* Roadmarking::unsafe_arena_release_calib_lines() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.calib_lines)
  
  ::perception::hz::Roadmarking_LanelineList* temp = calib_lines_;
  calib_lines_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_LanelineList* Roadmarking::_internal_mutable_calib_lines() {
  
  if (calib_lines_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_LanelineList>(GetArena());
    calib_lines_ = p;
  }
  return calib_lines_;
}
inline ::perception::hz::Roadmarking_LanelineList* Roadmarking::mutable_calib_lines() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.calib_lines)
  return _internal_mutable_calib_lines();
}
inline void Roadmarking::set_allocated_calib_lines(::perception::hz::Roadmarking_LanelineList* calib_lines) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete calib_lines_;
  }
  if (calib_lines) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(calib_lines);
    if (message_arena != submessage_arena) {
      calib_lines = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, calib_lines, submessage_arena);
    }
    
  } else {
    
  }
  calib_lines_ = calib_lines;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.calib_lines)
}

// .perception.hz.Roadmarking.MotionEst motion = 10;
inline bool Roadmarking::_internal_has_motion() const {
  return this != internal_default_instance() && motion_ != nullptr;
}
inline bool Roadmarking::has_motion() const {
  return _internal_has_motion();
}
inline void Roadmarking::clear_motion() {
  if (GetArena() == nullptr && motion_ != nullptr) {
    delete motion_;
  }
  motion_ = nullptr;
}
inline const ::perception::hz::Roadmarking_MotionEst& Roadmarking::_internal_motion() const {
  const ::perception::hz::Roadmarking_MotionEst* p = motion_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_MotionEst*>(
      &::perception::hz::_Roadmarking_MotionEst_default_instance_);
}
inline const ::perception::hz::Roadmarking_MotionEst& Roadmarking::motion() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.motion)
  return _internal_motion();
}
inline void Roadmarking::unsafe_arena_set_allocated_motion(
    ::perception::hz::Roadmarking_MotionEst* motion) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_);
  }
  motion_ = motion;
  if (motion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.motion)
}
inline ::perception::hz::Roadmarking_MotionEst* Roadmarking::release_motion() {
  auto temp = unsafe_arena_release_motion();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_MotionEst* Roadmarking::unsafe_arena_release_motion() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.motion)
  
  ::perception::hz::Roadmarking_MotionEst* temp = motion_;
  motion_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_MotionEst* Roadmarking::_internal_mutable_motion() {
  
  if (motion_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_MotionEst>(GetArena());
    motion_ = p;
  }
  return motion_;
}
inline ::perception::hz::Roadmarking_MotionEst* Roadmarking::mutable_motion() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.motion)
  return _internal_mutable_motion();
}
inline void Roadmarking::set_allocated_motion(::perception::hz::Roadmarking_MotionEst* motion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete motion_;
  }
  if (motion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(motion);
    if (message_arena != submessage_arena) {
      motion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motion, submessage_arena);
    }
    
  } else {
    
  }
  motion_ = motion;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.motion)
}

// .perception.hz.Roadmarking.PoseEst pose = 11;
inline bool Roadmarking::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool Roadmarking::has_pose() const {
  return _internal_has_pose();
}
inline void Roadmarking::clear_pose() {
  if (GetArena() == nullptr && pose_ != nullptr) {
    delete pose_;
  }
  pose_ = nullptr;
}
inline const ::perception::hz::Roadmarking_PoseEst& Roadmarking::_internal_pose() const {
  const ::perception::hz::Roadmarking_PoseEst* p = pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_PoseEst*>(
      &::perception::hz::_Roadmarking_PoseEst_default_instance_);
}
inline const ::perception::hz::Roadmarking_PoseEst& Roadmarking::pose() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.pose)
  return _internal_pose();
}
inline void Roadmarking::unsafe_arena_set_allocated_pose(
    ::perception::hz::Roadmarking_PoseEst* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.pose)
}
inline ::perception::hz::Roadmarking_PoseEst* Roadmarking::release_pose() {
  auto temp = unsafe_arena_release_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_PoseEst* Roadmarking::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.pose)
  
  ::perception::hz::Roadmarking_PoseEst* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_PoseEst* Roadmarking::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_PoseEst>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::perception::hz::Roadmarking_PoseEst* Roadmarking::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.pose)
  return _internal_mutable_pose();
}
inline void Roadmarking::set_allocated_pose(::perception::hz::Roadmarking_PoseEst* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.pose)
}

// .perception.hz.Roadmarking.HppInfo hpp_info = 12;
inline bool Roadmarking::_internal_has_hpp_info() const {
  return this != internal_default_instance() && hpp_info_ != nullptr;
}
inline bool Roadmarking::has_hpp_info() const {
  return _internal_has_hpp_info();
}
inline void Roadmarking::clear_hpp_info() {
  if (GetArena() == nullptr && hpp_info_ != nullptr) {
    delete hpp_info_;
  }
  hpp_info_ = nullptr;
}
inline const ::perception::hz::Roadmarking_HppInfo& Roadmarking::_internal_hpp_info() const {
  const ::perception::hz::Roadmarking_HppInfo* p = hpp_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_HppInfo*>(
      &::perception::hz::_Roadmarking_HppInfo_default_instance_);
}
inline const ::perception::hz::Roadmarking_HppInfo& Roadmarking::hpp_info() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.hpp_info)
  return _internal_hpp_info();
}
inline void Roadmarking::unsafe_arena_set_allocated_hpp_info(
    ::perception::hz::Roadmarking_HppInfo* hpp_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hpp_info_);
  }
  hpp_info_ = hpp_info;
  if (hpp_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.hpp_info)
}
inline ::perception::hz::Roadmarking_HppInfo* Roadmarking::release_hpp_info() {
  auto temp = unsafe_arena_release_hpp_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_HppInfo* Roadmarking::unsafe_arena_release_hpp_info() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.hpp_info)
  
  ::perception::hz::Roadmarking_HppInfo* temp = hpp_info_;
  hpp_info_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_HppInfo* Roadmarking::_internal_mutable_hpp_info() {
  
  if (hpp_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_HppInfo>(GetArena());
    hpp_info_ = p;
  }
  return hpp_info_;
}
inline ::perception::hz::Roadmarking_HppInfo* Roadmarking::mutable_hpp_info() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.hpp_info)
  return _internal_mutable_hpp_info();
}
inline void Roadmarking::set_allocated_hpp_info(::perception::hz::Roadmarking_HppInfo* hpp_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hpp_info_;
  }
  if (hpp_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hpp_info);
    if (message_arena != submessage_arena) {
      hpp_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hpp_info, submessage_arena);
    }
    
  } else {
    
  }
  hpp_info_ = hpp_info;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.hpp_info)
}

// uint64 tick = 13;
inline void Roadmarking::clear_tick() {
  tick_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking::_internal_tick() const {
  return tick_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking::tick() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.tick)
  return _internal_tick();
}
inline void Roadmarking::_internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  tick_ = value;
}
inline void Roadmarking::set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.tick)
}

// .minieye.DataSource data_source = 14;
inline void Roadmarking::clear_data_source() {
  data_source_ = 0;
}
inline ::minieye::DataSource Roadmarking::_internal_data_source() const {
  return static_cast< ::minieye::DataSource >(data_source_);
}
inline ::minieye::DataSource Roadmarking::data_source() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.data_source)
  return _internal_data_source();
}
inline void Roadmarking::_internal_set_data_source(::minieye::DataSource value) {
  
  data_source_ = value;
}
inline void Roadmarking::set_data_source(::minieye::DataSource value) {
  _internal_set_data_source(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.data_source)
}

// .perception.hz.Roadmarking.CurveCoeff slope_equation = 15;
inline bool Roadmarking::_internal_has_slope_equation() const {
  return this != internal_default_instance() && slope_equation_ != nullptr;
}
inline bool Roadmarking::has_slope_equation() const {
  return _internal_has_slope_equation();
}
inline void Roadmarking::clear_slope_equation() {
  if (GetArena() == nullptr && slope_equation_ != nullptr) {
    delete slope_equation_;
  }
  slope_equation_ = nullptr;
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking::_internal_slope_equation() const {
  const ::perception::hz::Roadmarking_CurveCoeff* p = slope_equation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_CurveCoeff*>(
      &::perception::hz::_Roadmarking_CurveCoeff_default_instance_);
}
inline const ::perception::hz::Roadmarking_CurveCoeff& Roadmarking::slope_equation() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.slope_equation)
  return _internal_slope_equation();
}
inline void Roadmarking::unsafe_arena_set_allocated_slope_equation(
    ::perception::hz::Roadmarking_CurveCoeff* slope_equation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slope_equation_);
  }
  slope_equation_ = slope_equation;
  if (slope_equation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.slope_equation)
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking::release_slope_equation() {
  auto temp = unsafe_arena_release_slope_equation();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking::unsafe_arena_release_slope_equation() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.slope_equation)
  
  ::perception::hz::Roadmarking_CurveCoeff* temp = slope_equation_;
  slope_equation_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking::_internal_mutable_slope_equation() {
  
  if (slope_equation_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_CurveCoeff>(GetArena());
    slope_equation_ = p;
  }
  return slope_equation_;
}
inline ::perception::hz::Roadmarking_CurveCoeff* Roadmarking::mutable_slope_equation() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.slope_equation)
  return _internal_mutable_slope_equation();
}
inline void Roadmarking::set_allocated_slope_equation(::perception::hz::Roadmarking_CurveCoeff* slope_equation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete slope_equation_;
  }
  if (slope_equation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(slope_equation);
    if (message_arena != submessage_arena) {
      slope_equation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slope_equation, submessage_arena);
    }
    
  } else {
    
  }
  slope_equation_ = slope_equation;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.slope_equation)
}

// uint64 finish_time = 16;
inline void Roadmarking::clear_finish_time() {
  finish_time_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking::_internal_finish_time() const {
  return finish_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking::finish_time() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.finish_time)
  return _internal_finish_time();
}
inline void Roadmarking::_internal_set_finish_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  finish_time_ = value;
}
inline void Roadmarking::set_finish_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_finish_time(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.finish_time)
}

// .perception.hz.Roadmarking.JunctionList junc_list = 17;
inline bool Roadmarking::_internal_has_junc_list() const {
  return this != internal_default_instance() && junc_list_ != nullptr;
}
inline bool Roadmarking::has_junc_list() const {
  return _internal_has_junc_list();
}
inline void Roadmarking::clear_junc_list() {
  if (GetArena() == nullptr && junc_list_ != nullptr) {
    delete junc_list_;
  }
  junc_list_ = nullptr;
}
inline const ::perception::hz::Roadmarking_JunctionList& Roadmarking::_internal_junc_list() const {
  const ::perception::hz::Roadmarking_JunctionList* p = junc_list_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::Roadmarking_JunctionList*>(
      &::perception::hz::_Roadmarking_JunctionList_default_instance_);
}
inline const ::perception::hz::Roadmarking_JunctionList& Roadmarking::junc_list() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.junc_list)
  return _internal_junc_list();
}
inline void Roadmarking::unsafe_arena_set_allocated_junc_list(
    ::perception::hz::Roadmarking_JunctionList* junc_list) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(junc_list_);
  }
  junc_list_ = junc_list;
  if (junc_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.junc_list)
}
inline ::perception::hz::Roadmarking_JunctionList* Roadmarking::release_junc_list() {
  auto temp = unsafe_arena_release_junc_list();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::Roadmarking_JunctionList* Roadmarking::unsafe_arena_release_junc_list() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.junc_list)
  
  ::perception::hz::Roadmarking_JunctionList* temp = junc_list_;
  junc_list_ = nullptr;
  return temp;
}
inline ::perception::hz::Roadmarking_JunctionList* Roadmarking::_internal_mutable_junc_list() {
  
  if (junc_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::Roadmarking_JunctionList>(GetArena());
    junc_list_ = p;
  }
  return junc_list_;
}
inline ::perception::hz::Roadmarking_JunctionList* Roadmarking::mutable_junc_list() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.junc_list)
  return _internal_mutable_junc_list();
}
inline void Roadmarking::set_allocated_junc_list(::perception::hz::Roadmarking_JunctionList* junc_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete junc_list_;
  }
  if (junc_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(junc_list);
    if (message_arena != submessage_arena) {
      junc_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, junc_list, submessage_arena);
    }
    
  } else {
    
  }
  junc_list_ = junc_list;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.junc_list)
}

// .perception.hz.RoadSysProfiling profiling_items = 18;
inline bool Roadmarking::_internal_has_profiling_items() const {
  return this != internal_default_instance() && profiling_items_ != nullptr;
}
inline bool Roadmarking::has_profiling_items() const {
  return _internal_has_profiling_items();
}
inline void Roadmarking::clear_profiling_items() {
  if (GetArena() == nullptr && profiling_items_ != nullptr) {
    delete profiling_items_;
  }
  profiling_items_ = nullptr;
}
inline const ::perception::hz::RoadSysProfiling& Roadmarking::_internal_profiling_items() const {
  const ::perception::hz::RoadSysProfiling* p = profiling_items_;
  return p != nullptr ? *p : *reinterpret_cast<const ::perception::hz::RoadSysProfiling*>(
      &::perception::hz::_RoadSysProfiling_default_instance_);
}
inline const ::perception::hz::RoadSysProfiling& Roadmarking::profiling_items() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.profiling_items)
  return _internal_profiling_items();
}
inline void Roadmarking::unsafe_arena_set_allocated_profiling_items(
    ::perception::hz::RoadSysProfiling* profiling_items) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(profiling_items_);
  }
  profiling_items_ = profiling_items;
  if (profiling_items) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.profiling_items)
}
inline ::perception::hz::RoadSysProfiling* Roadmarking::release_profiling_items() {
  auto temp = unsafe_arena_release_profiling_items();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::perception::hz::RoadSysProfiling* Roadmarking::unsafe_arena_release_profiling_items() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.profiling_items)
  
  ::perception::hz::RoadSysProfiling* temp = profiling_items_;
  profiling_items_ = nullptr;
  return temp;
}
inline ::perception::hz::RoadSysProfiling* Roadmarking::_internal_mutable_profiling_items() {
  
  if (profiling_items_ == nullptr) {
    auto* p = CreateMaybeMessage<::perception::hz::RoadSysProfiling>(GetArena());
    profiling_items_ = p;
  }
  return profiling_items_;
}
inline ::perception::hz::RoadSysProfiling* Roadmarking::mutable_profiling_items() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.profiling_items)
  return _internal_mutable_profiling_items();
}
inline void Roadmarking::set_allocated_profiling_items(::perception::hz::RoadSysProfiling* profiling_items) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete profiling_items_;
  }
  if (profiling_items) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(profiling_items);
    if (message_arena != submessage_arena) {
      profiling_items = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profiling_items, submessage_arena);
    }
    
  } else {
    
  }
  profiling_items_ = profiling_items;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.profiling_items)
}

// uint64 recv_time = 19;
inline void Roadmarking::clear_recv_time() {
  recv_time_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking::_internal_recv_time() const {
  return recv_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Roadmarking::recv_time() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.recv_time)
  return _internal_recv_time();
}
inline void Roadmarking::_internal_set_recv_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  recv_time_ = value;
}
inline void Roadmarking::set_recv_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_recv_time(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.recv_time)
}

// float fps = 20;
inline void Roadmarking::clear_fps() {
  fps_ = 0;
}
inline float Roadmarking::_internal_fps() const {
  return fps_;
}
inline float Roadmarking::fps() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.fps)
  return _internal_fps();
}
inline void Roadmarking::_internal_set_fps(float value) {
  
  fps_ = value;
}
inline void Roadmarking::set_fps(float value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.fps)
}

// .minieye.EgoMotion ego_motion = 21;
inline bool Roadmarking::_internal_has_ego_motion() const {
  return this != internal_default_instance() && ego_motion_ != nullptr;
}
inline bool Roadmarking::has_ego_motion() const {
  return _internal_has_ego_motion();
}
inline const ::minieye::EgoMotion& Roadmarking::_internal_ego_motion() const {
  const ::minieye::EgoMotion* p = ego_motion_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::EgoMotion*>(
      &::minieye::_EgoMotion_default_instance_);
}
inline const ::minieye::EgoMotion& Roadmarking::ego_motion() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.ego_motion)
  return _internal_ego_motion();
}
inline void Roadmarking::unsafe_arena_set_allocated_ego_motion(
    ::minieye::EgoMotion* ego_motion) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ego_motion_);
  }
  ego_motion_ = ego_motion;
  if (ego_motion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.ego_motion)
}
inline ::minieye::EgoMotion* Roadmarking::release_ego_motion() {
  auto temp = unsafe_arena_release_ego_motion();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::EgoMotion* Roadmarking::unsafe_arena_release_ego_motion() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.ego_motion)
  
  ::minieye::EgoMotion* temp = ego_motion_;
  ego_motion_ = nullptr;
  return temp;
}
inline ::minieye::EgoMotion* Roadmarking::_internal_mutable_ego_motion() {
  
  if (ego_motion_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::EgoMotion>(GetArena());
    ego_motion_ = p;
  }
  return ego_motion_;
}
inline ::minieye::EgoMotion* Roadmarking::mutable_ego_motion() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.ego_motion)
  return _internal_mutable_ego_motion();
}
inline void Roadmarking::set_allocated_ego_motion(::minieye::EgoMotion* ego_motion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ego_motion_);
  }
  if (ego_motion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ego_motion)->GetArena();
    if (message_arena != submessage_arena) {
      ego_motion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ego_motion, submessage_arena);
    }
    
  } else {
    
  }
  ego_motion_ = ego_motion;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.ego_motion)
}

// float ego_lane_width = 22;
inline void Roadmarking::clear_ego_lane_width() {
  ego_lane_width_ = 0;
}
inline float Roadmarking::_internal_ego_lane_width() const {
  return ego_lane_width_;
}
inline float Roadmarking::ego_lane_width() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.ego_lane_width)
  return _internal_ego_lane_width();
}
inline void Roadmarking::_internal_set_ego_lane_width(float value) {
  
  ego_lane_width_ = value;
}
inline void Roadmarking::set_ego_lane_width(float value) {
  _internal_set_ego_lane_width(value);
  // @@protoc_insertion_point(field_set:perception.hz.Roadmarking.ego_lane_width)
}

// .minieye.CamID cam_id = 23;
inline bool Roadmarking::_internal_has_cam_id() const {
  return this != internal_default_instance() && cam_id_ != nullptr;
}
inline bool Roadmarking::has_cam_id() const {
  return _internal_has_cam_id();
}
inline const ::minieye::CamID& Roadmarking::_internal_cam_id() const {
  const ::minieye::CamID* p = cam_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::minieye::CamID*>(
      &::minieye::_CamID_default_instance_);
}
inline const ::minieye::CamID& Roadmarking::cam_id() const {
  // @@protoc_insertion_point(field_get:perception.hz.Roadmarking.cam_id)
  return _internal_cam_id();
}
inline void Roadmarking::unsafe_arena_set_allocated_cam_id(
    ::minieye::CamID* cam_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cam_id_);
  }
  cam_id_ = cam_id;
  if (cam_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perception.hz.Roadmarking.cam_id)
}
inline ::minieye::CamID* Roadmarking::release_cam_id() {
  auto temp = unsafe_arena_release_cam_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::minieye::CamID* Roadmarking::unsafe_arena_release_cam_id() {
  // @@protoc_insertion_point(field_release:perception.hz.Roadmarking.cam_id)
  
  ::minieye::CamID* temp = cam_id_;
  cam_id_ = nullptr;
  return temp;
}
inline ::minieye::CamID* Roadmarking::_internal_mutable_cam_id() {
  
  if (cam_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::minieye::CamID>(GetArena());
    cam_id_ = p;
  }
  return cam_id_;
}
inline ::minieye::CamID* Roadmarking::mutable_cam_id() {
  // @@protoc_insertion_point(field_mutable:perception.hz.Roadmarking.cam_id)
  return _internal_mutable_cam_id();
}
inline void Roadmarking::set_allocated_cam_id(::minieye::CamID* cam_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cam_id_);
  }
  if (cam_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cam_id)->GetArena();
    if (message_arena != submessage_arena) {
      cam_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cam_id, submessage_arena);
    }
    
  } else {
    
  }
  cam_id_ = cam_id;
  // @@protoc_insertion_point(field_set_allocated:perception.hz.Roadmarking.cam_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hz
}  // namespace perception

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::perception::hz::Roadmarking_FreeSpaces_MotionProp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_FreeSpaces_MotionProp>() {
  return ::perception::hz::Roadmarking_FreeSpaces_MotionProp_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_Roadmarks_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_Roadmarks_Type>() {
  return ::perception::hz::Roadmarking_Roadmarks_Type_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_Roadmarks_Form> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_Roadmarks_Form>() {
  return ::perception::hz::Roadmarking_Roadmarks_Form_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_Roadmarks_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_Roadmarks_State>() {
  return ::perception::hz::Roadmarking_Roadmarks_State_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_LDWInfo_LdwState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_LDWInfo_LdwState>() {
  return ::perception::hz::Roadmarking_LDWInfo_LdwState_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_LDWInfo_LdwWorkState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_LDWInfo_LdwWorkState>() {
  return ::perception::hz::Roadmarking_LDWInfo_LdwWorkState_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_HppInfo_PlanningSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_HppInfo_PlanningSource>() {
  return ::perception::hz::Roadmarking_HppInfo_PlanningSource_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_Junction_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_Junction_Type>() {
  return ::perception::hz::Roadmarking_Junction_Type_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_LanelinePositionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_LanelinePositionType>() {
  return ::perception::hz::Roadmarking_LanelinePositionType_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_LineType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_LineType>() {
  return ::perception::hz::Roadmarking_LineType_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_ColorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_ColorType>() {
  return ::perception::hz::Roadmarking_ColorType_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_LineState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_LineState>() {
  return ::perception::hz::Roadmarking_LineState_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_LaneIdx> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_LaneIdx>() {
  return ::perception::hz::Roadmarking_LaneIdx_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_SpaceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_SpaceType>() {
  return ::perception::hz::Roadmarking_SpaceType_descriptor();
}
template <> struct is_proto_enum< ::perception::hz::Roadmarking_DirectPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::perception::hz::Roadmarking_DirectPosition>() {
  return ::perception::hz::Roadmarking_DirectPosition_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_roadmarking_5fhz_2eproto
